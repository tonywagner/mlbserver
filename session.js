#!/usr/bin/env node

// session.js defines the session class which handles API activity

// Required Node packages for the session class
const fs = require('fs')
const path = require('path')
const readlineSync = require('readline-sync')
const FileCookieStore = require('tough-cookie-filestore')
const parseString = require('xml2js').parseString

const MULTIVIEW_DIRECTORY_NAME = 'multiview'

// Default user agent to use for API requests
const USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36'

// Other variables to use in API communications
const GRAPHQL_URL = 'https://media-gateway.mlb.com/graphql'

// Default date handling
const TODAY_UTC_HOURS = 8 // UTC hours (EST + 4) into tomorrow to still use today's date

const TEAM_IDS = { 'ATH': '133', 'ATL': '144', 'AZ': '109', 'BAL': '110', 'BOS': '111', 'CHC': '112', 'CWS': '145', 'CIN': '113', 'CLE': '114', 'COL': '115', 'DET': '116', 'HOU': '117', 'KC': '118', 'LAA': '108', 'LAD': '119', 'MIA': '146', 'MIL': '158', 'MIN': '142', 'NYM': '121', 'NYY': '147', 'PHI': '143', 'PIT': '134', 'STL': '138', 'SD': '135', 'SF': '137', 'SEA': '136', 'TB': '139', 'TEX': '140', 'TOR': '141', 'WSH': '120' }

const LIDOM_TEAM_IDS = { 'AGU': '667', 'TOR': '668', 'EST': '669', 'GIG': '670', 'ESC': '671', 'LIC': '672' }

const AFFILIATE_TEAM_IDS = { 'ATH': '237,400,499,524', 'ATL': '431,432,478,6325', 'AZ': '419,516,2310,5368', 'BAL': '418,488,548,568', 'BOS': '414,428,533,546', 'CHC': '451,521,550,553', 'CIN': '416,450,459,498', 'CLE': '402,437,445,481', 'COL': '259,342,486,538', 'CWS': '247,487,494,580', 'DET': '106,512,570,582', 'HOU': '482,573,3712,5434', 'KC': '541,565,1350,3705', 'LAA': '401,460,559,561', 'LAD': '238,260,456,526', 'MIA': '479,554,564,4124', 'MIL': '249,556,572,5015', 'MIN': '492,509,1960,3898', 'NYM': '453,505,507,552', 'NYY': '531,537,587,1956', 'PHI': '427,522,566,1410', 'PIT': '452,477,484,3390', 'SD': '103,510,584,4904', 'SEA': '403,515,529,574', 'SF': '105,461,476,3410', 'STL': '235,279,440,443', 'TB': '233,234,421,2498', 'TEX': '102,448,540,6324', 'TOR': '422,424,435,463', 'WSH': '426,436,534,547' }

// First is default level, last should be All (also used as default org)
const LEVELS = { 'MLB': '1', 'AAA': '11', 'AA': '12', 'A+': '13', 'A': '14', 'WINTER': '17', 'All': '1,11,12,13,14,17' }

// Winter Leagues
const AFL_ID = '119'
const LIDOM_ID = '131'
const WINTER_LEAGUES = [AFL_ID, LIDOM_ID]

const OFF_AIR_LOGO = 'https://lh3.googleusercontent.com/uVJBX-jpgwHsDY_o6-po2JU5-cDZuoq_CsCcqJ0-T7996z8NbOzeQCfQaAG0DB2hbkxv2VvtZ2E'

// These are the events to ignore, if we're skipping breaks
const BREAK_TYPES = ['Game Advisory', 'Pitching Substitution', 'Offensive Substitution', 'Defensive Sub', 'Defensive Switch', 'Runner Placed On Base']
// These are the events to keep, in addition to the last event of each at-bat, if we're skipping pitches
const ACTION_TYPES = ['Wild Pitch', 'Passed Ball', 'Stolen Base', 'Caught Stealing', 'Pickoff', 'Error', 'Out', 'Balk', 'Defensive Indiff', 'Other Advance']
// These are some idle events to skip
const IDLE_TYPES = ['Mound Visit', 'Batter Timeout', 'Pitcher Step Off', 'challenge']
const EVENT_START_PADDING = -3
const PITCH_END_PADDING = 2
const ACTION_END_PADDING = 7
const MINIMUM_BREAK_DURATION = 5
// hardcode extra padding for MLB events
const MLB_PADDING = 2
// hardcode extra Game Changer padding for MLB, in 10-second increments as needed
const MLB_GAMECHANGER_PADDING = 0

// Base situation table for Stream Finder
const BASESIT_TABLE = {
  '0': {
    '0': {
      '0': 1,
      '1': 5
    },
    '1': {
      '0': 3,
      '1': 7
    }
  },
  '1': {
    '0': {
      '0': 2,
      '1': 6
    },
    '1': {
      '0': 4,
      '1': 8
    }
  }
}

const LI_TABLE = {
    1: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.6, 0.7, 0.8, 0.9, 0.0, 0.0, 0.0, 0.0],
                1: [0.3, 0.4, 0.5, 0.6, 0.6, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.3, 0.3, 0.4, 0.4, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ _": {
                0: [0.7, 0.9, 1.1, 1.3, 1.4, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 0.7, 0.9, 1.0, 1.1, 0.0, 0.0, 0.0, 0.0],
                2: [0.4, 0.5, 0.6, 0.7, 0.8, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 _": {
                0: [0.6, 0.7, 0.9, 1.0, 1.2, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 0.8, 0.9, 1.1, 1.2, 0.0, 0.0, 0.0, 0.0],
                2: [0.6, 0.7, 0.9, 1.0, 1.1, 0.0, 0.0, 0.0, 0.0],
            },
            "_ _ 3": {
                0: [0.5, 0.6, 0.8, 0.9, 1.0, 0.0, 0.0, 0.0, 0.0],
                1: [0.7, 0.9, 1.0, 1.2, 1.3, 0.0, 0.0, 0.0, 0.0],
                2: [0.7, 0.9, 1.0, 1.2, 1.3, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 _": {
                0: [0.8, 1.1, 1.3, 1.6, 1.8, 0.0, 0.0, 0.0, 0.0],
                1: [0.9, 1.2, 1.5, 1.7, 1.9, 0.0, 0.0, 0.0, 0.0],
                2: [0.8, 1.0, 1.3, 1.5, 1.6, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ 3": {
                0: [0.6, 0.8, 1.1, 1.3, 1.5, 0.0, 0.0, 0.0, 0.0],
                1: [0.9, 1.1, 1.3, 1.6, 1.7, 0.0, 0.0, 0.0, 0.0],
                2: [0.9, 1.1, 1.4, 1.6, 1.7, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 3": {
                0: [0.6, 0.8, 1.0, 1.2, 1.3, 0.0, 0.0, 0.0, 0.0],
                1: [0.7, 0.9, 1.1, 1.3, 1.4, 0.0, 0.0, 0.0, 0.0],
                2: [1.0, 1.2, 1.5, 1.7, 1.9, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 3": {
                0: [0.8, 1.1, 1.4, 1.7, 2.0, 0.0, 0.0, 0.0, 0.0],
                1: [1.1, 1.5, 1.8, 2.1, 2.4, 0.0, 0.0, 0.0, 0.0],
                2: [1.4, 1.8, 2.1, 2.5, 2.7, 0.0, 0.0, 0.0, 0.0],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.7, 0.8, 0.9, 0.9, 0.9, 0.8, 0.6, 0.5, 0.4],
                1: [0.5, 0.6, 0.6, 0.7, 0.6, 0.6, 0.5, 0.4, 0.3],
                2: [0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.2],
            },
            "1 _ _": {
                0: [1.2, 1.4, 1.5, 1.5, 1.4, 1.2, 1.0, 0.8, 0.6],
                1: [1.0, 1.1, 1.2, 1.2, 1.1, 1.0, 0.8, 0.7, 0.5],
                2: [0.6, 0.7, 0.8, 0.8, 0.8, 0.7, 0.6, 0.5, 0.4],
            },
            "_ 2 _": {
                0: [1.1, 1.2, 1.3, 1.2, 1.1, 1.0, 0.8, 0.6, 0.5],
                1: [1.0, 1.1, 1.2, 1.2, 1.2, 1.0, 0.9, 0.7, 0.5],
                2: [0.8, 1.0, 1.1, 1.1, 1.1, 1.0, 0.8, 0.7, 0.5],
            },
            "_ _ 3": {
                0: [1.0, 1.1, 1.1, 1.1, 1.0, 0.8, 0.7, 0.5, 0.4],
                1: [1.0, 1.1, 1.3, 1.3, 1.3, 1.1, 1.0, 0.8, 0.6],
                2: [1.0, 1.1, 1.3, 1.3, 1.3, 1.2, 1.0, 0.8, 0.6],
            },
            "1 2 _": {
                0: [1.7, 1.9, 2.0, 1.9, 1.7, 1.5, 1.2, 0.9, 0.7],
                1: [1.7, 1.9, 2.0, 2.0, 1.8, 1.6, 1.3, 1.0, 0.8],
                2: [1.3, 1.5, 1.6, 1.7, 1.6, 1.4, 1.2, 0.9, 0.7],
            },
            "1 _ 3": {
                0: [1.6, 1.7, 1.7, 1.6, 1.4, 1.2, 1.0, 0.7, 0.5],
                1: [1.5, 1.7, 1.8, 1.8, 1.7, 1.5, 1.2, 1.0, 0.8],
                2: [1.4, 1.6, 1.7, 1.8, 1.7, 1.5, 1.3, 1.0, 0.8],
            },
            "_ 2 3": {
                0: [1.4, 1.5, 1.5, 1.4, 1.3, 1.1, 0.9, 0.7, 0.5],
                1: [1.4, 1.5, 1.6, 1.5, 1.4, 1.2, 1.0, 0.8, 0.6],
                2: [1.6, 1.8, 2.0, 2.0, 1.9, 1.7, 1.4, 1.1, 0.8],
            },
            "1 2 3": {
                0: [2.2, 2.3, 2.3, 2.1, 1.9, 1.6, 1.2, 0.9, 0.7],
                1: [2.4, 2.6, 2.6, 2.6, 2.3, 2.0, 1.6, 1.3, 1.0],
                2: [2.4, 2.7, 2.9, 2.9, 2.7, 2.4, 2.0, 1.5, 1.2],
            },
        },
    },
    2: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7],
                1: [0.3, 0.4, 0.5, 0.6, 0.7, 0.7, 0.6, 0.6, 0.5],
                2: [0.2, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3],
            },
            "1 _ _": {
                0: [0.7, 0.9, 1.1, 1.3, 1.5, 1.5, 1.5, 1.4, 1.2],
                1: [0.6, 0.7, 0.9, 1.1, 1.2, 1.3, 1.2, 1.1, 0.9],
                2: [0.4, 0.5, 0.7, 0.8, 0.8, 0.9, 0.8, 0.7, 0.6],
            },
            "_ 2 _": {
                0: [0.5, 0.7, 0.9, 1.1, 1.2, 1.3, 1.3, 1.2, 1.0],
                1: [0.6, 0.8, 1.0, 1.1, 1.2, 1.3, 1.2, 1.1, 0.9],
                2: [0.6, 0.8, 0.9, 1.1, 1.2, 1.2, 1.1, 0.9, 0.8],
            },
            "_ _ 3": {
                0: [0.4, 0.6, 0.8, 0.9, 1.1, 1.1, 1.2, 1.1, 0.9],
                1: [0.7, 0.9, 1.1, 1.2, 1.3, 1.3, 1.3, 1.1, 0.9],
                2: [0.7, 0.9, 1.1, 1.3, 1.4, 1.4, 1.2, 1.1, 0.9],
            },
            "1 2 _": {
                0: [0.8, 1.1, 1.4, 1.6, 1.9, 2.0, 2.0, 1.9, 1.7],
                1: [0.9, 1.2, 1.5, 1.8, 2.0, 2.1, 2.0, 1.8, 1.6],
                2: [0.8, 1.0, 1.3, 1.5, 1.7, 1.7, 1.6, 1.4, 1.2],
            },
            "1 _ 3": {
                0: [0.6, 0.8, 1.1, 1.3, 1.6, 1.7, 1.8, 1.7, 1.5],
                1: [0.9, 1.1, 1.4, 1.6, 1.8, 1.8, 1.8, 1.6, 1.4],
                2: [0.9, 1.1, 1.4, 1.6, 1.8, 1.8, 1.7, 1.5, 1.3],
            },
            "_ 2 3": {
                0: [0.6, 0.8, 1.0, 1.2, 1.4, 1.5, 1.6, 1.5, 1.4],
                1: [0.7, 0.9, 1.1, 1.3, 1.5, 1.6, 1.6, 1.5, 1.3],
                2: [1.0, 1.2, 1.5, 1.8, 2.0, 2.1, 2.0, 1.7, 1.4],
            },
            "1 2 3": {
                0: [0.8, 1.1, 1.4, 1.7, 2.0, 2.3, 2.4, 2.3, 2.1],
                1: [1.1, 1.5, 1.8, 2.2, 2.5, 2.7, 2.7, 2.6, 2.3],
                2: [1.3, 1.7, 2.2, 2.6, 2.9, 3.0, 2.9, 2.6, 2.2],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 0.9, 1.0, 1.0, 0.9, 0.8, 0.6, 0.5, 0.4],
                1: [0.5, 0.6, 0.7, 0.7, 0.7, 0.6, 0.5, 0.4, 0.3],
                2: [0.3, 0.4, 0.4, 0.5, 0.4, 0.4, 0.3, 0.2, 0.2],
            },
            "1 _ _": {
                0: [1.3, 1.5, 1.6, 1.6, 1.5, 1.2, 1.0, 0.8, 0.6],
                1: [1.0, 1.2, 1.3, 1.3, 1.2, 1.0, 0.8, 0.6, 0.5],
                2: [0.6, 0.8, 0.9, 0.9, 0.8, 0.7, 0.6, 0.5, 0.3],
            },
            "_ 2 _": {
                0: [1.1, 1.3, 1.3, 1.3, 1.2, 1.0, 0.8, 0.6, 0.4],
                1: [1.0, 1.2, 1.3, 1.3, 1.2, 1.1, 0.9, 0.7, 0.5],
                2: [0.8, 1.0, 1.2, 1.2, 1.2, 1.0, 0.9, 0.7, 0.5],
            },
            "_ _ 3": {
                0: [1.0, 1.2, 1.2, 1.2, 1.0, 0.9, 0.7, 0.5, 0.4],
                1: [1.0, 1.2, 1.3, 1.4, 1.4, 1.2, 1.0, 0.8, 0.6],
                2: [1.0, 1.2, 1.3, 1.4, 1.4, 1.2, 1.0, 0.8, 0.6],
            },
            "1 2 _": {
                0: [1.8, 2.0, 2.1, 2.0, 1.8, 1.5, 1.2, 0.9, 0.7],
                1: [1.7, 2.0, 2.1, 2.1, 2.0, 1.7, 1.3, 1.0, 0.7],
                2: [1.3, 1.6, 1.8, 1.8, 1.7, 1.5, 1.2, 0.9, 0.7],
            },
            "1 _ 3": {
                0: [1.6, 1.8, 1.8, 1.7, 1.5, 1.2, 0.9, 0.7, 0.5],
                1: [1.5, 1.8, 1.9, 1.9, 1.8, 1.6, 1.3, 1.0, 0.7],
                2: [1.4, 1.7, 1.9, 1.9, 1.8, 1.6, 1.3, 1.0, 0.7],
            },
            "_ 2 3": {
                0: [1.5, 1.6, 1.6, 1.5, 1.3, 1.1, 0.9, 0.7, 0.5],
                1: [1.4, 1.6, 1.7, 1.6, 1.5, 1.3, 1.0, 0.8, 0.6],
                2: [1.6, 1.9, 2.1, 2.1, 2.0, 1.7, 1.4, 1.1, 0.8],
            },
            "1 2 3": {
                0: [2.3, 2.4, 2.4, 2.2, 1.9, 1.6, 1.2, 0.9, 0.6],
                1: [2.5, 2.7, 2.8, 2.7, 2.4, 2.1, 1.7, 1.3, 0.9],
                2: [2.5, 2.8, 3.1, 3.1, 2.9, 2.5, 2.0, 1.5, 1.1],
            },
        },
    },
    3: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.6, 0.7, 0.9, 1.0, 1.0, 1.0, 0.9, 0.7],
                1: [0.3, 0.4, 0.5, 0.6, 0.7, 0.7, 0.7, 0.6, 0.5],
                2: [0.2, 0.3, 0.4, 0.4, 0.5, 0.5, 0.4, 0.4, 0.3],
            },
            "1 _ _": {
                0: [0.6, 0.9, 1.1, 1.4, 1.6, 1.7, 1.6, 1.4, 1.2],
                1: [0.5, 0.7, 1.0, 1.2, 1.3, 1.4, 1.3, 1.1, 0.9],
                2: [0.4, 0.5, 0.7, 0.8, 0.9, 0.9, 0.8, 0.7, 0.6],
            },
            "_ 2 _": {
                0: [0.5, 0.7, 0.9, 1.1, 1.3, 1.4, 1.4, 1.2, 1.0],
                1: [0.6, 0.8, 1.0, 1.2, 1.3, 1.4, 1.3, 1.1, 0.9],
                2: [0.6, 0.8, 1.0, 1.1, 1.3, 1.3, 1.1, 1.0, 0.8],
            },
            "_ _ 3": {
                0: [0.4, 0.6, 0.8, 1.0, 1.1, 1.2, 1.2, 1.1, 1.0],
                1: [0.6, 0.9, 1.1, 1.3, 1.5, 1.5, 1.3, 1.1, 0.9],
                2: [0.7, 0.9, 1.1, 1.3, 1.5, 1.5, 1.3, 1.1, 0.9],
            },
            "1 2 _": {
                0: [0.8, 1.0, 1.4, 1.7, 2.0, 2.2, 2.1, 2.0, 1.7],
                1: [0.9, 1.2, 1.5, 1.8, 2.1, 2.2, 2.1, 1.9, 1.6],
                2: [0.8, 1.0, 1.3, 1.6, 1.8, 1.9, 1.8, 1.5, 1.2],
            },
            "1 _ 3": {
                0: [0.6, 0.8, 1.1, 1.4, 1.6, 1.8, 1.9, 1.8, 1.6],
                1: [0.8, 1.1, 1.4, 1.7, 1.9, 2.0, 1.9, 1.7, 1.5],
                2: [0.8, 1.1, 1.4, 1.7, 1.9, 2.0, 1.9, 1.6, 1.3],
            },
            "_ 2 3": {
                0: [0.5, 0.8, 1.0, 1.2, 1.5, 1.6, 1.7, 1.6, 1.4],
                1: [0.7, 0.9, 1.2, 1.4, 1.6, 1.7, 1.7, 1.6, 1.3],
                2: [0.9, 1.2, 1.6, 1.9, 2.2, 2.2, 2.1, 1.8, 1.5],
            },
            "1 2 3": {
                0: [0.7, 1.0, 1.4, 1.8, 2.1, 2.4, 2.6, 2.5, 2.3],
                1: [1.1, 1.4, 1.9, 2.3, 2.7, 2.9, 2.9, 2.7, 2.4],
                2: [1.3, 1.7, 2.2, 2.7, 3.1, 3.3, 3.1, 2.7, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 0.9, 1.0, 1.1, 1.0, 0.8, 0.6, 0.5, 0.3],
                1: [0.5, 0.7, 0.7, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3],
                2: [0.3, 0.4, 0.5, 0.5, 0.5, 0.4, 0.3, 0.2, 0.2],
            },
            "1 _ _": {
                0: [1.3, 1.6, 1.7, 1.7, 1.5, 1.3, 1.0, 0.7, 0.5],
                1: [1.0, 1.2, 1.4, 1.4, 1.3, 1.1, 0.8, 0.6, 0.4],
                2: [0.6, 0.8, 0.9, 1.0, 0.9, 0.8, 0.6, 0.5, 0.3],
            },
            "_ 2 _": {
                0: [1.2, 1.3, 1.5, 1.4, 1.3, 1.1, 0.8, 0.6, 0.4],
                1: [1.0, 1.3, 1.4, 1.4, 1.3, 1.1, 0.9, 0.6, 0.5],
                2: [0.9, 1.1, 1.3, 1.3, 1.3, 1.1, 0.9, 0.6, 0.5],
            },
            "_ _ 3": {
                0: [1.1, 1.2, 1.3, 1.2, 1.1, 0.9, 0.7, 0.5, 0.3],
                1: [1.0, 1.3, 1.4, 1.5, 1.5, 1.3, 1.0, 0.7, 0.5],
                2: [1.0, 1.2, 1.4, 1.6, 1.5, 1.3, 1.0, 0.8, 0.5],
            },
            "1 2 _": {
                0: [1.9, 2.1, 2.3, 2.2, 1.9, 1.6, 1.2, 0.9, 0.6],
                1: [1.8, 2.1, 2.3, 2.3, 2.1, 1.7, 1.3, 1.0, 0.7],
                2: [1.4, 1.7, 1.9, 2.0, 1.8, 1.5, 1.2, 0.9, 0.6],
            },
            "1 _ 3": {
                0: [1.7, 1.9, 2.0, 1.8, 1.5, 1.2, 0.9, 0.7, 0.4],
                1: [1.6, 1.9, 2.0, 2.1, 1.9, 1.6, 1.3, 0.9, 0.7],
                2: [1.4, 1.8, 2.0, 2.1, 1.9, 1.6, 1.3, 1.0, 0.7],
            },
            "_ 2 3": {
                0: [1.6, 1.7, 1.8, 1.6, 1.4, 1.1, 0.9, 0.6, 0.4],
                1: [1.5, 1.7, 1.8, 1.7, 1.6, 1.3, 1.0, 0.8, 0.5],
                2: [1.6, 2.0, 2.3, 2.3, 2.2, 1.8, 1.4, 1.0, 0.7],
            },
            "1 2 3": {
                0: [2.4, 2.6, 2.6, 2.4, 2.0, 1.6, 1.2, 0.8, 0.6],
                1: [2.6, 2.9, 3.1, 2.9, 2.6, 2.1, 1.6, 1.2, 0.8],
                2: [2.5, 3.0, 3.3, 3.4, 3.1, 2.5, 2.0, 1.5, 1.0],
            },
        },
    },
    4: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 0.9, 0.7],
                1: [0.3, 0.4, 0.5, 0.7, 0.8, 0.8, 0.7, 0.6, 0.5],
                2: [0.2, 0.3, 0.4, 0.5, 0.5, 0.5, 0.5, 0.4, 0.3],
            },
            "1 _ _": {
                0: [0.6, 0.8, 1.1, 1.4, 1.7, 1.8, 1.7, 1.5, 1.2],
                1: [0.5, 0.7, 1.0, 1.2, 1.4, 1.5, 1.4, 1.2, 0.9],
                2: [0.4, 0.5, 0.7, 0.9, 1.0, 1.0, 0.9, 0.7, 0.6],
            },
            "_ 2 _": {
                0: [0.5, 0.7, 0.9, 1.2, 1.4, 1.5, 1.5, 1.3, 1.1],
                1: [0.5, 0.7, 1.0, 1.2, 1.5, 1.5, 1.4, 1.2, 0.9],
                2: [0.5, 0.7, 1.0, 1.2, 1.4, 1.4, 1.2, 1.0, 0.7],
            },
            "_ _ 3": {
                0: [0.4, 0.6, 0.8, 1.0, 1.2, 1.3, 1.3, 1.2, 1.0],
                1: [0.6, 0.9, 1.1, 1.4, 1.6, 1.6, 1.4, 1.2, 0.9],
                2: [0.6, 0.9, 1.2, 1.4, 1.6, 1.6, 1.4, 1.1, 0.8],
            },
            "1 2 _": {
                0: [0.7, 1.0, 1.4, 1.8, 2.1, 2.3, 2.3, 2.1, 1.8],
                1: [0.8, 1.1, 1.5, 1.9, 2.3, 2.4, 2.3, 2.0, 1.6],
                2: [0.7, 1.0, 1.4, 1.7, 2.0, 2.1, 1.9, 1.6, 1.2],
            },
            "1 _ 3": {
                0: [0.5, 0.8, 1.0, 1.4, 1.7, 2.0, 2.1, 1.9, 1.7],
                1: [0.8, 1.1, 1.4, 1.8, 2.1, 2.2, 2.1, 1.8, 1.5],
                2: [0.8, 1.1, 1.5, 1.8, 2.1, 2.2, 2.0, 1.7, 1.3],
            },
            "_ 2 3": {
                0: [0.5, 0.7, 1.0, 1.3, 1.6, 1.8, 1.8, 1.7, 1.5],
                1: [0.6, 0.9, 1.2, 1.5, 1.7, 1.9, 1.9, 1.7, 1.4],
                2: [0.9, 1.2, 1.6, 2.0, 2.4, 2.5, 2.3, 1.9, 1.5],
            },
            "1 2 3": {
                0: [0.7, 1.0, 1.4, 1.8, 2.2, 2.6, 2.8, 2.7, 2.4],
                1: [1.0, 1.4, 1.9, 2.4, 2.9, 3.1, 3.2, 2.9, 2.4],
                2: [1.2, 1.7, 2.3, 2.9, 3.4, 3.6, 3.4, 2.9, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.0, 1.1, 1.2, 1.1, 0.9, 0.6, 0.4, 0.3],
                1: [0.5, 0.7, 0.8, 0.9, 0.8, 0.6, 0.5, 0.3, 0.2],
                2: [0.3, 0.4, 0.5, 0.6, 0.5, 0.4, 0.3, 0.2, 0.2],
            },
            "1 _ _": {
                0: [1.4, 1.7, 1.9, 1.9, 1.7, 1.3, 1.0, 0.7, 0.5],
                1: [1.0, 1.3, 1.5, 1.6, 1.4, 1.1, 0.8, 0.6, 0.4],
                2: [0.7, 0.8, 1.0, 1.1, 1.0, 0.8, 0.6, 0.4, 0.3],
            },
            "_ 2 _": {
                0: [1.2, 1.4, 1.6, 1.6, 1.4, 1.1, 0.8, 0.5, 0.4],
                1: [1.1, 1.3, 1.5, 1.6, 1.4, 1.2, 0.9, 0.6, 0.4],
                2: [0.9, 1.1, 1.4, 1.5, 1.4, 1.1, 0.9, 0.6, 0.4],
            },
            "_ _ 3": {
                0: [1.1, 1.3, 1.4, 1.4, 1.1, 0.9, 0.6, 0.4, 0.3],
                1: [1.0, 1.3, 1.6, 1.7, 1.6, 1.3, 1.0, 0.7, 0.5],
                2: [1.0, 1.3, 1.6, 1.7, 1.6, 1.3, 1.0, 0.7, 0.5],
            },
            "1 2 _": {
                0: [2.0, 2.3, 2.5, 2.4, 2.0, 1.6, 1.1, 0.8, 0.5],
                1: [1.8, 2.2, 2.5, 2.5, 2.2, 1.8, 1.3, 0.9, 0.6],
                2: [1.4, 1.8, 2.1, 2.2, 2.0, 1.6, 1.2, 0.8, 0.6],
            },
            "1 _ 3": {
                0: [1.8, 2.1, 2.1, 2.0, 1.6, 1.2, 0.9, 0.6, 0.4],
                1: [1.7, 2.0, 2.2, 2.3, 2.1, 1.7, 1.3, 0.9, 0.6],
                2: [1.5, 1.9, 2.2, 2.3, 2.1, 1.7, 1.3, 0.9, 0.6],
            },
            "_ 2 3": {
                0: [1.7, 1.9, 1.9, 1.8, 1.5, 1.1, 0.8, 0.6, 0.4],
                1: [1.6, 1.8, 2.0, 1.9, 1.7, 1.4, 1.0, 0.7, 0.5],
                2: [1.7, 2.1, 2.5, 2.6, 2.3, 1.9, 1.4, 1.0, 0.7],
            },
            "1 2 3": {
                0: [2.6, 2.8, 2.8, 2.6, 2.1, 1.6, 1.1, 0.8, 0.5],
                1: [2.7, 3.2, 3.3, 3.2, 2.8, 2.2, 1.6, 1.1, 0.7],
                2: [2.6, 3.2, 3.6, 3.7, 3.3, 2.6, 1.9, 1.4, 0.9],
            },
        },
    },
    5: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.5, 0.7, 1.0, 1.2, 1.3, 1.1, 0.9, 0.7],
                1: [0.3, 0.4, 0.6, 0.7, 0.9, 0.9, 0.8, 0.6, 0.5],
                2: [0.2, 0.3, 0.4, 0.5, 0.6, 0.6, 0.5, 0.4, 0.3],
            },
            "1 _ _": {
                0: [0.5, 0.8, 1.1, 1.5, 1.9, 2.0, 1.9, 1.6, 1.2],
                1: [0.5, 0.7, 1.0, 1.3, 1.6, 1.7, 1.5, 1.2, 0.9],
                2: [0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.0, 0.8, 0.6],
            },
            "_ 2 _": {
                0: [0.4, 0.6, 0.9, 1.2, 1.5, 1.7, 1.6, 1.4, 1.1],
                1: [0.5, 0.7, 1.0, 1.3, 1.6, 1.7, 1.5, 1.2, 0.9],
                2: [0.5, 0.7, 1.0, 1.3, 1.6, 1.6, 1.3, 1.0, 0.7],
            },
            "_ _ 3": {
                0: [0.3, 0.5, 0.7, 1.0, 1.3, 1.5, 1.5, 1.3, 1.1],
                1: [0.6, 0.8, 1.1, 1.5, 1.8, 1.8, 1.5, 1.2, 0.9],
                2: [0.6, 0.8, 1.2, 1.5, 1.8, 1.8, 1.5, 1.1, 0.8],
            },
            "1 2 _": {
                0: [0.6, 0.9, 1.3, 1.8, 2.3, 2.6, 2.5, 2.3, 1.8],
                1: [0.7, 1.1, 1.5, 2.0, 2.5, 2.7, 2.5, 2.1, 1.6],
                2: [0.7, 1.0, 1.4, 1.8, 2.2, 2.3, 2.1, 1.6, 1.2],
            },
            "1 _ 3": {
                0: [0.5, 0.7, 1.0, 1.4, 1.8, 2.2, 2.3, 2.1, 1.7],
                1: [0.7, 1.0, 1.4, 1.9, 2.3, 2.4, 2.3, 1.9, 1.5],
                2: [0.7, 1.1, 1.5, 1.9, 2.4, 2.5, 2.2, 1.7, 1.3],
            },
            "_ 2 3": {
                0: [0.4, 0.7, 1.0, 1.3, 1.7, 1.9, 2.0, 1.9, 1.6],
                1: [0.6, 0.8, 1.2, 1.5, 1.9, 2.1, 2.1, 1.8, 1.4],
                2: [0.8, 1.1, 1.6, 2.1, 2.6, 2.8, 2.5, 2.0, 1.4],
            },
            "1 2 3": {
                0: [0.6, 0.9, 1.3, 1.8, 2.4, 2.8, 3.0, 2.9, 2.5],
                1: [0.9, 1.3, 1.9, 2.5, 3.1, 3.5, 3.5, 3.1, 2.5],
                2: [1.1, 1.6, 2.2, 3.0, 3.7, 4.0, 3.7, 3.0, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.1, 1.3, 1.3, 1.2, 0.9, 0.6, 0.4, 0.3],
                1: [0.5, 0.7, 0.9, 1.0, 0.9, 0.7, 0.5, 0.3, 0.2],
                2: [0.3, 0.4, 0.6, 0.6, 0.6, 0.4, 0.3, 0.2, 0.1],
            },
            "1 _ _": {
                0: [1.4, 1.8, 2.1, 2.1, 1.8, 1.3, 0.9, 0.6, 0.4],
                1: [1.1, 1.4, 1.7, 1.8, 1.5, 1.2, 0.8, 0.5, 0.3],
                2: [0.6, 0.9, 1.1, 1.2, 1.1, 0.8, 0.6, 0.4, 0.2],
            },
            "_ 2 _": {
                0: [1.2, 1.6, 1.8, 1.8, 1.5, 1.1, 0.7, 0.5, 0.3],
                1: [1.1, 1.4, 1.7, 1.8, 1.6, 1.2, 0.8, 0.5, 0.3],
                2: [0.8, 1.2, 1.5, 1.7, 1.6, 1.2, 0.8, 0.6, 0.4],
            },
            "_ _ 3": {
                0: [1.2, 1.5, 1.6, 1.5, 1.2, 0.9, 0.6, 0.4, 0.2],
                1: [1.0, 1.4, 1.7, 2.0, 1.8, 1.4, 1.0, 0.6, 0.4],
                2: [0.9, 1.3, 1.7, 2.0, 1.9, 1.4, 1.0, 0.7, 0.4],
            },
            "1 2 _": {
                0: [2.1, 2.5, 2.7, 2.6, 2.2, 1.6, 1.1, 0.7, 0.4],
                1: [1.9, 2.4, 2.8, 2.8, 2.4, 1.8, 1.2, 0.8, 0.5],
                2: [1.4, 1.9, 2.3, 2.5, 2.2, 1.6, 1.1, 0.8, 0.5],
            },
            "1 _ 3": {
                0: [1.9, 2.3, 2.4, 2.2, 1.7, 1.2, 0.8, 0.5, 0.3],
                1: [1.7, 2.2, 2.5, 2.6, 2.3, 1.7, 1.2, 0.8, 0.5],
                2: [1.5, 2.0, 2.4, 2.6, 2.4, 1.8, 1.2, 0.8, 0.5],
            },
            "_ 2 3": {
                0: [1.8, 2.1, 2.1, 2.0, 1.6, 1.1, 0.8, 0.5, 0.3],
                1: [1.6, 2.0, 2.2, 2.1, 1.9, 1.4, 1.0, 0.6, 0.4],
                2: [1.7, 2.3, 2.8, 3.0, 2.6, 1.9, 1.3, 0.9, 0.6],
            },
            "1 2 3": {
                0: [2.8, 3.1, 3.1, 2.8, 2.2, 1.5, 1.0, 0.7, 0.4],
                1: [2.9, 3.4, 3.7, 3.5, 3.0, 2.2, 1.5, 1.0, 0.6],
                2: [2.7, 3.4, 4.0, 4.2, 3.6, 2.7, 1.8, 1.2, 0.8],
            },
        },
    },
    6: {
        "top": {
            "_ _ _": {
                0: [0.3, 0.5, 0.7, 1.0, 1.3, 1.4, 1.3, 1.0, 0.7],
                1: [0.2, 0.4, 0.5, 0.8, 1.0, 1.1, 0.9, 0.7, 0.4],
                2: [0.2, 0.3, 0.4, 0.5, 0.7, 0.7, 0.5, 0.4, 0.2],
            },
            "1 _ _": {
                0: [0.5, 0.7, 1.1, 1.6, 2.1, 2.3, 2.1, 1.7, 1.2],
                1: [0.4, 0.6, 0.9, 1.3, 1.8, 1.9, 1.7, 1.3, 0.9],
                2: [0.3, 0.5, 0.7, 1.0, 1.3, 1.3, 1.1, 0.8, 0.5],
            },
            "_ 2 _": {
                0: [0.4, 0.6, 0.9, 1.3, 1.7, 1.9, 1.8, 1.5, 1.1],
                1: [0.4, 0.6, 1.0, 1.4, 1.8, 2.0, 1.7, 1.3, 0.9],
                2: [0.4, 0.7, 1.0, 1.4, 1.8, 1.8, 1.4, 1.0, 0.7],
            },
            "_ _ 3": {
                0: [0.3, 0.5, 0.7, 1.0, 1.4, 1.7, 1.7, 1.4, 1.1],
                1: [0.5, 0.8, 1.1, 1.6, 2.0, 2.1, 1.6, 1.3, 0.9],
                2: [0.5, 0.8, 1.2, 1.6, 2.1, 2.1, 1.6, 1.1, 0.7],
            },
            "1 2 _": {
                0: [0.5, 0.8, 1.3, 1.8, 2.5, 2.9, 2.8, 2.4, 1.9],
                1: [0.6, 1.0, 1.5, 2.1, 2.8, 3.1, 2.8, 2.2, 1.6],
                2: [0.6, 0.9, 1.3, 1.9, 2.5, 2.6, 2.3, 1.7, 1.1],
            },
            "1 _ 3": {
                0: [0.4, 0.6, 0.9, 1.4, 1.9, 2.4, 2.6, 2.3, 1.8],
                1: [0.6, 0.9, 1.4, 2.0, 2.6, 2.8, 2.5, 2.1, 1.5],
                2: [0.6, 1.0, 1.4, 2.0, 2.7, 2.8, 2.4, 1.8, 1.2],
            },
            "_ 2 3": {
                0: [0.4, 0.6, 0.9, 1.3, 1.8, 2.2, 2.3, 2.1, 1.7],
                1: [0.5, 0.8, 1.1, 1.6, 2.1, 2.3, 2.3, 1.9, 1.5],
                2: [0.7, 1.0, 1.6, 2.2, 2.9, 3.2, 2.7, 2.0, 1.4],
            },
            "1 2 3": {
                0: [0.5, 0.8, 1.2, 1.8, 2.5, 3.1, 3.4, 3.2, 2.7],
                1: [0.8, 1.2, 1.8, 2.6, 3.4, 3.9, 3.9, 3.3, 2.6],
                2: [0.9, 1.4, 2.2, 3.1, 4.1, 4.5, 4.1, 3.2, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.1, 1.4, 1.6, 1.3, 0.9, 0.6, 0.3, 0.2],
                1: [0.5, 0.8, 1.0, 1.2, 1.0, 0.7, 0.4, 0.3, 0.2],
                2: [0.3, 0.4, 0.6, 0.8, 0.7, 0.5, 0.3, 0.2, 0.1],
            },
            "1 _ _": {
                0: [1.4, 1.9, 2.3, 2.4, 2.0, 1.3, 0.8, 0.5, 0.3],
                1: [1.0, 1.5, 1.9, 2.1, 1.7, 1.1, 0.7, 0.4, 0.3],
                2: [0.6, 0.9, 1.2, 1.5, 1.3, 0.8, 0.5, 0.3, 0.2],
            },
            "_ 2 _": {
                0: [1.3, 1.7, 2.0, 2.0, 1.6, 1.1, 0.7, 0.4, 0.2],
                1: [1.1, 1.5, 1.9, 2.1, 1.8, 1.2, 0.8, 0.5, 0.3],
                2: [0.8, 1.2, 1.6, 2.0, 1.8, 1.2, 0.8, 0.5, 0.3],
            },
            "_ _ 3": {
                0: [1.2, 1.6, 1.8, 1.7, 1.3, 0.8, 0.5, 0.3, 0.2],
                1: [1.0, 1.4, 1.9, 2.3, 2.1, 1.4, 0.9, 0.5, 0.3],
                2: [0.9, 1.3, 1.9, 2.4, 2.2, 1.4, 0.9, 0.6, 0.3],
            },
            "1 2 _": {
                0: [2.2, 2.7, 3.1, 3.0, 2.3, 1.5, 0.9, 0.6, 0.3],
                1: [1.9, 2.6, 3.1, 3.3, 2.7, 1.8, 1.1, 0.7, 0.4],
                2: [1.4, 2.0, 2.6, 2.9, 2.5, 1.6, 1.0, 0.6, 0.4],
            },
            "1 _ 3": {
                0: [2.0, 2.5, 2.7, 2.4, 1.7, 1.1, 0.7, 0.4, 0.2],
                1: [1.8, 2.4, 2.8, 3.0, 2.6, 1.7, 1.1, 0.7, 0.4],
                2: [1.4, 2.1, 2.7, 3.1, 2.7, 1.8, 1.1, 0.7, 0.4],
            },
            "_ 2 3": {
                0: [1.9, 2.3, 2.4, 2.2, 1.7, 1.1, 0.7, 0.4, 0.2],
                1: [1.7, 2.2, 2.5, 2.5, 2.1, 1.4, 0.9, 0.5, 0.3],
                2: [1.6, 2.4, 3.1, 3.5, 2.9, 1.9, 1.2, 0.7, 0.4],
            },
            "1 2 3": {
                0: [3.0, 3.5, 3.6, 3.1, 2.2, 1.4, 0.9, 0.5, 0.3],
                1: [3.0, 3.8, 4.2, 4.0, 3.3, 2.2, 1.4, 0.8, 0.5],
                2: [2.7, 3.7, 4.5, 4.9, 4.0, 2.6, 1.7, 1.0, 0.6],
            },
        },
    },
    7: {
        "top": {
            "_ _ _": {
                0: [0.2, 0.4, 0.7, 1.0, 1.5, 1.7, 1.4, 1.0, 0.6],
                1: [0.2, 0.3, 0.5, 0.8, 1.2, 1.3, 1.0, 0.6, 0.4],
                2: [0.1, 0.2, 0.4, 0.5, 0.8, 0.8, 0.6, 0.3, 0.2],
            },
            "1 _ _": {
                0: [0.4, 0.6, 1.0, 1.6, 2.4, 2.7, 2.3, 1.7, 1.2],
                1: [0.3, 0.5, 0.9, 1.4, 2.0, 2.3, 1.8, 1.3, 0.8],
                2: [0.2, 0.4, 0.6, 1.0, 1.5, 1.6, 1.2, 0.7, 0.4],
            },
            "_ 2 _": {
                0: [0.3, 0.5, 0.8, 1.2, 1.9, 2.3, 2.0, 1.5, 1.1],
                1: [0.3, 0.6, 0.9, 1.4, 2.1, 2.3, 1.8, 1.3, 0.8],
                2: [0.3, 0.6, 0.9, 1.4, 2.1, 2.2, 1.5, 0.9, 0.6],
            },
            "_ _ 3": {
                0: [0.2, 0.4, 0.6, 1.0, 1.5, 2.0, 1.9, 1.5, 1.1],
                1: [0.4, 0.7, 1.1, 1.6, 2.4, 2.5, 1.8, 1.3, 0.8],
                2: [0.4, 0.7, 1.1, 1.7, 2.5, 2.5, 1.7, 1.1, 0.6],
            },
            "1 2 _": {
                0: [0.4, 0.7, 1.1, 1.8, 2.7, 3.4, 3.2, 2.6, 1.9],
                1: [0.5, 0.8, 1.3, 2.1, 3.2, 3.6, 3.1, 2.3, 1.6],
                2: [0.4, 0.8, 1.2, 1.9, 2.9, 3.2, 2.5, 1.7, 1.0],
            },
            "1 _ 3": {
                0: [0.3, 0.5, 0.8, 1.3, 2.0, 2.8, 3.0, 2.5, 1.8],
                1: [0.5, 0.8, 1.3, 2.0, 3.1, 3.3, 2.9, 2.2, 1.5],
                2: [0.5, 0.8, 1.4, 2.1, 3.1, 3.4, 2.6, 1.7, 1.1],
            },
            "_ 2 3": {
                0: [0.3, 0.5, 0.8, 1.3, 2.0, 2.5, 2.6, 2.3, 1.7],
                1: [0.4, 0.7, 1.1, 1.6, 2.5, 2.8, 2.7, 2.1, 1.4],
                2: [0.5, 0.9, 1.5, 2.3, 3.4, 3.9, 3.1, 2.0, 1.2],
            },
            "1 2 3": {
                0: [0.4, 0.6, 1.1, 1.7, 2.6, 3.5, 3.9, 3.6, 2.8],
                1: [0.6, 1.0, 1.6, 2.6, 3.9, 4.5, 4.4, 3.6, 2.6],
                2: [0.7, 1.2, 2.0, 3.1, 4.7, 5.4, 4.5, 3.3, 2.1],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.2, 1.6, 1.9, 1.5, 0.8, 0.4, 0.2, 0.1],
                1: [0.5, 0.8, 1.1, 1.4, 1.2, 0.6, 0.3, 0.2, 0.1],
                2: [0.2, 0.4, 0.7, 1.0, 0.8, 0.4, 0.2, 0.1, 0.1],
            },
            "1 _ _": {
                0: [1.4, 2.0, 2.6, 3.0, 2.3, 1.2, 0.7, 0.4, 0.2],
                1: [1.0, 1.5, 2.1, 2.5, 2.0, 1.1, 0.6, 0.3, 0.2],
                2: [0.5, 0.9, 1.4, 1.8, 1.5, 0.8, 0.4, 0.2, 0.1],
            },
            "_ 2 _": {
                0: [1.3, 1.8, 2.3, 2.4, 1.8, 0.9, 0.5, 0.3, 0.1],
                1: [1.0, 1.5, 2.1, 2.6, 2.1, 1.1, 0.6, 0.3, 0.2],
                2: [0.7, 1.1, 1.8, 2.6, 2.2, 1.1, 0.7, 0.4, 0.2],
            },
            "_ _ 3": {
                0: [1.3, 1.8, 2.2, 2.0, 1.5, 0.8, 0.4, 0.2, 0.1],
                1: [1.0, 1.5, 2.1, 2.9, 2.5, 1.3, 0.7, 0.4, 0.2],
                2: [0.8, 1.3, 2.0, 3.0, 2.6, 1.4, 0.8, 0.4, 0.2],
            },
            "1 2 _": {
                0: [2.2, 3.0, 3.6, 3.5, 2.5, 1.3, 0.8, 0.4, 0.2],
                1: [1.9, 2.7, 3.6, 4.0, 3.0, 1.6, 0.9, 0.5, 0.3],
                2: [1.2, 2.0, 2.9, 3.6, 2.9, 1.5, 0.8, 0.5, 0.2],
            },
            "1 _ 3": {
                0: [2.1, 2.8, 3.3, 2.8, 1.7, 0.9, 0.5, 0.3, 0.1],
                1: [1.8, 2.6, 3.2, 3.7, 3.1, 1.6, 0.9, 0.5, 0.3],
                2: [1.3, 2.1, 3.0, 3.8, 3.1, 1.6, 0.9, 0.5, 0.3],
            },
            "_ 2 3": {
                0: [2.0, 2.6, 2.9, 2.6, 1.7, 0.9, 0.5, 0.3, 0.1],
                1: [1.7, 2.4, 3.0, 3.0, 2.5, 1.3, 0.7, 0.4, 0.2],
                2: [1.5, 2.4, 3.6, 4.3, 3.3, 1.7, 1.0, 0.5, 0.3],
            },
            "1 2 3": {
                0: [3.3, 4.0, 4.1, 3.5, 2.3, 1.2, 0.7, 0.4, 0.2],
                1: [3.1, 4.2, 4.9, 4.8, 3.7, 2.0, 1.1, 0.6, 0.3],
                2: [2.6, 3.9, 5.2, 5.9, 4.5, 2.4, 1.3, 0.7, 0.4],
            },
        },
    },
    8: {
        "top": {
            "_ _ _": {
                0: [0.2, 0.3, 0.6, 1.0, 1.9, 2.2, 1.5, 0.9, 0.6],
                1: [0.1, 0.2, 0.4, 0.7, 1.4, 1.6, 1.0, 0.6, 0.3],
                2: [0.1, 0.2, 0.3, 0.5, 1.0, 1.1, 0.6, 0.3, 0.1],
            },
            "1 _ _": {
                0: [0.2, 0.4, 0.8, 1.5, 2.8, 3.4, 2.6, 1.7, 1.0],
                1: [0.2, 0.4, 0.7, 1.3, 2.4, 2.9, 2.0, 1.2, 0.7],
                2: [0.2, 0.3, 0.5, 1.0, 1.8, 2.1, 1.3, 0.7, 0.3],
            },
            "_ 2 _": {
                0: [0.2, 0.4, 0.6, 1.1, 2.2, 2.8, 2.3, 1.6, 1.0],
                1: [0.2, 0.4, 0.8, 1.3, 2.5, 2.9, 2.0, 1.2, 0.7],
                2: [0.2, 0.4, 0.8, 1.4, 2.7, 2.8, 1.5, 0.8, 0.4],
            },
            "_ _ 3": {
                0: [0.2, 0.3, 0.5, 0.9, 1.8, 2.4, 2.3, 1.6, 1.0],
                1: [0.3, 0.5, 0.9, 1.6, 3.1, 3.2, 2.0, 1.3, 0.7],
                2: [0.3, 0.5, 0.9, 1.6, 3.2, 3.3, 1.7, 0.9, 0.4],
            },
            "1 2 _": {
                0: [0.3, 0.5, 0.9, 1.6, 3.1, 4.1, 3.7, 2.8, 1.8],
                1: [0.3, 0.6, 1.1, 2.0, 3.7, 4.5, 3.5, 2.4, 1.4],
                2: [0.3, 0.6, 1.0, 1.8, 3.5, 4.0, 2.7, 1.6, 0.8],
            },
            "1 _ 3": {
                0: [0.2, 0.3, 0.6, 1.1, 2.1, 3.3, 3.6, 2.8, 1.8],
                1: [0.3, 0.6, 1.1, 2.0, 3.8, 4.2, 3.3, 2.3, 1.4],
                2: [0.3, 0.6, 1.1, 2.0, 3.8, 4.3, 2.8, 1.6, 0.8],
            },
            "_ 2 3": {
                0: [0.2, 0.3, 0.6, 1.1, 2.1, 3.1, 3.2, 2.6, 1.7],
                1: [0.3, 0.5, 0.9, 1.6, 3.0, 3.4, 3.2, 2.2, 1.3],
                2: [0.3, 0.7, 1.2, 2.1, 4.0, 4.9, 3.5, 1.9, 1.0],
            },
            "1 2 3": {
                0: [0.2, 0.4, 0.8, 1.5, 2.8, 4.1, 4.6, 4.0, 3.0],
                1: [0.4, 0.7, 1.4, 2.4, 4.6, 5.6, 5.2, 3.9, 2.6],
                2: [0.5, 0.9, 1.6, 2.9, 5.6, 6.8, 5.1, 3.3, 1.9],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.7, 1.1, 1.8, 2.5, 1.8, 0.6, 0.3, 0.1, 0.1],
                1: [0.4, 0.7, 1.2, 1.9, 1.4, 0.5, 0.2, 0.1, 0.0],
                2: [0.2, 0.4, 0.7, 1.3, 1.1, 0.3, 0.2, 0.1, 0.0],
            },
            "1 _ _": {
                0: [1.3, 2.1, 3.1, 3.8, 2.6, 0.9, 0.4, 0.2, 0.1],
                1: [0.8, 1.5, 2.4, 3.4, 2.4, 0.8, 0.4, 0.2, 0.1],
                2: [0.4, 0.8, 1.6, 2.5, 1.8, 0.6, 0.3, 0.1, 0.1],
            },
            "_ 2 _": {
                0: [1.2, 1.9, 2.7, 3.1, 2.0, 0.7, 0.3, 0.1, 0.1],
                1: [0.8, 1.5, 2.4, 3.4, 2.5, 0.8, 0.4, 0.2, 0.1],
                2: [0.5, 1.0, 1.9, 3.5, 2.8, 0.9, 0.4, 0.2, 0.1],
            },
            "_ _ 3": {
                0: [1.2, 1.9, 2.7, 2.5, 1.7, 0.6, 0.3, 0.1, 0.1],
                1: [0.9, 1.5, 2.4, 3.9, 3.2, 1.0, 0.5, 0.2, 0.1],
                2: [0.5, 1.1, 2.1, 4.1, 3.4, 1.0, 0.5, 0.2, 0.1],
            },
            "1 2 _": {
                0: [2.2, 3.3, 4.2, 4.4, 2.8, 0.9, 0.4, 0.2, 0.1],
                1: [1.7, 2.9, 4.1, 5.1, 3.5, 1.1, 0.5, 0.3, 0.1],
                2: [1.0, 2.0, 3.3, 4.7, 3.5, 1.1, 0.5, 0.2, 0.1],
            },
            "1 _ 3": {
                0: [2.2, 3.2, 4.1, 3.3, 1.8, 0.6, 0.3, 0.1, 0.1],
                1: [1.7, 2.7, 3.9, 4.9, 3.8, 1.2, 0.6, 0.3, 0.1],
                2: [1.0, 2.0, 3.4, 5.1, 3.8, 1.2, 0.6, 0.3, 0.1],
            },
            "_ 2 3": {
                0: [2.1, 3.0, 3.6, 3.3, 1.8, 0.6, 0.3, 0.1, 0.1],
                1: [1.6, 2.6, 3.7, 4.0, 3.0, 0.9, 0.4, 0.2, 0.1],
                2: [1.2, 2.3, 4.2, 5.8, 3.9, 1.3, 0.6, 0.3, 0.1],
            },
            "1 2 3": {
                0: [3.5, 4.6, 5.0, 4.2, 2.2, 0.8, 0.4, 0.2, 0.1],
                1: [3.1, 4.6, 5.9, 6.2, 4.4, 1.4, 0.7, 0.3, 0.1],
                2: [2.3, 4.0, 6.1, 7.7, 5.3, 1.7, 0.8, 0.4, 0.2],
            },
        },
    },
    9: {
        "top": {
            "_ _ _": {
                0: [0.1, 0.2, 0.3, 0.7, 2.4, 2.9, 1.6, 0.8, 0.4],
                1: [0.1, 0.1, 0.3, 0.6, 1.9, 2.2, 1.0, 0.5, 0.2],
                2: [0.0, 0.1, 0.2, 0.4, 1.4, 1.5, 0.5, 0.2, 0.1],
            },
            "1 _ _": {
                0: [0.1, 0.2, 0.5, 1.1, 3.4, 4.6, 2.9, 1.6, 0.8],
                1: [0.1, 0.2, 0.5, 1.0, 3.1, 3.9, 2.2, 1.0, 0.4],
                2: [0.1, 0.2, 0.3, 0.7, 2.4, 2.9, 1.3, 0.4, 0.1],
            },
            "_ 2 _": {
                0: [0.1, 0.2, 0.4, 0.8, 2.6, 3.7, 2.7, 1.5, 0.8],
                1: [0.1, 0.2, 0.5, 1.0, 3.3, 4.0, 2.2, 1.0, 0.5],
                2: [0.1, 0.2, 0.5, 1.1, 3.7, 4.0, 1.4, 0.5, 0.2],
            },
            "_ _ 3": {
                0: [0.1, 0.2, 0.3, 0.7, 2.3, 3.1, 2.9, 1.6, 0.8],
                1: [0.1, 0.3, 0.6, 1.2, 4.3, 4.4, 2.3, 1.1, 0.5],
                2: [0.1, 0.3, 0.6, 1.3, 4.4, 4.6, 1.4, 0.5, 0.2],
            },
            "1 2 _": {
                0: [0.1, 0.3, 0.6, 1.2, 3.6, 5.3, 4.4, 2.9, 1.6],
                1: [0.1, 0.3, 0.7, 1.4, 4.6, 6.1, 4.0, 2.3, 1.1],
                2: [0.1, 0.3, 0.7, 1.4, 4.5, 5.5, 2.9, 1.3, 0.4],
            },
            "1 _ 3": {
                0: [0.1, 0.2, 0.4, 0.8, 2.3, 4.2, 4.6, 3.0, 1.7],
                1: [0.1, 0.3, 0.7, 1.5, 5.0, 5.7, 4.0, 2.3, 1.1],
                2: [0.2, 0.3, 0.7, 1.5, 5.0, 5.9, 2.9, 1.3, 0.4],
            },
            "_ 2 3": {
                0: [0.1, 0.2, 0.4, 0.8, 2.4, 4.0, 4.0, 2.9, 1.6],
                1: [0.1, 0.3, 0.6, 1.2, 3.9, 4.6, 3.9, 2.3, 1.1],
                2: [0.2, 0.3, 0.7, 1.6, 5.1, 6.9, 3.9, 1.4, 0.5],
            },
            "1 2 3": {
                0: [0.1, 0.2, 0.5, 1.0, 2.9, 5.2, 5.7, 4.6, 3.1],
                1: [0.2, 0.4, 0.8, 1.8, 5.7, 7.3, 6.2, 4.2, 2.4],
                2: [0.2, 0.5, 1.0, 2.1, 6.9, 9.1, 5.7, 3.1, 1.4],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.5, 1.0, 2.0, 3.6, 2.3, 0.0, 0.0, 0.0, 0.0],
                1: [0.2, 0.6, 1.3, 2.8, 1.9, 0.0, 0.0, 0.0, 0.0],
                2: [0.1, 0.2, 0.6, 1.9, 1.5, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ _": {
                0: [1.0, 2.0, 3.6, 5.4, 3.1, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 1.3, 2.8, 4.8, 3.0, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.5, 1.7, 3.7, 2.4, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 _": {
                0: [1.0, 1.9, 3.3, 4.3, 2.5, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 1.3, 2.7, 5.0, 3.2, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.6, 1.8, 5.2, 3.9, 0.0, 0.0, 0.0, 0.0],
            },
            "_ _ 3": {
                0: [1.1, 2.0, 3.6, 3.5, 2.1, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 1.4, 2.9, 5.8, 4.5, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.7, 1.8, 6.1, 4.7, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 _": {
                0: [2.0, 3.6, 5.2, 6.0, 3.2, 0.0, 0.0, 0.0, 0.0],
                1: [1.3, 2.9, 4.8, 7.2, 4.3, 0.0, 0.0, 0.0, 0.0],
                2: [0.6, 1.7, 3.7, 6.8, 4.4, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ 3": {
                0: [2.1, 3.7, 5.5, 4.3, 2.1, 0.0, 0.0, 0.0, 0.0],
                1: [1.4, 2.9, 4.9, 7.1, 5.0, 0.0, 0.0, 0.0, 0.0],
                2: [0.6, 1.7, 3.7, 7.4, 5.0, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 3": {
                0: [2.0, 3.5, 4.7, 4.3, 2.0, 0.0, 0.0, 0.0, 0.0],
                1: [1.4, 2.8, 4.8, 5.7, 4.0, 0.0, 0.0, 0.0, 0.0],
                2: [0.7, 1.8, 5.1, 8.4, 4.7, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 3": {
                0: [3.7, 5.4, 6.4, 5.3, 2.4, 0.0, 0.0, 0.0, 0.0],
                1: [3.0, 5.1, 7.3, 8.6, 5.4, 0.0, 0.0, 0.0, 0.0],
                2: [1.8, 3.9, 7.0, 10.9, 6.4, 0.0, 0.0, 0.0, 0.0],
            },
        },
    },
}

class sessionClass {
  // Initialize the class
  constructor(argv = {}) {
    this.debug = argv.debug

    let dirname = __dirname
    if ( argv.data_directory ) {
      dirname = argv.data_directory
    }

    // Define some file paths and names
    this.DATA_DIRECTORY = path.join(dirname, 'data')
    this.CACHE_DIRECTORY = path.join(dirname, 'cache')
    this.IMAGE_DIRECTORY = path.join(dirname, 'img')

    this.CREDENTIALS_FILE = path.join(dirname, 'credentials.json')
    this.PROTECTION_FILE = path.join(dirname, 'protection.json')
    this.COOKIE_FILE = path.join(this.DATA_DIRECTORY, 'cookies.json')
    this.DATA_FILE = path.join(this.DATA_DIRECTORY, 'data.json')
    this.CACHE_FILE = path.join(this.CACHE_DIRECTORY, 'cache.json')
    this.STREAM_FINDER_SETTINGS_FILE = path.join(this.DATA_DIRECTORY, 'stream_finder_settings.json')

    // Read credentials from file, if present
    this.credentials = this.readFileToJson(this.CREDENTIALS_FILE) || {}

    // Check if account credentials were provided and if they are different from the stored credentials
    if ( argv.account_username && argv.account_password && ((argv.account_username != this.credentials.account_username) || (argv.account_password != this.credentials.account_password)) ) {
      this.log('updating account credentials')
      this.credentials.account_username = argv.account_username
      this.credentials.account_password = argv.account_password
      this.save_credentials()
      this.clear_session_data()
    } else {
      // Prompt for credentials if they don't exist
      if ( !this.credentials.account_username || !this.credentials.account_password ) {
        this.debuglog('prompting for account credentials')
        try {
          this.credentials.account_username = readlineSync.question('Enter account username (email address): ')
          this.credentials.account_password = readlineSync.question('Enter account password: ', { hideEchoBack: true })
        } catch {
          this.log('error: required account credentials not present in Docker compose/run')
          process.exit(1)
        }
        this.save_credentials()
        this.clear_session_data()
      }
    }

    // If page username/password protection is specified, retrieve or generate a random string of random length
    // to protect non-page content (streams, playlists, guides, images)
    this.protection = {}
    if ( argv.page_username && argv.page_password ) {
      // Read protection data from file, if present
      this.protection = this.readFileToJson(this.PROTECTION_FILE) || {}

      // Check if content_protect key was provided and if it is different from the stored one
      if ( argv.content_protect && (argv.content_protect != this.protection.content_protect) ) {
        this.log('using specified content protection key')
        this.log('you may need to update any content URLs you have copied outside of mlbserver')
        this.protection.content_protect = argv.content_protect
      } else {
        // Generate a content_protect key if it doesn't exist
        if ( !this.protection.content_protect ) {
          this.log('generating new content protection key')
          this.log('** YOU WILL NEED TO UPDATE ANY CONTENT URLS YOU HAVE COPIED OUTSIDE OF MLBSERVER **')
          this.protection.content_protect = this.getRandomString(this.getRandomInteger(32,64))
          this.save_protection()
        }
      }
    }

    // Create storage directory if it doesn't already exist
    this.createDirectory(this.DATA_DIRECTORY)

    // Set multiview path
    if ( argv.multiview_path ) {
      this.multiview_path = path.join(argv.multiview_path, path.basename(dirname))
      this.createDirectory(this.multiview_path)
      this.multiview_path = path.join(this.multiview_path, MULTIVIEW_DIRECTORY_NAME)
    } else {
      this.multiview_path = path.join(dirname, MULTIVIEW_DIRECTORY_NAME)
    }
    this.createDirectory(this.multiview_path)

    // Create cookie storage file if it doesn't already exist
    this.createFile(this.COOKIE_FILE)
    // Verify its contents are valid
    let cookieStr = fs.readFileSync(this.COOKIE_FILE)
    if ( (cookieStr != '') && !this.isValidJson(cookieStr) ) {
      this.log('invalid cookie storage file contents, resetting')
      fs.unlinkSync(this.COOKIE_FILE)
      this.createFile(this.COOKIE_FILE)
    }

    // Set up http requests with the cookie jar
    this.request = require('request-promise')
    this.jar = this.request.jar(new FileCookieStore(this.COOKIE_FILE))
    this.request = this.request.defaults({timeout:15000, agent:false, jar: this.request.jar()})

    // Load session data and cache from files
    this.data = this.readFileToJson(this.DATA_FILE) || {}
    this.cache = this.readFileToJson(this.CACHE_FILE) || {}
    this.stream_finder_settings = this.readFileToJson(this.STREAM_FINDER_SETTINGS_FILE) || {}

    // Define empty temporary cache (for skip, gamechanger, and key data)
    this.temp_cache = {}
    // Store previous keys, for return without retrieval
    this.temp_cache.prevKeys = {}

    // Default scan_mode and linkType values
    if ( !this.data.scan_mode ) {
      this.setScanMode('off')
    }
    if ( !this.data.linkType ) {
      this.setLinkType('embed')
    }

    // Check if fav teams was provided and if they are different from the stored fav teams
    if ( argv.fav_teams ) {
      let fav_teams_arg = argv.fav_teams.toString().toUpperCase()
      if ( fav_teams_arg == 'TRUE' ) {
        fav_teams_arg = []
      } else {
        fav_teams_arg = fav_teams_arg.replace(/[^A-Z,]+/g,'').split(',')
      }
      if ( (typeof(this.credentials.fav_teams) === 'undefined') || (fav_teams_arg.toString() != this.credentials.fav_teams.toString()) ) {
        this.log('updating fav teams')
        this.credentials.fav_teams = fav_teams_arg
        this.save_credentials()
      }
    } else {
      // Prompt for fav_teams
      if ( typeof(this.credentials.fav_teams) === 'undefined' ) {
        this.debuglog('prompting for fav teams')
        let team_abbreviations = Object.keys(TEAM_IDS)
        try {
          this.credentials.fav_teams = readlineSync.question('Enter favorite team(s) (optional, separate by comma from ' + team_abbreviations.join() + '): ').toUpperCase().replace(/[^A-Z,]+/g,'').split(',')
        } catch {
          this.log('no favorite team specified')
          this.credentials.fav_teams = ''
        }
        this.save_credentials()
      }
    }
    if ( (this.credentials.fav_teams != '') && !this.credentials.fav_teams.every(v => Object.keys(TEAM_IDS).includes(v)) ) {
      this.log('warning: one or more fav_teams abbreviation is invalid')
    }

    // Check if free account
    this.free = false
    if (argv.free) {
      this.debuglog('labeling free games')
      this.free = true
    }

    // Check if extra gamechanger delay is specified
    this.gamechanger_delay = 0
    if (argv.gamechanger_delay && Number.isInteger(parseInt(argv.gamechanger_delay))) {
      this.gamechanger_delay = Math.round(parseInt(argv.gamechanger_delay) / 10) * 10
      this.debuglog('adding ' + this.gamechanger_delay + ' seconds extra delay to gamechanger')
    }
  }

  // Store the ports, used for generating URLs
  setPorts(port, multiviewPort) {
    this.data.port = port
    this.data.multiviewPort = multiviewPort
    this.save_session_data()
  }

  // Set the scan_mode
  // "on" will return the sample stream for all live channels.m3u stream requests
  setScanMode(x) {
    this.log('scan_mode set to ' + x)
    this.data.scan_mode = x
    this.save_session_data()
  }

  // Set the linkType
  // used for storing the desired page type across throughout site navigation
  setLinkType(x) {
    this.data.linkType = x
    this.save_session_data()
  }

  // Set the multiview stream URL path
  setMultiviewStreamURLPath(url_path) {
    this.data.multiviewStreamURLPath = url_path
    this.save_session_data()
  }

  // Some basic self-explanatory functions
  createDirectory(directoryPath) {
    if (fs.existsSync(directoryPath) && !fs.lstatSync(directoryPath).isDirectory() ){
      fs.unlinkSync(directoryPath);
    }
    if (!fs.existsSync(directoryPath)){
      fs.mkdirSync(directoryPath);
    }
  }

  createFile(filePath) {
    if (!fs.existsSync(filePath)) {
      fs.closeSync(fs.openSync(filePath, 'w'))
    }
  }

  isValidJson(str) {
    try {
      JSON.parse(str);
    } catch (e) {
      return false;
    }
    return true;
  }

  readFileToJson(filePath) {
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath))
    }
  }

  writeJsonToFile(jsonStr, filePath) {
    if (this.isValidJson(jsonStr)) {
      fs.writeFileSync(filePath, jsonStr)
    }
  }

  checkValidItem(item, obj) {
    if (obj.includes(item)) {
      return true
    }
    return false
  }

  returnValidItem(item, obj) {
    if (!obj.includes(item)) return obj[0]
    else return item
  }

  sortObj(obj) {
    return Object.keys(obj).sort().reduce(function (result, key) {
      result[key] = obj[key];
      return result;
    }, {});
  }

  localTimeString() {
    let curDate = new Date()
    return curDate.toLocaleString()
  }

  getTodayUTCHours() {
    return TODAY_UTC_HOURS
  }

  getUserAgent() {
    return USER_AGENT
  }

  getLevels() {
    return LEVELS
  }

  getLidomId() {
    return LIDOM_ID
  }

  getLevelNameFromSportId(sportId) {
    let sportIds = Object.values(LEVELS)
    for (var i=0; i<sportIds.length; i++) {
      if ( sportId == sportIds[i] ) {
        let levelNames = Object.keys(LEVELS)
        return levelNames[i]
      }
    }
  }

  getTeamIds(team_abbr = false) {
    if ( team_abbr ) {
      return TEAM_IDS[team_abbr]
    } else {
      return Object.values(TEAM_IDS).toString() + ',159,160'
    }
  }

  getLidomTeamIds(team_abbr = false) {
    if ( team_abbr ) {
      return LIDOM_TEAM_IDS[team_abbr]
    } else {
      return Object.values(LIDOM_TEAM_IDS).toString()
    }
  }

  getAffiliateTeamIds(team_abbr = false) {
    if ( team_abbr ) {
      return AFFILIATE_TEAM_IDS[team_abbr]
    } else {
      return Object.values(AFFILIATE_TEAM_IDS).toString()
    }
  }

  getOrgs() {
    return Object.keys(AFFILIATE_TEAM_IDS)
  }

  // get parent org nickname
  getParent(parent) {
    let long_orgs = [ 'Jays', 'Sox' ]
    let parent_array = parent.split(' ')
    parent = parent_array[parent_array.length-1]
    if ( long_orgs.includes(parent) ) {
      parent = parent_array[parent_array.length-2] + ' ' + parent
    }
    return parent
  }

  // the live date is today's date, or if before a specified hour (UTC time), then use yesterday's date
  liveDate(hour = TODAY_UTC_HOURS) {
    let curDate = new Date()
    if ( curDate.getUTCHours() < hour ) {
      curDate.setDate(curDate.getDate()-1)
    }
    return curDate.toISOString().substring(0,10)
  }

  yesterdayDate() {
    let curDate = new Date(this.liveDate())
    curDate.setDate(curDate.getDate()-1)
    return curDate.toISOString().substring(0,10)
  }

  convertDateToXMLTV(x) {
    let newDate = String(x.getFullYear()) + String(x.getMonth() + 1).padStart(2, '0') + String(x.getDate()).padStart(2, '0') + String(x.getHours()).padStart(2, '0') + String(x.getMinutes()).padStart(2, '0') + String(x.getSeconds()).padStart(2, '0') + " "
    let offset = x.getTimezoneOffset()
    if ( offset > 0 ) {
      newDate += "-"
    } else {
      offset = Number(String(offset).substring(1,offset.length));
      newDate += "+"
    }
    newDate += String((offset / 60)).padStart(2, '0') + "00"
    return newDate
  }

  convertStringToAirDate(s) {
    return s.substr(0,19).replace('T', ' ')
  }

  convertDateToAirDate(d) {
    return this.convertStringToAirDate(d.toISOString())
  }

  getCacheUpdatedDate(dateString) {
    return this.cache.dates[dateString].updated
  }

  setHighlightsCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.highlights ) {
      this.cache.highlights={}
    }
    if ( !this.cache.highlights[cache_name] ) {
      this.cache.highlights[cache_name] = {}
    }
    this.cache.highlights[cache_name].highlightsCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setBlackoutsCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.blackouts ) {
      this.cache.blackouts={}
    }
    if ( !this.cache.blackouts[cache_name] ) {
      this.cache.blackouts[cache_name] = {}
    }
    this.cache.blackouts[cache_name].blackoutsCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setDateCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.dates ) {
      this.cache.dates={}
    }
    if ( !this.cache.dates[cache_name] ) {
      this.cache.dates[cache_name] = {}
    }
    this.cache.dates[cache_name].dateCacheExpiry = expiryDate
    this.cache.dates[cache_name].updated = this.localTimeString()
    this.save_cache_data()
  }

  setWeekCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.weeks ) {
      this.cache.weeks={}
    }
    if ( !this.cache.weeks[cache_name] ) {
      this.cache.weeks[cache_name] = {}
    }
    this.cache.weeks[cache_name].weekCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setAiringsCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.airings ) {
      this.cache.airings={}
    }
    if ( !this.cache.airings[cache_name] ) {
      this.cache.airings[cache_name] = {}
    }
    this.cache.airings[cache_name].airingsCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setGamedayCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.gameday ) {
      this.cache.gameday={}
    }
    if ( !this.cache.gameday[cache_name] ) {
      this.cache.gameday[cache_name] = {}
    }
    this.cache.gameday[cache_name].gamedayCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setBreakExpiry(id, game_pk) {
    let currentDate = new Date()
    currentDate.setSeconds(currentDate.getSeconds()+109)
    this.temp_cache.gamechanger[id].break_expiries[game_pk] = currentDate
  }

  removeBreakExpiry(id, game_pk) {
    delete this.temp_cache.gamechanger[id].break_expiries[game_pk]
  }

  createMediaCache(mediaId) {
    if ( !this.cache.media ) {
      this.cache.media = {}
    }
    if ( !this.cache.media[mediaId] ) {
      this.cache.media[mediaId] = {}
    }
  }

  setRecapRundownCacheExpiry(dateString, expiryDate) {
    if ( !this.cache.recapRundown ) {
      this.cache.recapRundown = {}
    }
    if ( !this.cache.recapRundown[dateString] ) {
      this.cache.recapRundown[dateString] = {}
    }
    this.cache.recapRundown[dateString].recapRundownCacheExpiry = expiryDate
    this.save_cache_data()
  }

  cacheStreamURL(mediaId, streamURL, streamURLToken='', streamURLExpiration='', rawStreamURL='') {
    this.createMediaCache(mediaId)
    this.cache.media[mediaId].streamURL = streamURL
    if (streamURLToken != '') {
      this.cache.media[mediaId].streamURLToken = streamURLToken
    }
    if (streamURLExpiration == '') {
      // Expire it in 1 minute
      let seconds_to_expire = 60
      this.cache.media[mediaId].streamURLExpiry = new Date(new Date().getTime() + seconds_to_expire * 1000)
    } else {
      this.cache.media[mediaId].streamURLExpiry = new Date(streamURLExpiration)
    }
    this.cache.media[mediaId].rawStreamURL = rawStreamURL
    this.save_cache_data()
  }

  markBlackoutError(mediaId) {
    this.createMediaCache(mediaId)
    this.log('saving blackout error to prevent repeated access attempts')
    this.cache.media[mediaId].blackout = true
    // Expire it in 1 hour
    let seconds_to_expire = 60*60
    this.cache.media[mediaId].blackoutExpiry = new Date(new Date().getTime() + seconds_to_expire * 1000)
    this.save_cache_data()
  }

  log(msg) {
    console.log(this.localTimeString() + ' ' + msg)
  }

  debuglog(msg) {
    if (this.debug) this.log(msg)
  }

  requestlog(type, req, debug=false) {
    if ( req.url ) {
      let msg = type + ' request : ' + req.url
      if ( req.headers && req.headers['x-forwarded-for'] ) {
        msg += ' from: ' + req.headers['x-forwarded-for']
      } else if ( req.connection && req.connection.remoteAddress ) {
        msg += ' from: ' + req.connection.remoteAddress
      }
      if ( req.headers && req.headers['user-agent'] ) msg += ' using: ' + req.headers['user-agent']
      if (!debug || this.debug) this.log(msg)
    }
  }

  halt(msg) {
    this.log(msg)
    process.exit(1)
  }

  logout() {
    try {
      fs.unlinkSync(this.CREDENTIALS_FILE)
    } catch(e){
      this.debuglog('credentials cannot be cleared or do not exist yet : ' + e.message)
    }
  }

  clear_session_data() {
    try {
      fs.unlinkSync(this.COOKIE_FILE)
      fs.unlinkSync(this.DATA_FILE)
    } catch(e){
      this.debuglog('session cannot be cleared or does not exist yet : ' + e.message)
    }
  }

  clear_cache() {
    try {
      fs.unlinkSync(this.CACHE_FILE)
    } catch(e){
      this.debuglog('cache cannot be cleared or does not exist yet : ' + e.message)
    }
  }

  get_multiview_directory() {
    return this.multiview_path
  }

  clear_multiview_files() {
    try {
      if ( this.multiview_path ) {
        fs.readdir(this.multiview_path, (err, files) => {
          if (err) throw err

          for (const file of files) {
            fs.unlink(path.join(this.multiview_path, file), err => {
              if (err) throw err
            })
          }
        })
      }
    } catch(e){
      this.debuglog('clear multiview files error : ' + e.message)
    }
  }

  save_credentials() {
    this.writeJsonToFile(JSON.stringify(this.credentials), this.CREDENTIALS_FILE)
    this.debuglog('credentials saved to file')
  }

  save_protection() {
    this.writeJsonToFile(JSON.stringify(this.protection), this.PROTECTION_FILE)
    this.debuglog('protection data saved to file')
  }

  save_session_data() {
    this.createDirectory(this.DATA_DIRECTORY)
    this.writeJsonToFile(JSON.stringify(this.data), this.DATA_FILE)
    this.debuglog('session data saved to file')
  }

  save_cache_data() {
    this.createDirectory(this.CACHE_DIRECTORY)
    this.writeJsonToFile(JSON.stringify(this.cache), this.CACHE_FILE)
    this.debuglog('cache data saved to file')
  }

  save_json_cache_file(cache_name, cache_data) {
    this.createDirectory(this.CACHE_DIRECTORY)
    this.writeJsonToFile(JSON.stringify(cache_data), path.join(this.CACHE_DIRECTORY, cache_name+'.json'))
    this.debuglog('cache file saved')
  }

  parse_stream_finder_settings(body) {
    this.stream_finder_settings = JSON.parse(body.match(/^([{][\s\S]+[}])$/m)[1])
    this.debuglog('stream finder settings parsed')
    this.save_stream_finder_settings()
  }

  save_stream_finder_settings() {
    this.createDirectory(this.DATA_DIRECTORY)
    this.writeJsonToFile(JSON.stringify(this.stream_finder_settings), this.STREAM_FINDER_SETTINGS_FILE)
    this.debuglog('stream finder settings saved to file')
  }

  // Generate a random integer in a range
  getRandomInteger(min, max) {
    return Math.floor(Math.random() * (max - min) ) + min;
  }

  // Generate a random string of specified length
  getRandomString(length) {
    var s = ''
    do {
      s += Math.random().toString(36).substr(2);
    } while (s.length < length)
    s = s.substr(0, length)

    return s
  }

  // Generic http GET request function
  httpGet(reqObj, exit=true) {
    reqObj.jar = this.jar
    return new Promise((resolve, reject) => {
      this.request.get(reqObj)
      .then(function(body) {
        resolve(body)
      })
      .catch(function(e) {
        console.log('http get failed : ' + e.message)
        console.log(reqObj)
        if ( exit ) {
          process.exit(1)
        } else {
          resolve(false)
        }
      })
    })
  }

  // Generic http POST request function
  httpPost(reqObj) {
    reqObj.jar = this.jar
    return new Promise((resolve, reject) => {
      this.request.post(reqObj)
      .then(function(body) {
        resolve(body)
      })
      .catch(function(e) {
        console.log('http post failed : ' + e.message)
        console.log(reqObj)
        process.exit(1)
      })
    })
  }

  // request to use when fetching videos
  streamVideo(u, opts, tries, cb) {
    opts.jar = this.jar
    opts.headers = {
      'User-Agent': USER_AGENT
    }
    if ( opts.referer ) {
      opts.headers['Referer'] = opts.referer
      delete opts.headers.Authorization
    }
    if ( opts.origin ) {
      opts.headers['Origin'] = opts.origin
    }
    if ( opts['x-cdn-token'] ) {
      opts.headers['x-cdn-token'] = opts['x-cdn-token']
    }
    this.request(u, opts, cb)
    .catch(function(e) {
      let curDate = new Date()
      console.log(curDate.toLocaleString() + ' stream video failed on url : ' + u)
      console.log(curDate.toLocaleString() + ' stream video failed with error : ' + e.message.toString())
      console.log(curDate.toLocaleString() + ' stream video failed with headers: ' + JSON.stringify(opts.headers))
      if ( (tries == 0) && !u.startsWith('http://127.0.0.1') ) process.exit(1)
    })
  }

  // new API call
  async getDeviceId() {
    this.debuglog('getDeviceId')
    if ( !this.data.deviceId ) {
      await this.getSession()
    }
    if ( this.data.deviceId ) {
      this.debuglog('using cached deviceId')
      return this.data.deviceId
    } else {
      this.log('failed to getDeviceId')
    }
  }

  // new API call
  async getSessionId() {
    this.debuglog('getSessionId')
    if ( !this.data.sessionId ) {
      await this.getSession()
    }
    if ( this.data.sessionId ) {
      this.debuglog('using cached sessionId')
      return this.data.sessionId
    } else {
      this.log('failed to getSessionId')
    }
  }

  // new API call
  async getEntitlements() {
    this.debuglog('getEntitlements')
    if ( !this.data.entitlements ) {
      await this.getSession()
    }
    if ( this.data.entitlements ) {
      this.debuglog('using cached entitlements')
      return this.data.entitlements
    } else {
      this.log('failed to getEntitlements')
    }
  }

  // new API call
  async getSession() {
    this.debuglog('getSession')
    let reqObj = {
      url: GRAPHQL_URL,
      headers: {
        'accept': 'application/json, text/plain, */*',
		    'accept-encoding': 'gzip, deflate, br',
		    'accept-language': 'en-US,en;q=0.5',
		    'authorization': 'Bearer ' + await this.getLoginToken() || this.halt('missing loginToken'),
		    'connection': 'keep-alive',
		    'content-type': 'application/json',
		    'x-client-name': 'WEB',
		    'x-client-version': '7.8.1',
        'origin': 'https://www.mlb.com',
        'referer': 'https://www.mlb.com/',
        'user-agent': USER_AGENT
      },
      body: {
        'operationName': 'initSession',
        'query': 'mutation initSession($device: InitSessionInput!, $clientType: ClientType!, $experience: ExperienceTypeInput) {\n    initSession(device: $device, clientType: $clientType, experience: $experience) {\n        deviceId\n        sessionId\n        entitlements {\n            code\n        }\n        location {\n            countryCode\n            regionName\n            zipCode\n            latitude\n            longitude\n        }\n        clientExperience\n        features\n    }\n  }',
        'variables': {
          'device': {
            'appVersion': '7.8.1',
            'deviceFamily': 'desktop',
            'knownDeviceId': '',
            'languagePreference': 'ENGLISH',
            'manufacturer': 'Apple',
            'model': 'Macintosh',
            'os': 'macos',
            'osVersion': '10.15'
          },
          'clientType': 'WEB'
        }
      },
      json: true,
      gzip: true
    }
    var response = await this.httpPost(reqObj)
    if ( response ) {
      this.debuglog('getSession response : ' + JSON.stringify(response))
      this.data.deviceId = response.data.initSession.deviceId
      this.data.sessionId = response.data.initSession.sessionId
      var entitlements = []
      for (var i=0; i<response.data.initSession.entitlements.length; i++) {
        entitlements.push(response.data.initSession.entitlements[i].code)
      }
      this.data.entitlements = entitlements
      this.save_session_data()
    } else {
      this.log('getSession response failure')
    }
  }

  // new API call
  async getStreamURL(mediaId) {
    this.debuglog('getStreamURL from ' + mediaId)
    if ( this.cache.media && this.cache.media[mediaId] && this.cache.media[mediaId].streamURL && this.cache.media[mediaId].streamURLToken && this.cache.media[mediaId].streamURLExpiry && (Date.parse(this.cache.media[mediaId].streamURLExpiry) > new Date()) ) {
      this.debuglog('using cached streamURL and token')
      let streamInfo = {streamURL: this.cache.media[mediaId].streamURL, streamURLToken: this.cache.media[mediaId].streamURLToken}
      if ( this.cache.media[mediaId].rawStreamURL ) {
        streamInfo['rawStreamURL'] = this.cache.media[mediaId].rawStreamURL
      }
      return streamInfo
    } else if ( this.cache.media && this.cache.media[mediaId] && this.cache.media[mediaId].blackout && this.cache.media[mediaId].blackoutExpiry && (Date.parse(this.cache.media[mediaId].blackoutExpiry) > new Date()) ) {
      this.log('mediaId recently blacked out, skipping')
    } else {
      let reqObj = {
        url: GRAPHQL_URL,
        simple: false,
        headers: {
          'accept': 'application/json, text/plain, */*',
  		    'accept-encoding': 'gzip, deflate, br',
  		    'accept-language': 'en-US,en;q=0.5',
  		    'authorization': 'Bearer ' + await this.getLoginToken() || this.halt('missing loginToken'),
  		    'connection': 'keep-alive',
  		    'content-type': 'application/json',
  		    'x-client-name': 'WEB',
  		    'x-client-version': '7.8.1',
          'origin': 'https://www.mlb.com',
          'referer': 'https://www.mlb.com/',
          'user-agent': USER_AGENT
        },
        body: {
          'operationName': 'initPlaybackSession',
          'query': 'mutation initPlaybackSession(\n        $adCapabilities: [AdExperienceType]\n        $mediaId: String!\n        $deviceId: String!\n        $sessionId: String!\n        $quality: PlaybackQuality\n    ) {\n        initPlaybackSession(\n            adCapabilities: $adCapabilities\n            mediaId: $mediaId\n            deviceId: $deviceId\n            sessionId: $sessionId\n            quality: $quality\n        ) {\n            playbackSessionId\n            playback {\n                url\n                token\n                expiration\n                cdn\n            }\n            adScenarios {\n                adParamsObj\n                adScenarioType\n                adExperienceType\n            }\n            adExperience {\n                adExperienceTypes\n                adEngineIdentifiers {\n                    name\n                    value\n                }\n                adsEnabled\n            }\n            heartbeatInfo {\n                url\n                interval\n            }\n            trackingObj\n        }\n    }',
          'variables': {
            'adCapabilities': [
              'NONE'
            ],
            'deviceId': await this.getDeviceId() || this.halt('missing deviceId'),
            'mediaId': mediaId,
            'quality': 'PLACEHOLDER',
            'sessionId': await this.getSessionId() || this.halt('missing sessionId')
          }
        },
        json: true,
        gzip: true
      }
      var response = await this.httpPost(reqObj)
      if ( response ) {
        this.debuglog('getStreamURL response : ' + JSON.stringify(response))
        if ( response.data && response.data.initPlaybackSession && response.data.initPlaybackSession.playback && response.data.initPlaybackSession.playback.url ) {
          let rawStreamURL = response.data.initPlaybackSession.playback.url
          this.debuglog('getStreamURL rawStreamURL : ' + rawStreamURL)
          let streamURL = rawStreamURL.replace(/[\/]([A-Za-z0-9_]+)[\/]/, '/')
  		  let streamURLToken = response.data.initPlaybackSession.playback.token
  		  let streamURLExpiration = response.data.initPlaybackSession.playback.expiration
          this.debuglog('getStreamURL streamURL : ' + streamURL)
          this.debuglog('getStreamURL token : ' + streamURLToken)
          this.debuglog('getStreamURL expiration : ' + streamURLExpiration)
          this.cacheStreamURL(mediaId, streamURL, streamURLToken, streamURLExpiration, rawStreamURL)
          let streamInfo = {streamURL: streamURL, streamURLToken: streamURLToken, rawStreamURL: rawStreamURL}
          return streamInfo
        } else {
          this.log('getStreamURL streamURL not found')
          return false
        }
      } else {
        this.log('getStreamURL response failure')
      }
    }
  }

  // API call
  async getLoginToken() {
    this.debuglog('getLoginToken')
    if ( !this.data.loginToken || !this.data.loginTokenExpiry || (Date.parse(this.data.loginTokenExpiry) < new Date()) ) {
      this.debuglog('need to get loginToken')
      let reqObj = {
        url: 'https://ids.mlb.com/oauth2/aus1m088yK07noBfh356/v1/token',
        headers: {
          'user-agent': USER_AGENT,
          'content-type': 'application/x-www-form-urlencoded'
        },
        form: {
          'username': this.credentials.account_username || this.halt('missing account username'),
          'password': this.credentials.account_password || this.halt('missing account password'),
          'grant_type': 'password',
          'scope': 'openid offline_access',
          'client_id': '0oa3e1nutA1HLzAKG356'
        }
      }
      var response = await this.httpPost(reqObj)
      if ( this.isValidJson(response) ) {
        this.debuglog('getLoginToken : ' + response)
        let obj = JSON.parse(response)
        this.debuglog('getLoginToken token : ' + obj.access_token)
        this.debuglog('getLoginToken expires in : ' + obj.expires_in)
        this.data.loginToken = obj.access_token
        this.data.loginTokenExpiry = new Date(new Date().getTime() + obj.expires_in * 1000)
        this.save_session_data()
        await this.getSession()
        return this.data.loginToken
      } else {
        this.log('getLoginToken response failure')
      }
    } else {
      this.debuglog('using cached loginToken')
      return this.data.loginToken
    }
  }

  // API call
  async getOktaId() {
    this.debuglog('getOktaId')
    if ( !this.data.oktaId ) {
      this.debuglog('need to get oktaId')
      // get a sample playback token from which to extract the base64-encoded okta_id
      let token

      // use any currently cached playback token
      try {
        this.debuglog('getOktaId attempting to use cached playback token')
        let mediaIds = Object.keys(this.cache.media)
        for (var i=0; i<mediaIds.length; i++) {
          if ( this.cache.media[mediaIds[i]].streamURLToken && (this.cache.media[mediaIds[i]].streamURLToken != '') ) {
            this.debuglog('getOktaId using cached playback token')
            token = this.cache.media[mediaIds[i]].streamURLToken
            break
          }
        }
      } catch(e) {
        this.debuglog('getOktaId failed to use cached playback token')
      }

      // otherwise, get a new playback token for a past free game
      if ( !token ) {
        this.debuglog('getOktaId getting new playback token')
        let streamInfo = await this.getStreamURL('b7f0fff7-266f-4171-aa2d-af7988dc9302')
        token = streamInfo.streamURLToken
      }

      if ( token ) {
        this.debuglog('getOktaId using token ' + token)
        let encoded_okta_id = token.split('_')[1]
        let okta_id = Buffer.from(encoded_okta_id + '==', 'base64').toString('ascii')
        this.debuglog('getOktaId extracted okta_id ' + okta_id)
        this.data.oktaId = okta_id
        this.save_session_data()
        return this.data.oktaId
      } else {
        this.debuglog('failed to get oktaId')
      }
    } else {
      this.debuglog('using cached oktaId')
      return this.data.oktaId
    }
  }

  // get mediaId for a live channel request
  async getMediaId(team, level, mediaType, mediaDate, gameNumber, includeBlackouts) {
    try {
      this.debuglog('getMediaId')

      var language = 'en'
      if ( mediaType == 'Video' ) {
        mediaType = 'MLBTV'
      } else if ( (mediaType == 'Audio') || (mediaType == 'Spanish') ) {
        if ( mediaType == 'Spanish' ) {
          mediaType = 'Audio'
          language = 'es'
        }
      }

      let today = this.liveDate()
      let gameDate = today
      if ( mediaDate == 'yesterday' ) {
        gameDate = this.yesterdayDate()
      } else if ( (mediaDate) && (mediaDate != 'today') ) {
        gameDate = mediaDate
      }

      if ( gameDate <= today ) {
        let mediaInfo = {}

        let cache_data
        let cache_name = gameDate
        let cache_file = path.join(this.CACHE_DIRECTORY, gameDate+'.json')
        let currentDate = new Date()
        cache_data = await this.getDayData(gameDate)

        if ( cache_data ) {
          let nationalCount = 0
          let freeCount = 0
          let blackouts = {}
          if ( includeBlackouts == 'false' ) blackouts = await this.get_blackout_games(cache_data.dates[0].date, true)

          for (var j = 0; j < cache_data.dates[0].games.length; j++) {
            if ( mediaInfo.mediaId || mediaInfo.gamePk ) break

            let gamePk = cache_data.dates[0].games[j].gamePk.toString()

            if ( typeof cache_data.dates[0].games[j] !== 'undefined' ) {
              let home_team = cache_data.dates[0].games[j].teams['home'].team.abbreviation
              let away_team = cache_data.dates[0].games[j].teams['away'].team.abbreviation
              let home_level = cache_data.dates[0].games[j].teams['home'].team.sport.id
              let away_level = cache_data.dates[0].games[j].teams['away'].team.sport.id
              this.debuglog('checking game ' + cache_data.dates[0].games[j].teams['home'].team.abbreviation + '@' + cache_data.dates[0].games[j].teams['away'].team.abbreviation)

              // check that that game involves the requested team, or if we've requested a national or free game
              if ( ((team.toUpperCase() == home_team) && (LEVELS[level.toUpperCase()] == home_level)) || ((team.toUpperCase() == away_team) && (LEVELS[level.toUpperCase()] == away_level)) || ((team.toUpperCase().indexOf('NATIONAL.') == 0) && (home_level == LEVELS['MLB'])) || ((team.toUpperCase().startsWith('FREE.') && cache_data.dates[0].games[j].broadcasts && cache_data.dates[0].games[j].broadcasts[0] && (cache_data.dates[0].games[j].broadcasts[0].freeGame == true))) ) {

                // Check if Winter League / MiLB game first
                if ( (away_level != LEVELS['MLB']) && (home_level != LEVELS['MLB']) && (mediaType == 'MLBTV') ) {
                  this.debuglog('matched non-MLB team for ' + cache_data.dates[0].games[j].teams['home'].team.abbreviation + '@' + cache_data.dates[0].games[j].teams['away'].team.abbreviation)
                  if ( cache_data.dates[0].games[j].broadcasts ) {
                    let broadcastName = 'N/A'
                    for (var k = 0; k < cache_data.dates[0].games[j].broadcasts.length; k++) {
                      if ( cache_data.dates[0].games[j].broadcasts[k].name != 'Audio' ) {
                        broadcastName = mediaType
                        break
                      }
                    }
                    if ( broadcastName == 'N/A' ) {
                      break
                    } else {
                      if ( gameNumber && (gameNumber > 1) ) {
                        this.debuglog('matched team for MILB game number 1')
                        gameNumber--
                      } else {
                        this.debuglog('matched team for MILB event')
                        mediaInfo.gamePk = gamePk
                        break
                      }
                    }
                  }
                }

                // MLB games
                if ( cache_data.dates[0].games[j].broadcasts ) {
                  let teamType
                  // initial loop will count number of broadcasts
                  let broadcast_count = await this.count_broadcasts(cache_data.dates[0].games[j].broadcasts, mediaType, language)
                  for (var k = 0; k < cache_data.dates[0].games[j].broadcasts.length; k++) {
                    if ( mediaInfo.mediaId ) break
                    let broadcast = cache_data.dates[0].games[j].broadcasts[k]
                    if ( broadcast.availableForStreaming == false ) continue
                    if ( blackouts[gamePk] && blackouts[gamePk].blackout_feeds && blackouts[gamePk].blackout_feeds.includes(broadcast.mediaId) ) {
                      continue
                    }
                    let mediaTitle = 'Audio'
                    if ( broadcast.type == 'TV' ) {
                      mediaTitle = 'MLBTV'
                    } else if ( broadcast.language == 'es' ) {
                      mediaTitle = 'Spanish'
                    }
                    if ( mediaType == mediaTitle ) {
                      teamType = broadcast.homeAway

                      let station = broadcast.callSign

                      // process requested national games (with the team/channel NATIONAL.x)
                      if ( (team.toUpperCase().indexOf('NATIONAL.') == 0) && ((broadcast.isNational == true) || ((mediaType == 'MLBTV') && (cache_data.dates[0].games[j].seriesDescription != 'Regular Season') && (cache_data.dates[0].games[j].seriesDescription != 'Spring Training'))) ) {

                        nationalCount += 1
                        let nationalArray = team.split('.')
                        if ( (nationalArray.length == 2) && (nationalArray[1] == nationalCount) ) {
                          this.debuglog('matched national event')
                          mediaInfo = await this.check_media_state(broadcast, cache_data.dates[0].games[j].status.abstractGameState, mediaDate, cache_data.dates[0].games[j].gamePk)
                          break
                        }

                        // process requested free games (with the team/channel FREE.x)
                      } else if ( team.toUpperCase().startsWith('FREE.') && (broadcast.freeGame == true) ) {

                          freeCount += 1
                          let freeArray = team.split('.')
                          if ( (freeArray.length == 2) && (freeArray[1] == freeCount) ) {
                            this.debuglog('matched free event')
                            mediaInfo = await this.check_media_state(broadcast, cache_data.dates[0].games[j].status.abstractGameState, mediaDate, cache_data.dates[0].games[j].gamePk)
                            break
                          }

                      // process requested team games
                      } else if ( (team.toUpperCase() == home_team) || (team.toUpperCase() == away_team) ) {

                        if ( ((team.toUpperCase() == home_team) && (teamType == 'home')) || ((team.toUpperCase() == away_team) && (teamType == 'away')) || (broadcast_count == 1) ) {
                          if ( gameNumber && (gameNumber > 1) ) {
                            this.debuglog('matched team for game number 1')
                            gameNumber--
                          } else {
                            this.debuglog('matched team for event')
                            mediaInfo = await this.check_media_state(broadcast, cache_data.dates[0].games[j].status.abstractGameState, mediaDate, cache_data.dates[0].games[j].gamePk)
                            break
                          }
                        }

                      }

                    } // end mediaType check
                  } // end for loop

                }

              }
            }
          }

          if (mediaInfo.mediaId || mediaInfo.gamePk) {
            return mediaInfo
          }
        }
        this.log('could not find mediaId or gamePk')
      } else {
        this.log('will not find mediaId for future date')
      }
    } catch(e) {
      this.log('getMediaId error : ' + e.message)
    }
  }

  // get highlights for a game
  async getHighlightsData(gamePk, gameDate) {
    try {
      this.debuglog('getHighlightsData for ' + gamePk)

      let cache_data
      let cache_name = 'h' + gamePk
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.highlights || !this.cache.highlights[cache_name] || !this.cache.highlights[cache_name].highlightsCacheExpiry || (currentDate > new Date(this.cache.highlights[cache_name].highlightsCacheExpiry)) ) {
        let reqObj = {
          url: 'https://statsapi.mlb.com/api/v1/game/' + gamePk + '/content',
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          //this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 hour from now
          let oneHourFromNow = new Date()
          oneHourFromNow.setHours(oneHourFromNow.getHours()+1)
          let cacheExpiry = oneHourFromNow

          let today = this.liveDate()
          let yesterday = this.yesterdayDate()
          if ( gameDate == today ) {
            if ( (cache_data.media) && (cache_data.media.epg) ) {
              for (var i = 0; i < cache_data.media.epg.length; i++) {
                if ( cache_data.media.epg[i].items && cache_data.media.epg[i].items[0] && cache_data.media.epg[i].items[0].mediaState && (cache_data.media.epg[i].items[0].mediaState == 'MEDIA_ON') ) {
                  this.debuglog('setting cache expiry to 5 minute due to in progress games')
                  currentDate.setMinutes(currentDate.getMinutes()+5)
                  cacheExpiry = currentDate
                  break
                }
              }
            }
          } else if ( gameDate < today ) {
            this.debuglog('1+ days old, setting cache expiry to forever')
            cacheExpiry = new Date(8640000000000000)
          }

          // finally save the setting
          this.setHighlightsCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached highlight data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data && cache_data.highlights && cache_data.highlights.highlights && cache_data.highlights.highlights.items) {
        var array = cache_data.highlights.highlights.items
        return array.sort(this.GetSortOrder('date'))
      }
    } catch(e) {
      this.log('getHighlightsData error : ' + e.message)
    }
  }

  GetSortOrder(prop) {
    return function(a, b) {
      if (a[prop] > b[prop]) {
        return 1
      } else if (a[prop] < b[prop]) {
        return -1
      }
      return 0
    }
  }

  GetSortOrderReverse(prop) {
    return function(a, b) {
      if (a[prop] < b[prop]) {
        return 1
      } else if (a[prop] > b[prop]) {
        return -1
      }
      return 0
    }
  }

  // get data for a day, either from cache or an API call
  async getDayData(dateString, team = false, level_ids = LEVELS.All, team_ids = '') {
    try {
      let cache_data
      let cache_name = dateString
      if ( level_ids != LEVELS['MLB'] ) {
        cache_name += '.' + level_ids
      }
      if ( team_ids != '' ) {
        cache_name += '.' + team_ids
      }
      //let data_url = 'https://bdfed.stitch.mlbinfra.com/bdfed/transform-mlb-scoreboard?stitch_env=prod&sortTemplate=2&sportId=1&sportId=17&startDate=' + dateString + '&endDate=' + dateString + '&gameType=E&&gameType=S&&gameType=R&&gameType=F&&gameType=D&&gameType=L&&gameType=W&&gameType=A&language=en&leagueId=104&leagueId=103&leagueId=131&contextTeamId='
      let data_url = 'https://statsapi.mlb.com/api/v1/schedule?sportId=' + level_ids
      if ( team_ids != '' ) {
        data_url += '&teamId=' + team_ids
      }
      data_url += '&startDate=' + dateString + '&endDate=' + dateString + '&hydrate=broadcasts(all),probablePitcher,linescore,team,flags,gameInfo'
      if ( team && !team.toUpperCase().startsWith('NATIONAL.') && !team.toUpperCase().startsWith('FREE.') ) {
        this.debuglog('getDayData for team ' + team + ' on date ' + dateString)
        cache_name = team.toUpperCase() + dateString
        data_url = 'https://statsapi.mlb.com/api/v1/schedule?sportId=1&teamId=' + TEAM_IDS[team.toUpperCase()] + '&startDate=' + dateString + '&endDate=' + dateString + '&hydrate=team,broadcasts(all)'
      } else {
        this.debuglog('getDayData for level(s) ' + level_ids + ' on date ' + dateString)
      }
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.dates || !this.cache.dates[cache_name] || !this.cache.dates[cache_name].dateCacheExpiry || (currentDate > new Date(this.cache.dates[cache_name].dateCacheExpiry)) ) {
        let reqObj = {
          url: data_url,
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          //this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 hour from now
          let oneHourFromNow = new Date()
          oneHourFromNow.setHours(oneHourFromNow.getHours()+1)
          let cacheExpiry = oneHourFromNow

          let today = this.liveDate()
          let yesterday = this.yesterdayDate()
          if ( (dateString == today) && cache_data.dates && cache_data.dates[0] && cache_data.dates[0].games && (cache_data.dates[0].games.length > 1) ) {
            let finals = false
            for (var i = 0; i < cache_data.dates[0].games.length; i++) {
              if ( ((cache_data.dates[0].games[i].status.abstractGameState == 'Live') && (cache_data.dates[0].games[i].status.detailedState.indexOf('Suspended') != 0)) || ((cache_data.dates[0].games[i].status.startTimeTBD == true) && (cache_data.dates[0].games[i].status.abstractGameState != 'Final') && (i > 0) && (cache_data.dates[0].games[i-1].status.abstractGameState == 'Final')) ) {
                this.debuglog('setting cache expiry to 1 minute due to in progress games or upcoming TBD game')
                currentDate.setMinutes(currentDate.getMinutes()+1)
                cacheExpiry = currentDate
                break
              } else if ( cache_data.dates[0].games[i].status.abstractGameState == 'Final' ) {
                finals = true
              } else if ( (finals == false) && (cache_data.dates[0].games[i].status.startTimeTBD == false) ) {
                let nextGameDate = new Date(cache_data.dates[0].games[i].gameDate)
                nextGameDate.setHours(nextGameDate.getHours()-1)
                this.debuglog('setting cache expiry to 1 hour before next live game')
                cacheExpiry = nextGameDate
                break
              }
            }
          } else if ( dateString > today ) {
            this.debuglog('1+ days in the future, setting cache expiry to tomorrow')
            let tomorrowDate = new Date(today)
            tomorrowDate.setDate(tomorrowDate.getDate()+1)
            let utcHours = 10
            tomorrowDate.setHours(tomorrowDate.getHours()+utcHours)
            cacheExpiry = tomorrowDate
          } else if ( dateString < yesterday ) {
            this.debuglog('2+ days old, setting cache expiry to forever')
            cacheExpiry = new Date(8640000000000000)
          }

          // finally save the setting
          this.setDateCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached date data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getDayData error : ' + e.message)
    }
  }

  // get data for 3 weeks, either from cache or an API call
  async getWeeksData(level_ids, team_ids) {
    try {
      this.debuglog('getWeeksData')

      // use 5 AM UTC time as the threshold to advance 1 day
      let utcHours = 5

      let cache_data
      let cache_name = 'week'

      if ( level_ids != LEVELS['All'] ) {
        cache_name += '.' + level_ids
      }
      if ( team_ids != '' ) {
        cache_name += '.' + team_ids
      }

      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.weeks || !this.cache.weeks[cache_name] || !this.cache.weeks[cache_name].weekCacheExpiry || (currentDate > new Date(this.cache.weeks[cache_name].weekCacheExpiry)) ) {
        let startDate = this.liveDate(utcHours)
        let endDate = new Date(startDate)
        endDate.setDate(endDate.getDate()+20)
        endDate = endDate.toISOString().substring(0,10)
        let data_url = 'https://statsapi.mlb.com/api/v1/schedule?sportId=' + level_ids
        if ( team_ids != '' ) {
          data_url += '&teamId=' + team_ids
        }
        data_url += '&startDate=' + startDate + '&endDate=' + endDate + '&hydrate=broadcasts(all),probablePitcher,linescore,team'
        let reqObj = {
          //url: 'https://bdfed.stitch.mlbinfra.com/bdfed/transform-mlb-scoreboard?stitch_env=prod&sortTemplate=2&sportId=1&sportId=17&startDate=' + startDate + '&endDate=' + endDate + '&gameType=E&&gameType=S&&gameType=R&&gameType=F&&gameType=D&&gameType=L&&gameType=W&&gameType=A&language=en&leagueId=104&leagueId=103&leagueId=131&contextTeamId=',
          url: data_url,
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          //this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          this.debuglog('setting channels cache expiry to next day')
          let cacheExpiry = new Date(startDate)
          cacheExpiry.setDate(cacheExpiry.getDate()+1)
          cacheExpiry.setHours(cacheExpiry.getHours()+utcHours)
          // finally save the setting
          this.setWeekCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached week data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getWeeksData error : ' + e.message)
    }
  }

  // get TV data (channels or guide)
  async getTVData(dataType, mediaType, includeTeams, excludeTeams, includeLevels, includeOrgs, server, includeBlackouts, includeTeamsInTitles='false', offAir='false', resolution='best', pipe='false', startingChannelNumber=1) {
    try {
      this.debuglog('getTVData for ' + dataType)

      var body = ''
      // output M3U channel data, if requested
      if ( dataType == 'channels' ) {
        body = '#EXTM3U' + "\n"
      // output ICS calendar data, if requested
      } else if ( dataType == 'calendar' ) {
        body = 'BEGIN:VCALENDAR' + "\n" + 'PRODID:-//mlbserver//MLB Calendar//EN' + "\n" + 'VERSION:2.0'
      // otherwise output XML guide data
      } else {
        body = '<?xml version="1.0" encoding="UTF-8"?>' + "\n" +
        '<!DOCTYPE tv SYSTEM "xmltv.dd">' + "\n" +
        '  <tv generator-info-name="mlbserver" source-info-name="mlbserver">'
      }
      var channels = {}
      var calendar = ""
      var programs = ""

      try {
        this.debuglog('getTVData processing')

        var mediaFeedType = 'mediaFeedType'
        var language = 'en'
        if ( mediaType == 'Video' ) {
          mediaType = 'MLBTV'
        } else if ( (mediaType == 'Audio') || (mediaType == 'Spanish') ) {
          mediaFeedType = 'type'
          if ( mediaType == 'Spanish' ) {
            mediaType = 'Audio'
            language = 'es'
          }
        }

        var level_ids = LEVELS['All']
        var team_ids = ''
        if ( includeLevels.length > 0 ) {
          if ( (includeLevels.length > 1) || !includeLevels.includes('ALL') ) {
            let level_list = []
            for (let i = 0; i < includeLevels.length; i++) {
              if ( LEVELS[includeLevels[i]] ) {
                level_list.push(LEVELS[includeLevels[i]])
              }
            }
            level_ids = level_list.toString()
          }
        } else {
          if ( includeOrgs.length > 0 ) {
            team_ids = this.getTeamIds()
            for (let i = 0; i < includeOrgs.length; i++) {
              if ( AFFILIATE_TEAM_IDS[includeOrgs[i]] ) {
                team_ids += ',' + AFFILIATE_TEAM_IDS[includeOrgs[i]]
              }
            }
          } else if ( includeTeams.length > 0 ) {
            team_ids = this.getTeamIds()
            for (let i=0; i<includeTeams.length; i++) {
              if ( (includeTeams[i] != '') && AFFILIATE_TEAM_IDS[includeTeams[i]] ) {
                team_ids += ',' + AFFILIATE_TEAM_IDS[includeTeams[i]]
              }
            }
            if ( includeTeams.includes('LIDOM') ) {
              team_ids += ',' + this.getLidomTeamIds()
            }
          } else {
            team_ids = this.getTeamIds()
            for (let i=0; i<this.credentials.fav_teams.length; i++) {
              if ( (this.credentials.fav_teams[i] != '') && AFFILIATE_TEAM_IDS[this.credentials.fav_teams[i]] ) {
                team_ids += ',' + AFFILIATE_TEAM_IDS[this.credentials.fav_teams[i]]
              }
            }
            if ( (excludeTeams.length == 0) || !excludeTeams.includes('LIDOM') ) {
              team_ids += ',' + this.getLidomTeamIds()
            }
          }
        }

        let cache_data = await this.getWeeksData(level_ids, team_ids)
        if (cache_data) {
          let today = this.liveDate()
          let prevDateIndex = {MLBTV:-1,Free:-1,Audio:-1}

          let gameIndexes_obj = {}

          let blackouts = {}
          if ( includeBlackouts == 'false' ) blackouts = await this.get_blackout_games()
          
          let pre_post_shows = await this.get_pre_post_shows()

          for (var i = 0; i < cache_data.dates.length; i++) {
            this.debuglog('getTVData processing date ' + cache_data.dates[i].date)
            let dateIndex = {MLBTV:i,Free:i,Audio:i}
            let gameCounter = {MLBTV:0,Free:0,Audio:0}

            let gameIndexes = await this.get_first_and_last_games(cache_data.dates[i].games, blackouts)
            // store gameIndexes for gamechanger/multiview reference later
            gameIndexes_obj[cache_data.dates[i].date] = gameIndexes

            for (var j = 0; j < cache_data.dates[i].games.length; j++) {
              this.debuglog('getTVData processing game ' + j + ' for date ' + cache_data.dates[i].date)
              // Check if non-MLB (Winter League / MiLB) game first
              if ( (cache_data.dates[i].games[j].teams['home'].team.sport.id != LEVELS['MLB']) && (cache_data.dates[i].games[j].teams['away'].team.sport.id != LEVELS['MLB']) && (mediaType == 'MLBTV') ) {
                let league_id = cache_data.dates[i].games[j].teams['home'].team.league.id
                let broadcastName = 'N/A'
                if ( cache_data.dates[i].games[j].broadcasts ) {
                  for (var k = 0; k < cache_data.dates[i].games[j].broadcasts.length; k++) {
                    if ( cache_data.dates[i].games[j].broadcasts[k].name != 'Audio' ) {
                      broadcastName = mediaType
                      break
                    }
                  }
                }
                  if ( (broadcastName == 'N/A') && (league_id != LIDOM_ID) ) {
                    continue
                  } else {
                    //for (var k = 0; k < cache_data.dates[i].games[j].broadcasts.length; k++) {
                      if (broadcastName == 'N/A') broadcastName = 'MLBTV'
                      let team = cache_data.dates[i].games[j].teams['home'].team.abbreviation
                      let team_id = cache_data.dates[i].games[j].teams['home'].team.id.toString()
                      let opponent_team_id = cache_data.dates[i].games[j].teams['away'].team.id.toString()
                      if ( team_ids.split(',').includes(opponent_team_id) && !team_ids.split(',').includes(team_id) ) {
                        team_id = opponent_team_id
                        team = cache_data.dates[i].games[j].teams['away'].team.abbreviation
                      }
                      let sportId = cache_data.dates[i].games[j].teams['home'].team.sport.id
                      let channelid = mediaType + '.' + sportId + '.' + team
                      //let logo = server + '/image.svg?teamId=' + team_id
                      let logo = 'https://www.mlbstatic.com/team-logos/share/' + team_id + '.jpg'
                      //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
                      if ( league_id == LIDOM_ID ) {
                        let lidom_abbr = cache_data.dates[i].games[j].teams['home'].team.name.replace(/[^A-Z]/g, '').toLowerCase()
                        logo = 'https://pizarra.multimediard.com/ac/' + lidom_abbr + '.png'
                      }
                      let streamMediaType = 'Video'
                      let stream = server + '/stream.m3u8?team=' + encodeURIComponent(team) + '&mediaType=' + streamMediaType
                      if ( league_id == LIDOM_ID ) {
                        stream = server + '/stream.m3u8?event=' + encodeURIComponent(cache_data.dates[i].games[j].teams['home'].team.shortName.toUpperCase()) + '&mediaType=' + streamMediaType
                      }
                      stream += '&level=' + encodeURIComponent(this.getLevelNameFromSportId(sportId))
                      stream += '&resolution=' + resolution
                      if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
                      if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
                      if ( !channels[channelid] ) {
                        channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)
                      }

                      let title = 'Minor League Baseball'
                      if ( WINTER_LEAGUES.includes(league_id.toString()) ) {
                        title = cache_data.dates[i].games[j].teams['home'].team.league.name
                      }

                      let away_team = cache_data.dates[i].games[j].teams['away'].team.shortName
                      let home_team = cache_data.dates[i].games[j].teams['home'].team.shortName
                      let subtitle = away_team + ' at ' + home_team
                      
                      if ( includeTeamsInTitles != 'false' ) {
                        if ( includeTeamsInTitles == 'channels' ) {
                          title = this.channelsFormattedTitle(subtitle, cache_data.dates[i].games[j].gameDate)
                        } else {
                          if ( league_id == AFL_ID ) {
                            title = 'AFL'
                          } else if ( league_id == LIDOM_ID ) {
                            title = 'LIDOM'
                          } else {
                            title = 'MiLB'
                          }
                          title += ': ' + subtitle
                        }
                      }

                      let description = cache_data.dates[i].games[j].teams['home'].team.sport.name + ' ' + cache_data.dates[i].games[j].teams['home'].team.league.name + '. '
                      if ( cache_data.dates[i].games[j].seriesDescription != 'Regular Season' ) {
                        description += cache_data.dates[i].games[j].seriesDescription + '. '
                      }
                      if ( cache_data.dates[i].games[j].doubleHeader != 'N' ) {
                        description += 'Doubleheader game ' + cache_data.dates[i].games[j].gameNumber + '. '
                      }
                      var scheduledInnings = await this.get_scheduled_innings(cache_data.dates[0].games[j])
                      if ( scheduledInnings != '9' ) {
                        description += scheduledInnings + '-inning game. '
                      }
                      if ( cache_data.dates[i].games[j].teams['away'].team.parentOrgName && cache_data.dates[i].games[j].teams['home'].team.parentOrgName ) {
                        description += cache_data.dates[i].games[j].teams['away'].team.name + ' (' + this.getParent(cache_data.dates[i].games[j].teams['away'].team.parentOrgName) + ') at ' + cache_data.dates[i].games[j].teams['home'].team.name + ' (' + this.getParent(cache_data.dates[i].games[j].teams['home'].team.parentOrgName) + '). '
                      }
                      if ( (cache_data.dates[i].games[j].teams['away'].probablePitcher && cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName) || (cache_data.dates[i].games[j].teams['home'].probablePitcher && cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName) ) {
                        if ( cache_data.dates[i].games[j].teams['away'].probablePitcher && cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName ) {
                          description += cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName
                        } else {
                          description += 'TBD'
                        }
                        description += ' vs. '
                        if ( cache_data.dates[i].games[j].teams['home'].probablePitcher && cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName ) {
                          description += cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName
                        } else {
                          description += 'TBD'
                        }
                        description += '. '
                      }

                      let gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                      let gameHours = 3
                      // Handle suspended, TBD, and doubleheaders
                      if ( cache_data.dates[i].games[j].status.resumedFrom ) {
                        gameHours = 1
                        if ( cache_data.dates[i].games[j].description ) {
                          description += cache_data.dates[i].games[j].description
                        } else {
                          description += 'Resumption of suspended game.'
                        }
                        gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                        gameDate.setHours(gameDate.getHours()+1)
                      } else if ( (cache_data.dates[i].games[j].status.startTimeTBD == true) && (cache_data.dates[i].games[j].doubleHeader == 'Y') && (cache_data.dates[i].games[j].gameNumber == 2) ) {
                        description += 'Start time TBD.'
                        gameDate = new Date(cache_data.dates[i].games[j-1].gameDate)
                        gameDate.setHours(gameDate.getHours()+4)
                      } else if ( cache_data.dates[i].games[j].status.startTimeTBD == true ) {
                        continue
                      }
                      let start = this.convertDateToXMLTV(gameDate)
                      let calendar_start = gameDate
                      let stopDate = gameDate
                      stopDate.setHours(stopDate.getHours()+gameHours)
                      let stop = this.convertDateToXMLTV(gameDate)
                      let calendar_stop = stopDate

                      // MILB calendar ICS
                      let prefix = 'Watch'
                      let location = server + '/embed.html?team=' + encodeURIComponent(team) + '&mediaType=' + streamMediaType
                      if ( this.protection.content_protect ) location += '&content_protect=' + this.protection.content_protect
                      calendar += await this.generate_ics_event(prefix, calendar_start, calendar_stop, subtitle, description, location)
                      
                      // Off Air if necessary
                      let off_air_event = await this.generate_off_air_event(offAir, channelid, cache_data.dates[i].date, channels[channelid].stop, cache_data.dates[i].games[j].gameDate, cache_data.dates[i].games[j].teams['away'].team.shortName + ' at ' + cache_data.dates[i].games[j].teams['home'].team.shortName)
                      if ( off_air_event ) {
                        programs += off_air_event
                        channels[channelid].stop = stop
                      }

                      // MILB guide XML
                      programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertDateToAirDate(new Date(cache_data.dates[i].games[j].gameDate)), subtitle, team_id, cache_data.dates[i].games[j].gamePk, away_team, home_team)

                      //break
                    //}
                  }
              } else {
                // Begin MLB games
                if ( cache_data.dates[i].games[j].broadcasts ) {
                  // initial loop will count number of broadcasts
                  let broadcast_count = await this.count_broadcasts(cache_data.dates[i].games[j].broadcasts, mediaType, language)
                  for (var k = 0; k < cache_data.dates[i].games[j].broadcasts.length; k++) {
                    let broadcast = cache_data.dates[i].games[j].broadcasts[k]
                    if ( broadcast.availableForStreaming == true ) {
                      let mediaTitle = 'Audio'
                      if ( broadcast.type == 'TV' ) {
                        mediaTitle = 'MLBTV'
                      }
                      if ( mediaType == mediaTitle ) {
                      
                        // check blackout or non-entitlement status, if necessary
                        let gamePk = cache_data.dates[i].games[j].gamePk.toString()
                        if ( (includeBlackouts == 'false') && blackouts[gamePk] && blackouts[gamePk].blackout_feeds && blackouts[gamePk].blackout_feeds.includes(broadcast.mediaId) ) {
                          continue
                        }

                        if ( (broadcast.type == 'TV') || ((mediaType == 'Audio') && (broadcast.language == language)) ) {
                          let teamType = broadcast.homeAway

                          if ( (mediaType == 'MLBTV') && (cache_data.dates[i].games[j].seriesDescription != 'Regular Season') && (cache_data.dates[i].games[j].seriesDescription != 'Spring Training') ) {
                            teamType = 'NATIONAL'
                          }
                          let team = cache_data.dates[i].games[j].teams['home'].team.abbreviation
                          let opponent_team = cache_data.dates[i].games[j].teams['away'].team.abbreviation

                          let station = broadcast.callSign

                          if ( teamType == 'NATIONAL' ) {
                            if ( dateIndex[mediaTitle] > prevDateIndex[mediaTitle] ) {
                              prevDateIndex[mediaTitle] = dateIndex[mediaTitle]
                              gameCounter[mediaTitle] = 1
                            } else {
                              gameCounter[mediaTitle] += 1
                            }
                          } else {
                            teamType = teamType.toLowerCase()
                            let opponent_teamType = 'away'
                            if ( teamType == 'away' ) {
                              opponent_teamType = 'home'
                            }
                            team = cache_data.dates[i].games[j].teams[teamType].team.abbreviation
                            opponent_team = cache_data.dates[i].games[j].teams[opponent_teamType].team.abbreviation
                          }
                          if ( (excludeTeams.length > 0) && (excludeTeams.includes(team) || excludeTeams.includes(opponent_team) || ((teamType == 'NATIONAL') && excludeTeams.includes(teamType))) ) {
                            continue
                          } else if ( (includeTeams.length == 0) || includeTeams.includes(team) || ((teamType == 'NATIONAL') && (includeTeams.includes(teamType) || includeTeams.includes(opponent_team))) || ((broadcast_count == 1) && includeTeams.includes(opponent_team)) || ((broadcast.freeGame == true) && includeTeams.includes('FREE')) ) {
                            if ( (broadcast_count == 1) && !includeTeams.includes(team) && includeTeams.includes(opponent_team) ) {
                              team = opponent_team
                            }
                            let logo = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRi5AKF6eAu9Va9BzZzgw0PSsQXw8rXPiQLHA'
                            let seriesId = 'MLB'
                            if ( (teamType == 'NATIONAL') && ((includeTeams.length == 0) || ((includeTeams.length > 0) && includeTeams.includes(teamType))) ) {
                              team = teamType + '.' + gameCounter[mediaTitle]
                            } else if ( includeTeams.includes('FREE') && (broadcast.freeGame == true) ) {
                              if ( dateIndex['Free'] > prevDateIndex['Free'] ) {
                                prevDateIndex['Free'] = dateIndex['Free']
                                gameCounter['Free'] = 1
                              } else {
                                gameCounter['Free'] += 1
                              }
                              team = 'FREE.' + gameCounter['Free']
                            } else {
                              seriesId = cache_data.dates[i].games[j].teams[teamType].team.id
                              logo = 'https://www.mlbstatic.com/team-logos/share/' + cache_data.dates[i].games[j].teams[teamType].team.id + '.jpg'
                            }

                            let icon = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRi5AKF6eAu9Va9BzZzgw0PSsQXw8rXPiQLHA'
                            if ( (cache_data.dates[i].games[j].teams['home'].team.id >= 108) && (cache_data.dates[i].games[j].teams['home'].team.id <= 158) && (cache_data.dates[i].games[j].teams['away'].team.id >= 108) && (cache_data.dates[i].games[j].teams['away'].team.id <= 158) ) {
                              icon = 'https://img.mlbstatic.com/mlb-photos/image/upload/ar_167:215,c_crop/fl_relative,l_team:' + cache_data.dates[i].games[j].teams['home'].team.id + ':fill:spot.png,w_1.0,h_1,x_0.5,y_0,fl_no_overflow,e_distort:100p:0:200p:0:200p:100p:0:100p/fl_relative,l_team:' + cache_data.dates[i].games[j].teams['away'].team.id + ':logo:spot:current,w_0.38,x_-0.25,y_-0.16/fl_relative,l_team:' + cache_data.dates[i].games[j].teams['home'].team.id + ':logo:spot:current,w_0.38,x_0.25,y_0.16/w_750/team/' + cache_data.dates[i].games[j].teams['away'].team.id + '/fill/spot.png'
                            }

                            let channelid = mediaType
                            if ( language == 'es' ) {
                              channelid = 'Spanish'
                            }
                            channelid += '.' + team
                            let streamMediaType = mediaType
                            let channelMediaType = mediaType
                            if ( mediaType == 'MLBTV' ) {
                              streamMediaType = 'Video'
                            } else if ( language == 'es' ) {
                              streamMediaType = 'Spanish'
                              channelMediaType = 'Spanish'
                            }
                            let stream = server + '/stream.m3u8?team=' + encodeURIComponent(team) + '&mediaType=' + streamMediaType
                            if ( streamMediaType == 'Video' ) {
                              stream += '&resolution=' + resolution
                            }
                            if ( includeBlackouts == 'true' ) stream += '&includeBlackouts=' + includeBlackouts
                            if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
                            if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)

                            if ( !channels[channelid] ) {
                              channels[channelid] = await this.create_channel_object(channelid, logo, stream, channelMediaType)
                            }

                            let title = 'MLB Baseball'

                            let away_team = cache_data.dates[i].games[j].teams['away'].team.teamName
                            let home_team = cache_data.dates[i].games[j].teams['home'].team.teamName
                            let subtitle = away_team + ' at ' + home_team

                            if (includeTeamsInTitles != 'false') {
                              if ( includeTeamsInTitles == 'channels' ) {
                                title = this.channelsFormattedTitle(subtitle, cache_data.dates[i].games[j].gameDate)
                              } else {
                                title = 'MLB: ' + subtitle + ' (' + station
                                if ( language == 'es' ) {
                                  title += ' Spanish'
                                }
                                if ( mediaType == 'Audio' ) {
                                  title += ' Radio'
                                }
                                title += ')'
                              }
                            }

                            let description = station
                            if ( mediaType == 'Audio' ) {
                              if ( language == 'es' ) {
                                description += ' Spanish'
                              }
                              description += ' Radio'
                            }
                            description += '. '
                            if ( cache_data.dates[i].games[j].seriesDescription != 'Regular Season' ) {
                              description += cache_data.dates[i].games[j].seriesDescription + '. '
                            }
                            if ( cache_data.dates[i].games[j].doubleHeader != 'N' ) {
                              description += 'Doubleheader game ' + cache_data.dates[i].games[j].gameNumber + '. '
                            }
                            if ( (cache_data.dates[i].games[j].teams['away'].probablePitcher && cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName) || (cache_data.dates[i].games[j].teams['home'].probablePitcher && cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName) ) {
                              if ( cache_data.dates[i].games[j].teams['away'].probablePitcher && cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName ) {
                                description += cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName
                              } else {
                                description += 'TBD'
                              }
                              description += ' vs. '
                              if ( cache_data.dates[i].games[j].teams['home'].probablePitcher && cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName ) {
                                description += cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName
                              } else {
                                description += 'TBD'
                              }
                              description += '. '
                            }

                            let gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                            let gameHours = 3
                            // Handle suspended, TBD, and doubleheaders
                            if ( cache_data.dates[i].games[j].status.resumedFrom ) {
                              gameHours = 1
                              if ( cache_data.dates[i].games[j].description ) {
                                description += cache_data.dates[i].games[j].description
                              } else {
                                description += 'Resumption of suspended game.'
                              }
                              gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                              gameDate.setHours(gameDate.getHours()+1)
                            } else if ( (cache_data.dates[i].games[j].status.startTimeTBD == true) && (cache_data.dates[i].games[j].doubleHeader == 'Y') && (cache_data.dates[i].games[j].gameNumber == 2) ) {
                              description += 'Start time TBD.'
                              gameDate = new Date(cache_data.dates[i].games[j-1].gameDate)
                              gameDate.setHours(gameDate.getHours()+4)
                            } else if ( cache_data.dates[i].games[j].status.startTimeTBD == true ) {
                              continue
                            }
                            let start = this.convertDateToXMLTV(gameDate)
                            let calendar_start = gameDate
                            let stopDate = gameDate
                            stopDate.setHours(stopDate.getHours()+gameHours)
                            let stop = this.convertDateToXMLTV(stopDate)
                            let calendar_stop = stopDate

                            // MLB calendar ICS
                            let prefix = 'Watch'
                            if ( mediaType == 'Audio' ) {
                              prefix = 'Listen'
                              if ( language == 'es' ) {
                                prefix += ' (in Spanish)'
                              }
                              prefix += ' to'
                            }
                            let location = server + '/embed.html?team=' + encodeURIComponent(team) + '&mediaType=' + streamMediaType
                            if ( streamMediaType == 'Video' ) {
                              location += '&resolution=' + resolution
                            }
                            if ( includeBlackouts == 'true' ) location += '&includeBlackouts=' + includeBlackouts
                            if ( this.protection.content_protect ) location += '&content_protect=' + this.protection.content_protect
                            calendar += await this.generate_ics_event(prefix, calendar_start, calendar_stop, subtitle, description, location)

                            // MLB guide XML
                            programs += await this.generate_xml_program(channelid, start, stop, title, description, icon, this.convertDateToAirDate(new Date(cache_data.dates[i].games[j].gameDate)), subtitle, seriesId, cache_data.dates[i].games[j].gamePk, away_team, home_team)
                            
                            // pre- and post-game shows
                            if ( pre_post_shows.pregame_shows[broadcast.mediaId] || pre_post_shows.postgame_shows[broadcast.mediaId] ) {
                              if ( (pre_post_shows.pregame_shows[broadcast.mediaId] && (pre_post_shows.pregame_shows[broadcast.mediaId].team == 'home')) || (pre_post_shows.postgame_shows[broadcast.mediaId] && (pre_post_shows.postgame_shows[broadcast.mediaId].team == 'home')) ) {
                               away_team = false
                              } else {
                               home_team = false
                              }
                              // pre-game
                              if ( pre_post_shows.pregame_shows[broadcast.mediaId] ) {
                                let pre_start = this.convertDateToXMLTV(new Date(pre_post_shows.pregame_shows[broadcast.mediaId].start))
                                title = cache_data.dates[i].games[j].teams[pre_post_shows.pregame_shows[broadcast.mediaId].team].team.teamName + ' Pregame'
                                let preSeriesId = seriesId + '1'
                                programs += await this.generate_xml_program(channelid, pre_start, start, title, '', icon, this.convertDateToAirDate(new Date(pre_post_shows.pregame_shows[broadcast.mediaId].start)), '', preSeriesId, cache_data.dates[i].games[j].gamePk, away_team, home_team)
                                start = pre_start
                              }
                              // post-game
                              if ( pre_post_shows.postgame_shows[broadcast.mediaId] ) {
                                let postgameMinutes = 30
                                let startDate = stopDate
                                stopDate.setMinutes(stopDate.getMinutes()+postgameMinutes)
                                let post_stop = this.convertDateToXMLTV(stopDate)
                                title = cache_data.dates[i].games[j].teams[pre_post_shows.postgame_shows[broadcast.mediaId].team].team.teamName + ' Postgame'
                                let postSeriesId = seriesId + '2'
                                programs += await this.generate_xml_program(channelid, stop, post_stop, title, '', icon, this.convertDateToAirDate(startDate), '', postSeriesId, cache_data.dates[i].games[j].gamePk, away_team, home_team)
                                stop = post_stop
                              }
                            }
                            
                            // Off Air if necessary
                            let off_air_event = await this.generate_off_air_event(offAir, channelid, cache_data.dates[i].date, channels[channelid].stop, cache_data.dates[i].games[j].gameDate, subtitle)
                            if ( off_air_event ) {
                              programs += off_air_event
                              channels[channelid].stop = stop
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              this.debuglog('getTVData completed game ' + j + ' for date ' + cache_data.dates[i].date)
            }
            this.debuglog('getTVData completed date ' + cache_data.dates[i].date)
          }
          channels = this.sortObj(channels)
          
          let entitlements = await this.getEntitlements()
          // MLB Network live stream for eligible USA subscribers
          try {
              if ( (entitlements.includes('MLBN') || entitlements.includes('EXECMLB') || entitlements.includes('MLBTVMLBNADOBEPASS')) ) {
                if ( (mediaType == 'MLBTV') && ((includeLevels.length == 0) || includeLevels.includes('MLB') || includeLevels.includes('ALL')) ) {
                  if ( (excludeTeams.length > 0) && excludeTeams.includes('MLBN') ) {
                    // do nothing
                  } else if ( (includeTeams.length == 0) || includeTeams.includes('MLBN') ) {
                    this.debuglog('getTVData processing MLB Network')
                    let logo = 'https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcQRgC2JdbtFplKjfhXm5_vzpkUQ3XyDT91SEnHmuB0p5tReQ3Ez'
                    let channelid = mediaType + '.MLBN'
                    //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
                    let stream = server + '/stream.m3u8?event=mlbn&mediaType=Video&resolution=' + resolution
                    if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
                    if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
                    channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

                    let title = 'MLB Network'
                    let description = 'Live stream of MLB Network'

                    let start = this.convertDateToXMLTV(new Date(cache_data.dates[0].date + ' 00:00:00'))
                    let stop = this.convertDateToXMLTV(new Date(cache_data.dates[cache_data.dates.length-1].date + ' 00:00:00'))

                    // MLB Network guide XML
                    programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertStringToAirDate(cache_data.dates[0].date))
                    this.debuglog('getTVData completed MLB Network')
                  } // end includeTeams check
                } // end mediaType check
              } // end entitlements check
          } catch (e) {
            this.debuglog('getTVData MLB Network detect error : ' + e.message)
          }
          
          // SNLA live stream for entitled subscribers
          try {
              if ( (entitlements.includes('SNLA_119')) ) {
                if ( (mediaType == 'MLBTV') && ((includeLevels.length == 0) || includeLevels.includes('MLB') || includeLevels.includes('ALL')) ) {
                  if ( (excludeTeams.length > 0) && excludeTeams.includes('SNLA') ) {
                    // do nothing
                  } else if ( (includeTeams.length == 0) || includeTeams.includes('SNLA') ) {
                    this.debuglog('getTVData processing SNLA')
                    let logo = 'https://img.mlbstatic.com/mlb-images/image/upload/t_w640/mlb/fnwk2k0kgn1j8r8vvx3d.png'
                    let channelid = mediaType + '.SNLA'
                    //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
                    let stream = server + '/stream.m3u8?event=snla&mediaType=Video&resolution=' + resolution
                    if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
                    if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
                    channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

                    let title = 'SportsNet LA'
                    let description = 'Live stream of SNLA'

                    let start = this.convertDateToXMLTV(new Date(cache_data.dates[0].date + ' 00:00:00'))
                    let stop = this.convertDateToXMLTV(new Date(cache_data.dates[cache_data.dates.length-1].date + ' 00:00:00'))

                    // SNLA guide XML
                    programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertStringToAirDate(cache_data.dates[0].date))
                    this.debuglog('getTVData completed SNLA')
                  } // end includeTeams check
                } // end mediaType check
              } // end entitlements check
          } catch (e) {
            this.debuglog('getTVData SNLA detect error : ' + e.message)
          }
          
          // SNY live stream for entitled subscribers
          try {
              if ( (entitlements.includes('SNY_121')) ) {
                if ( (mediaType == 'MLBTV') && ((includeLevels.length == 0) || includeLevels.includes('MLB') || includeLevels.includes('ALL')) ) {
                  if ( (excludeTeams.length > 0) && excludeTeams.includes('SNY') ) {
                    // do nothing
                  } else if ( (includeTeams.length == 0) || includeTeams.includes('SNY') ) {
                    this.debuglog('getTVData processing SNY')
                    let logo = 'https://img.mlbstatic.com/mlb-images/image/upload/t_w640/mlb/le5jifzo6oylxtnuf0m1.png'
                    let channelid = mediaType + '.SNY'
                    //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
                    let stream = server + '/stream.m3u8?event=sny&mediaType=Video&resolution=' + resolution
                    if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
                    if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
                    channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

                    let title = 'SNY'
                    let description = 'Live stream of SNY'

                    let start = this.convertDateToXMLTV(new Date(cache_data.dates[0].date + ' 00:00:00'))
                    let stop = this.convertDateToXMLTV(new Date(cache_data.dates[cache_data.dates.length-1].date + ' 00:00:00'))

                    // SNLA guide XML
                    programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertStringToAirDate(cache_data.dates[0].date))
                    this.debuglog('getTVData completed SNY')
                  } // end includeTeams check
                } // end mediaType check
              } // end entitlements check
          } catch (e) {
            this.debuglog('getTVData SNY detect error : ' + e.message)
          }

          // Big Inning
          if ( (entitlements.length > 0) && (mediaType == 'MLBTV') && ((includeLevels.length == 0) || includeLevels.includes('MLB') || includeLevels.includes('ALL')) ) {
            if ( (excludeTeams.length > 0) && excludeTeams.includes('BIGINNING') ) {
              // do nothing
            } else if ( (includeTeams.length == 0) || includeTeams.includes('BIGINNING') ) {
              this.debuglog('getTVData processing Big Inning')
              let logo = 'https://img.mlbstatic.com/mlb-images/image/private/ar_16:9,g_auto,q_auto:good,w_372,c_fill,f_jpg/mlb/uwr8vepua4t1fe8uwyki'
              let channelid = mediaType + '.BIGINNING'
              //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
              let stream = server + '/stream.m3u8?event=biginning&mediaType=Video&resolution=' + resolution
              if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
              if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
              channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

              let title = 'MLB Big Inning'
              let description = 'Live look-ins and big moments from around the league'

              for (var i = 0; i < cache_data.dates.length; i++) {
                // Scraped Big Inning schedule
                if ( (cache_data.dates[i].date >= today) && cache_data.dates[i].games && (cache_data.dates[i].games.length > 1) && cache_data.dates[i].games[0] && (cache_data.dates[i].games[0].seriesDescription == 'Regular Season') ) {
                  await this.getBigInningSchedule()
                }
                this.debuglog('getTVData processing Big Inning for date ' + cache_data.dates[i].date)
                let gameDate = cache_data.dates[i].date
                if ( (gameDate >= today) && cache_data.dates[i].games && (cache_data.dates[i].games.length > 1) && cache_data.dates[i].games[0] && (cache_data.dates[i].games[0].seriesDescription == 'Regular Season') && this.cache.bigInningSchedule[gameDate] ) {
                  this.debuglog('getTVData Big Inning active for date ' + cache_data.dates[i].date)
                  // Scraped Big Inning schedule
                  let start = this.convertDateToXMLTV(new Date(this.cache.bigInningSchedule[gameDate].start))
                  let stop = this.convertDateToXMLTV(new Date(this.cache.bigInningSchedule[gameDate].end))

                  // Big Inning calendar ICS
                  let prefix = 'Watch'
                  let location = server + '/embed.html?event=biginning&mediaType=Video&resolution=' + resolution
                  if ( this.protection.content_protect ) location += '&content_protect=' + this.protection.content_protect
                  calendar += await this.generate_ics_event(prefix, new Date(this.cache.bigInningSchedule[gameDate].start), new Date(this.cache.bigInningSchedule[gameDate].end), title, description, location)
                  
                  // Off Air if necessary
                  let off_air_event = await this.generate_off_air_event(offAir, channelid, gameDate, channels[channelid].stop, this.cache.bigInningSchedule[gameDate].start, title)
                  if ( off_air_event ) {
                    programs += off_air_event
                    channels[channelid].stop = stop
                  }

                  // Big Inning guide XML
                  programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertDateToAirDate(new Date(this.cache.bigInningSchedule[gameDate].start)))
                }
                this.debuglog('getTVData completed Big Inning for date ' + cache_data.dates[i].date)
              }
              
              // generic Big Inning guide XML
              /*let start = this.convertDateToXMLTV(new Date(cache_data.dates[0].date + ' 00:00:00'))
              let stop = this.convertDateToXMLTV(new Date(cache_data.dates[cache_data.dates.length-1].date + ' 00:00:00'))
              programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertStringToAirDate(cache_data.dates[0].date))*/
              
              this.debuglog('getTVData completed Big Inning')
            }
          }

          // Game Changer
          if ( (entitlements.length > 0) && (mediaType == 'MLBTV') && ((includeLevels.length == 0) || includeLevels.includes('MLB') || includeLevels.includes('ALL')) ) {
            if ( (excludeTeams.length > 0) && excludeTeams.includes('GAMECHANGER') ) {
              // do nothing
            } else if ( (includeTeams.length == 0) || includeTeams.includes('GAMECHANGER') ) {
              this.debuglog('getTVData processing Game Changer')
              let channelid = mediaType + '.GAMECHANGER'
              //let logo = server + '/image.svg?teamId=MLB'
              //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
              let logo = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRi5AKF6eAu9Va9BzZzgw0PSsQXw8rXPiQLHA'
              let stream = server + '/gamechanger.m3u8?resolution=' + resolution
              if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
              if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
              channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

              let title = 'MLB.TV Game Changer'
              let description = 'Automatically switches between the highest leverage active live games.'

              for (var i = 0; i < cache_data.dates.length; i++) {
                if ( cache_data.dates[i].games.length > 1 ) {
                  this.debuglog('getTVData processing Game Changer for date ' + cache_data.dates[i].date)
                  let gameIndexes = gameIndexes_obj[cache_data.dates[i].date]
                  if ( (typeof gameIndexes.firstGameIndex !== 'undefined') && (typeof gameIndexes.lastGameIndex !== 'undefined') && (gameIndexes.firstGameIndex !== gameIndexes.lastGameIndex) ) {
                    this.debuglog('getTVData Game Changer available for date ' + cache_data.dates[i].date)
                    let gameDate = new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate)
                    let start = this.convertDateToXMLTV(gameDate)
                    gameDate = new Date(cache_data.dates[i].games[gameIndexes.lastGameIndex].gameDate)
                    let stopDate = gameDate
                    stopDate.setHours(gameDate.getHours()+4)
                    let stop = this.convertDateToXMLTV(stopDate)

                    // Game Changer calendar ICS
                    let prefix = 'Watch'
                    let location = server + '/embed.html?src=' + encodeURIComponent(stream)
                    if ( this.protection.content_protect ) location += '&content_protect=' + this.protection.content_protect
                    calendar += await this.generate_ics_event(prefix, new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate), gameDate, title, description, location)
                    
                    // Off Air if necessary
                    let off_air_event = await this.generate_off_air_event(offAir, channelid, cache_data.dates[i].date, channels[channelid].stop, cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate, title)
                    if ( off_air_event ) {
                      programs += off_air_event
                      channels[channelid].stop = stop
                    }

                    // Game Changer guide XML
                    programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertDateToAirDate(gameDate))
                  }
                  this.debuglog('getTVData completed Game Changer for date ' + cache_data.dates[i].date)
                }
              }
              this.debuglog('getTVData completed Game Changer')
            }
          }

          // Stream Finder
          if ( (entitlements.length > 0) && (mediaType == 'MLBTV') && ((includeLevels.length == 0) || includeLevels.includes('MLB') || includeLevels.includes('ALL')) ) {
            if ( (excludeTeams.length > 0) && excludeTeams.includes('STREAMFINDER') ) {
              // do nothing
            } else if ( (includeTeams.length == 0) || includeTeams.includes('STREAMFINDER') ) {
              this.debuglog('getTVData processing Stream Finder')
              let channelid = mediaType + '.STREAMFINDER'
              //let logo = server + '/image.svg?teamId=MLB'
              //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
              let logo = server + '/stream_finder_icon.png'
              let stream = server + '/gamechanger.m3u8?streamFinder=on&resolution=' + resolution
              if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
              if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
              channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

              let title = 'MLB.TV Stream Finder'
              let description = 'Automatically switches between games according to your preferences. This stream is not affiliated with Baseball Reference, do not contact them for support. Visit http://bit.ly/bbrefsf to create and export your preferences, then upload and save them to mlbserver at ' + server

              for (var i = 0; i < cache_data.dates.length; i++) {
                if ( cache_data.dates[i].games.length > 1 ) {
                  this.debuglog('getTVData processing Stream Finder for date ' + cache_data.dates[i].date)
                  let gameIndexes = gameIndexes_obj[cache_data.dates[i].date]
                  if ( (typeof gameIndexes.firstGameIndex !== 'undefined') && (typeof gameIndexes.lastGameIndex !== 'undefined') && (gameIndexes.firstGameIndex !== gameIndexes.lastGameIndex) ) {
                    this.debuglog('getTVData Stream Finder available for date ' + cache_data.dates[i].date)
                    let gameDate = new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate)
                    let start = this.convertDateToXMLTV(gameDate)
                    gameDate = new Date(cache_data.dates[i].games[gameIndexes.lastGameIndex].gameDate)
                    let stopDate = gameDate
                    stopDate.setHours(gameDate.getHours()+4)
                    let stop = this.convertDateToXMLTV(stopDate)

                    // Stream Finder calendar ICS
                    let prefix = 'Watch'
                    let location = server + '/embed.html?src=' + encodeURIComponent(stream)
                    if ( this.protection.content_protect ) location += '&content_protect=' + this.protection.content_protect
                    calendar += await this.generate_ics_event(prefix, new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate), gameDate, title, description, location)
                    
                    // Off Air if necessary
                    let off_air_event = await this.generate_off_air_event(offAir, channelid, cache_data.dates[i].date, channels[channelid].stop, cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate, title)
                    if ( off_air_event ) {
                      programs += off_air_event
                      channels[channelid].stop = stop
                    }

                    // Stream Finder guide XML
                    programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertDateToAirDate(gameDate))
                  }
                  this.debuglog('getTVData completed Stream Finder for date ' + cache_data.dates[i].date)
                }
              }
              this.debuglog('getTVData completed Stream Finder')
            }
          }

          // Multiview
          if ( (entitlements.length > 0) && (mediaType == 'MLBTV') && (typeof this.data.multiviewStreamURLPath !== 'undefined') && ((includeLevels.length == 0) || includeLevels.includes('MLB') || includeLevels.includes('ALL')) ) {
            if ( (excludeTeams.length > 0) && excludeTeams.includes('MULTIVIEW') ) {
              // do nothing
            } else if ( (includeTeams.length == 0) || includeTeams.includes('MULTIVIEW') ) {
              this.debuglog('getTVData processing Multiview')
              let channelid = mediaType + '.MULTIVIEW'
              //let logo = server + '/image.svg?teamId=MLB'
              //if ( this.protection.content_protect ) logo += '&amp;content_protect=' + this.protection.content_protect
              let logo = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRi5AKF6eAu9Va9BzZzgw0PSsQXw8rXPiQLHA'
              let stream = server + '/stream.m3u8?src=' + encodeURIComponent('http://127.0.0.1:' + this.data.multiviewPort + this.data.multiviewStreamURLPath)
              if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
              if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
              channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

              let title = 'MLB.TV Multiview'
              let description = 'Watch up to 4 games at once. Requires starting the multiview stream in the web interface first, and stopping it when done.'

              for (var i = 0; i < cache_data.dates.length; i++) {
                if ( cache_data.dates[i].games.length > 1 ) {
                  this.debuglog('getTVData processing Multiview for date ' + cache_data.dates[i].date)
                  let gameIndexes = gameIndexes_obj[cache_data.dates[i].date]
                  if ( (typeof gameIndexes.firstGameIndex !== 'undefined') && (typeof gameIndexes.lastGameIndex !== 'undefined') ) {
                    this.debuglog('getTVData Multiview active for date ' + cache_data.dates[i].date)
                    let gameDate = new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate)
                    let start = this.convertDateToXMLTV(gameDate)
                    gameDate = new Date(cache_data.dates[i].games[gameIndexes.lastGameIndex].gameDate)
                    let stopDate = gameDate
                    stopDate.setHours(stopDate.getHours()+4)
                    let stop = this.convertDateToXMLTV(stopDate)

                    // Multview calendar ICS
                    let prefix = 'Watch'
                    let location = stream.replace('/stream.m3u8?src=', '/embed.html?msrc=')
                    calendar += await this.generate_ics_event(prefix, new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate), gameDate, title, description, location)
                    
                    // Off Air if necessary
                    let off_air_event = await this.generate_off_air_event(offAir, channelid, cache_data.dates[i].date, channels[channelid].stop, cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate, title)
                    if ( off_air_event ) {
                      programs += off_air_event
                      channels[channelid].stop = stop
                    }

                    // Multview guide XML
                    programs += await this.generate_xml_program(channelid, start, stop, title, description, logo, this.convertDateToAirDate(gameDate))
                  }
                  this.debuglog('getTVData completed Multiview for date ' + cache_data.dates[i].date)
                }
              }
              this.debuglog('getTVData completed Multiview')
            }
          }
        }
      } catch(e) {
        this.log('getTVData processing error : ' + e.message)
      }

      // output M3U channel data, if requested
      if ( dataType == 'channels' ) {
        let channelnumber = startingChannelNumber
        for (const [key, value] of Object.entries(channels)) {
          body += '#EXTINF:-1 CUID="' + key + '" channelID="' + key + '" tvg-num="1.' + channelnumber + '" tvg-chno="1.' + channelnumber + '" tvg-id="' + key + '" tvg-name="' + key + '" tvg-logo="' + value.logo + '" group-title="' + value.mediatype + '",' + key + "\n"
          body += value.stream + "\n"
          channelnumber++
        }
      // output ICS calendar data, if requested
      } else if ( dataType == 'calendar' ) {
        body += calendar + "\n" + 'END:VCALENDAR'
      // otherwise output XML guide data
      } else {
        for (const [key, value] of Object.entries(channels)) {
          body += "\n" + '    <channel id="' + key + '">' + "\n" +
          '      <display-name>' + value.name + '</display-name>' + "\n" +
          '      <icon src="' + value.logo + '"></icon>' + "\n" +
          '    </channel>'
        }
        body += programs + "\n" + '  </tv>'
      }

      return body
    } catch(e) {
      this.log('getTVData error : ' + e.message)
    }
  }

  // Get image from cache or request
  async getImage(teamId) {
    this.debuglog('getImage ' + teamId)
    let imagePath = path.join(this.CACHE_DIRECTORY, teamId + '.svg')
    if ( fs.existsSync(imagePath) ) {
      this.debuglog('using cached image for ' + teamId)
      return fs.readFileSync(imagePath)
    } else {
      this.debuglog('requesting new image for ' + teamId)
      let imageURL = 'https://www.mlbstatic.com/team-logos/' + teamId + '.svg'
      if ( teamId == 'MLB' ) {
        imageURL = 'https://www.mlbstatic.com/team-logos/league-on-dark/1.svg'
      }
      let reqObj = {
        url: imageURL,
        headers: {
          'User-agent': USER_AGENT,
          'origin': 'https://www.mlb.com'
        }
      }
      var response = await this.httpGet(reqObj, false)
      if ( response ) {
        this.debuglog('getImage response : ' + response)
        fs.writeFileSync(imagePath, response)
      } else {
        this.debuglog('failed to get image for ' + teamId)
      }
    }
  }

  // Get image from cache or request
  async getPNGImage(name) {
    this.debuglog('getPNGImage ' + name)
    let imagePath = path.join(this.IMAGE_DIRECTORY, name + '.png')
    if ( fs.existsSync(imagePath) ) {
      this.debuglog('serving local image at ' + imagePath)
      return fs.readFileSync(imagePath)
    } else {
      this.debuglog('failed to get image at ' + imagePath)
      return
    }
  }

  // Get gameday data for a game (play and pitch data)
  async getGamedayData(gamePk) {
    try {
      this.debuglog('getGamedayData')

      let cache_data
      let cache_name = 'g' + gamePk
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.gameday || !this.cache.gameday[cache_name] || !this.cache.gameday[cache_name].gamedayCacheExpiry || (currentDate > new Date(this.cache.gameday[cache_name].gamedayCacheExpiry)) ) {
        let reqObj = {
          url: 'https://statsapi.mlb.com/api/v1.1/game/' + gamePk + '/feed/live',
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 hour from now
          let oneHourFromNow = new Date()
          oneHourFromNow.setHours(oneHourFromNow.getHours()+1)
          let cacheExpiry = oneHourFromNow

          if ( (cache_data.gameData.status.abstractGameState == 'Live') && (cache_data.gameData.status.detailedState.indexOf('Suspended') != 0) ) {
            this.debuglog('setting cache expiry to 5 minutes for live game')
            currentDate.setMinutes(currentDate.getMinutes()+5)
            cacheExpiry = currentDate
          } else {
            let today = this.liveDate()

            if ( cache_data.gameData.datetime.officialDate < today ) {
              this.debuglog('setting cache expiry to forever for past games')
              cacheExpiry = new Date(8640000000000000)
            }
          }

          // finally save the setting
          this.setGamedayCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid response from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached gameday data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getGamedayData error : ' + e.message)
    }
  }

  // Get variant playlist
  async getVariantPlaylist(streamURL, streamURLToken) {
    try {
      this.debuglog('getVariantPlaylist')
      
      // MLB version
      let variant = '_5600K'
      if ( streamURL.includes('milb.com') ) {
        variant = '_1280x720_59_5472K'
      }

      let variant_url = 'http://localhost:' + this.data.port + '/playlist.m3u8?url=' + encodeURIComponent(streamURL.substr(0,streamURL.length-5) + variant + '.m3u8')
      if ( streamURLToken ) {
        variant_url += '&streamURLToken=' + encodeURIComponent(streamURLToken)
      }
      if ( this.protection.content_protect ) {
        variant_url += '&content_protect=' + this.protection.content_protect
      }
      let reqObj = {
        url: variant_url
      }
      var response = await this.httpGet(reqObj, false)
      var body = response.replace(/^\s+|\s+$/g, '').split('\n')
      
      return body
    } catch(e) {
      this.log('getVariantPlaylist error : ' + e.message)
    }
  }

  // Get broadcast start timestamp
  async getBroadcastStart(variantPlaylist) {
    try {
      this.debuglog('getBroadcastStart')
      
      var body = variantPlaylist

      // check if HLS
      if ( body[0] != '#EXTM3U' ) {
        session.log('not a valid hls stream at ' + u)
        return
      }

      for (var i=0; i<body.length; i++) {
        if ( body[i].startsWith('#EXT-X-PROGRAM-DATE-TIME:') ) {
          return new Date(body[i].substr(25,body[i].length))
          break
        }
      }
    } catch(e) {
      this.log('getBroadcastStart error : ' + e.message)
    }
  }

  // Get skip markers into temporary cache
  async getSkipMarkers(gamePk, skip_type, start_inning, start_inning_half, streamURL, streamURLToken, skip_adjust) {
    try {
      this.debuglog('getSkipMarkers')

      if ( skip_adjust != 0 ) this.log('manual adjustment of ' + skip_adjust + ' seconds being applied')
      
      let event_start_padding = EVENT_START_PADDING
      let pitch_end_padding = PITCH_END_PADDING
      let action_end_padding = ACTION_END_PADDING
      if ( !streamURL.includes('milb.com') ) {
        event_start_padding += MLB_PADDING
        pitch_end_padding += MLB_PADDING
        action_end_padding += MLB_PADDING
      }

      if ( !this.temp_cache[gamePk] ) {
        this.temp_cache[gamePk] = {}
      }

      let skip_markers = []

      // assume the game starts in a break
      let break_start = 0

      // Get the broadcast start time first -- event times will be relative to this
      let variantPlaylist = await this.getVariantPlaylist(streamURL, streamURLToken)
      let broadcast_start_timestamp = await this.getBroadcastStart(variantPlaylist)

      if ( broadcast_start_timestamp ) {
        this.debuglog('getSkipMarkers broadcast start detected as ' + broadcast_start_timestamp)

        if (start_inning == '') {
          start_inning = 0
        }
        if (start_inning_half == '') {
          start_inning_half = 'top'
        }

        let cache_data = await this.getGamedayData(gamePk)

        // make sure we have play data
        if (cache_data && cache_data.liveData && cache_data.liveData.plays && cache_data.liveData.plays.allPlays) {

          // make sure start inning is valid
          if (start_inning > 0) {
            let last_play_index = cache_data.liveData.plays.allPlays.length - 1
            let final_inning = cache_data.liveData.plays.allPlays[last_play_index].about.inning
            if (start_inning >= final_inning) {
              if (start_inning > final_inning) {
                start_inning = final_inning
                let final_inning_half = json_source['liveData']['plays']['allPlays'][last_play_index]['about']['halfInning']
                if ((start_inning_half == 'bottom') && (final_inning_half == 'top')) {
                  start_inning_half = final_inning_half
                }
              }
            }
          }

          // keep track of inning, if skipping inning breaks only
          let previous_inning = 0
          let previous_inning_half = ''

          // calculate total skip time (for fun)
          let total_skip_time = 0

          // Loop through all plays
          for (var i=0; i < cache_data.liveData.plays.allPlays.length; i++) {

            // exit loop after found inning, if not skipping any play-defined breaks
            if ( ((skip_type == 0) || (skip_type == 4)) && (skip_markers.length == 1) ) {
              break
            }

            let current_inning = cache_data.liveData.plays.allPlays[i].about.inning
            let current_inning_half = cache_data.liveData.plays.allPlays[i].about.halfInning
            // make sure we're past our start inning
            if ((current_inning > start_inning) || ((current_inning == start_inning) && ((current_inning_half == start_inning_half) || (current_inning_half == 'bottom')))) {
              // loop through events within each play
              for (var j=0; j < cache_data.liveData.plays.allPlays[i].playEvents.length; j++) {
                let event_end_padding = action_end_padding
                // always exclude break types
                if (cache_data.liveData.plays.allPlays[i].playEvents[j].details && cache_data.liveData.plays.allPlays[i].playEvents[j].details.event && BREAK_TYPES.includes(cache_data.liveData.plays.allPlays[i].playEvents[j].details.event)) {
                  // if we're in the process of skipping inning breaks, treat the first break type we find as another inning break
                  if ((skip_type == 1) && (previous_inning > 0)) {
                    break_start = ((new Date(cache_data.liveData.plays.allPlays[i].playEvents[j].startTime) - broadcast_start_timestamp) / 1000) + event_end_padding
                    previous_inning = 0
                  }
                  continue
                } else {
                  if ( (j < (cache_data.liveData.plays.allPlays[i].playEvents.length - 1)) && (!cache_data.liveData.plays.allPlays[i].playEvents[j].details || !cache_data.liveData.plays.allPlays[i].playEvents[j].details.event || !ACTION_TYPES.some(v => cache_data.liveData.plays.allPlays[i].playEvents[j].details.event.includes(v))) ) {
                    event_end_padding = pitch_end_padding
                  }
                  let action_index
                  // skip type 0 (none, inning start), 1 (breaks), and 4 (commercials) will look at all plays with an endTime
                  if ( ((skip_type <= 1) || (skip_type == 4)) && cache_data.liveData.plays.allPlays[i].playEvents[j].endTime ) {
                    action_index = j
                  // skip type 2 (idle time) will look at all non-idle plays with an endTime
                  } else if ((skip_type == 2) && cache_data.liveData.plays.allPlays[i].playEvents[j].endTime && (!cache_data.liveData.plays.allPlays[i].playEvents[j].details || !cache_data.liveData.plays.allPlays[i].playEvents[j].details.description || !IDLE_TYPES.some(v => cache_data.liveData.plays.allPlays[i].playEvents[j].details.description.includes(v)))) {
                    action_index = j
                  } else if (skip_type == 3) {
                    // skip type 3 excludes non-action pitches (events that aren't last in the at-bat and don't fall under action types)
                    if ( event_end_padding == pitch_end_padding ) {
                      continue
                    } else {
                      // if the action is associated with another play or the event doesn't have an end time, use the previous event instead
                      if (cache_data.liveData.plays.allPlays[i].playEvents[j].actionPlayId || ((cache_data.liveData.plays.allPlays[i].playEvents[j].endTime === 'undefined') && (j > 0))) {
                        action_index = j - 1
                      } else {
                        action_index = j
                      }
                    }
                  }
                  if (typeof action_index === 'undefined') {
                    continue
                  } else {
                    let break_end = ((new Date(cache_data.liveData.plays.allPlays[i].playEvents[action_index].startTime) - broadcast_start_timestamp) / 1000) + event_start_padding

                    // attempt to fix erroneous timestamps, like NYY-SEA 2022-08-09, bottom 11
                    if ( break_end < break_start ) {
                      this.debuglog('getSkipMarkers adjusting break start')
                      break_start = break_end - 10

                      let prev_break = skip_markers.length-1
                      if ( (prev_break > 0) && (break_start < skip_markers[prev_break].break_end) && (skip_markers[prev_break].break_start < (skip_markers[prev_break].break_end - 40)) ) {
                        this.debuglog('getSkipMarkers adjusting previous break end')
                        skip_markers[prev_break].break_end = skip_markers[prev_break].break_start + 30
                      }
                    }

                    // if the break duration should be greater than than our specified minimum
                    // and if skip type is not 1 (inning breaks) or the inning has changed
                    // then we'll add the skip marker
                    // otherwise we'll ignore it and move on to the next one
                    if ( ((break_end - break_start) >= MINIMUM_BREAK_DURATION) && ((skip_type != 1) || (current_inning != previous_inning) || (current_inning_half != previous_inning_half)) ) {
                      if ( break_start > 0 ) break_start += skip_adjust
                      break_end += skip_adjust
                      skip_markers.push({'break_start': break_start, 'break_end': break_end})
                      total_skip_time += break_end - break_start
                      previous_inning = current_inning
                      previous_inning_half = current_inning_half
                      // exit loop after found inning, if not skipping play-defined breaks
                      if ( (skip_type == 0) || (skip_type == 4)) {
                        break
                      }
                    }
                    break_start = ((new Date(cache_data.liveData.plays.allPlays[i].playEvents[action_index].endTime) - broadcast_start_timestamp) / 1000) + event_end_padding
                    // add extra padding for overturned review plays
                    if ( cache_data.liveData.plays.allPlays[i].reviewDetails ) {
                      let isOverturned = cache_data.liveData.plays.allPlays[i].reviewDetails.isOverturned
                      if ( (isOverturned == false) && cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews && (cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews.length > 0) ) {
                        for (var k=0; k < cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews.length; k++) {
                          isOverturned = cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews[k].isOverturned
                          if ( isOverturned == true ) {
                            break
                          }
                        }
                      }
                      if (isOverturned) {
                        break_start += 40
                      }
                    }
                  }
                }
              }
            }
          }
          
          // if skipping commercials, look at the variant playlist to detect insertions
          if ( skip_type == 4 ) {
            this.debuglog('detecting commercial breaks')
            let body = variantPlaylist
            let break_active = false
            let break_end = 0
            let time_counter = 0
            if ( skip_markers.length > 0 ) {
              break_end = skip_markers[skip_markers.length-1].break_end
            }
            for (var i=0; i<body.length; i++) {
              if ( body[i].startsWith('#EXTINF:') ) {
                time_counter += parseFloat(body[i].substring(8, body[i].length-1))
              }
              if ( (time_counter > break_end) && (break_active == false) && body[i].startsWith('#EXT-OATCLS-SCTE35:') ) {
                break_active = true
                break_start = time_counter
              } else if ( (break_active == true) && body[i].startsWith('#EXT-X-CUE-IN') ) {
                break_end = time_counter
                break_active = false
                skip_markers.push({'break_start': break_start, 'break_end': break_end})
                total_skip_time += break_end - break_start
              }
            }
          }

          this.debuglog('getSkipMarkers found ' + new Date(total_skip_time * 1000).toISOString().substr(11, 8) + ' total skip time')
        }
      } else {
        this.log('getSkipMarkers failed to find broadcast start time')
      }

      this.debuglog('getSkipMarkers skip markers: ' + JSON.stringify(skip_markers))
      this.temp_cache[gamePk].skip_markers = skip_markers

      return true
    } catch(e) {
      this.log('getSkipMarkers error : ' + e.message)
    }
  }

  // Get Big Inning schedule, if available
  async getBigInningSchedule(dateString = false) {
    try {
      this.debuglog('getBigInningSchedule')

      // temporarily disable Big Inning schedule checking until a new source URL is available
      /*this.cache.bigInningSchedule = {}
      return*/

      let currentDate = new Date()
      if ( !this.cache || !this.cache.bigInningScheduleCacheExpiry || (currentDate > new Date(this.cache.bigInningScheduleCacheExpiry)) ) {
        if ( !this.cache.bigInningSchedule ) this.cache.bigInningSchedule = {}
        let reqObj = {
          url: 'https://api.fubo.tv/gg/series/123881219/live-programs?limit=14&languages=en&countrySlugs=USA',
          headers: {
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
            'accept-language': 'en-US,en;q=0.9',
            'cache-control': 'no-cache',
            'dnt': '1',
            'pragma': 'no-cache',
            'sec-ch-ua': '"Not(A:Brand";v="99", "Google Chrome";v="133", "Chromium";v="133"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"macOS"',
            'sec-fetch-dest': 'document',
            'sec-fetch-mode': 'navigate',
            'sec-fetch-site': 'none',
            'sec-fetch-user': '?1',
            'sec-gpc': '1',
            'upgrade-insecure-requests': '1',
            'user-agent': USER_AGENT
          },
          json: true,
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response ) {
          this.debuglog(JSON.stringify(response))
          
          if ( response.data ) {
            for (var i=0; i < response.data.length; i++) {
              if ( response.data[i].airings && (response.data[i].airings.length > 0) && response.data[i].airings[0] && response.data[i].airings[0].accessRightsV2 && response.data[i].airings[0].accessRightsV2.live ) {
                let est_date = new Date(response.data[i].airings[0].accessRightsV2.live.startTime).toLocaleString("en-US", {timeZone: 'America/New_York'})
                let date_array = est_date.split(',')[0].split('/')
                let this_datestring = date_array[2] + '-' + date_array[0].padStart(2, '0') + '-' + date_array[1].padStart(2, '0')
                this.cache.bigInningSchedule[this_datestring] = {
                  start: response.data[i].airings[0].accessRightsV2.live.startTime, 
                  end: response.data[i].airings[0].accessRightsV2.live.endTime
                }
              }
            }
          }
          this.debuglog(JSON.stringify(this.cache.bigInningSchedule))

          // Default cache period is 1 day from now
          let oneDayFromNow = new Date()
          oneDayFromNow.setDate(oneDayFromNow.getDate()+1)
          let cacheExpiry = oneDayFromNow
          this.cache.bigInningScheduleCacheExpiry = cacheExpiry

          this.save_cache_data()
        } else {
          this.log('error : invalid response from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached big inning schedule')
      }
      // If we requested the schedule for a specific date, and it exists, return it
      if ( dateString ) {
        if ( this.cache.bigInningSchedule && this.cache.bigInningSchedule[dateString] ) {
          return this.cache.bigInningSchedule[dateString]
        }
      }
    } catch(e) {
      this.log('getBigInningSchedule error : ' + e.message)
    }
  }

  // Generate generic Big Inning schedule for specified date
  // times in UTC (and DST) according to https://www.mlb.com/live-stream-games/help-center/subscription-access-big-inning
  async generateBigInningSchedule(dateString) {
    try {
      this.debuglog('generateBigInningSchedule')

      let utc_start_string = '01:00'
      let utc_end_string = '03:30'
      let add_date = 1
      // Different Sunday schedule
      let weekday_index = new Date(dateString + ' 00:00:00').getDay()
      if ( weekday_index == 0 ) {
        utc_start_string = '19:00'
        utc_end_string = '21:30'
        add_date = 0
      }
      let d = new Date(dateString + 'T' + utc_start_string + ':00.000+00:00')
      d.setDate(d.getDate()+add_date)
      let start = d
      d = new Date(dateString + 'T' + utc_end_string + ':00.000+00:00')
      d.setDate(d.getDate()+add_date)
      let end = d

      return {start: start, end: end}
    } catch(e) {
      this.log('generateBigInningSchedule error : ' + e.message)
    }
  }

  // Get event data
  async getEventData() {
    try {
      this.debuglog('getEventData')

      let cache_data
      let cache_name = 'events'
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.eventURLCacheExpiry || (currentDate > new Date(this.cache.eventURLCacheExpiry)) ) {
        let reqObj = {
          url: 'https://dapi.cms.mlbinfra.com/v2/content/en-us/sel-mlbtv-featured-svod-video-list',
          //url: 'https://dapi.mlbinfra.com/v2/content/en-us/vsmcontents/mlb-tv-welcome-center-big-inning-show',
          headers: {
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com',
            'Content-Type': 'application/json'
          }
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 5 minutes from now
          let fiveMinutesFromNow = new Date()
          fiveMinutesFromNow.setMinutes(fiveMinutesFromNow.getMinutes()+5)
          let cacheExpiry = fiveMinutesFromNow

          // finally save the setting
          this.cache.eventURLCacheExpiry = cacheExpiry
          this.save_cache_data()
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
          return
        }
      } else {
        this.debuglog('using cached event data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getEventData error : ' + e.message)
    }
  }

  // Get event URL, used to determine the stream URL if available
  async getEventURL(eventName) {
    try {
      this.debuglog('getEventURL')

      let cache_data = await this.getEventData()

      let eventList
      if ( cache_data && cache_data.items ) {
        eventList = cache_data.items
      } else if ( cache_data && cache_data.references && cache_data.references.video ) {
        eventList = cache_data.references.video
      }

      if ( eventList ) {
        for (var i=0; i<eventList.length; i++) {
          if ( eventList[i].fields && eventList[i].fields.blurb && eventList[i].fields.url ) {
            if ( !eventList[i].fields.blurb.includes('LIVE') ) {
              break
            } else {
              if ( eventList[i].title ) {
                if ( (eventName == 'BIGINNING') && eventList[i].title.startsWith('LIVE') && eventList[i].title.includes('Big Inning') ) {
                  this.debuglog('active big inning url')
                  return eventList[i].fields.url
                } else {
                  let cleaned_title = eventList[i].title.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase()
                  if ( cleaned_title.endsWith(' VS. ' + eventName) || cleaned_title.includes(eventName + ' VS. ') ) {
                    this.debuglog('active ' + eventName + ' url')
                    return eventList[i].fields.url
                  }
                }
              }
            }
          }
        }
      }
    } catch(e) {
      this.log('getEventURL error : ' + e.message)
    }
  }

  // Get linear channel stream URL
  async getLinearStreamURL(network) {
    try {
      this.debuglog('getLinearStreamURL')      
      
      let reqObj = {
        url: GRAPHQL_URL,
        simple: false,
        headers: {
          'accept': 'application/json, text/plain, */*',
  		  'accept-encoding': 'gzip, deflate, br',
  		  'accept-language': 'en-US,en;q=0.5',
  		  'authorization': 'Bearer ' + await this.getLoginToken() || this.halt('missing loginToken'),
  		  'connection': 'keep-alive',
  		  'content-type': 'application/json',
  		  'x-client-name': 'WEB',
  		  'x-client-version': '7.8.1',
          'origin': 'https://www.mlb.com',
          'referer': 'https://www.mlb.com/',
          'user-agent': USER_AGENT
        },
        body: {
          'operationName': 'contentCollections',
          'query': 'query contentCollections(\n        $categories: [ContentGroupCategory!]\n        $includeRestricted: Boolean = false\n        $includeSpoilers: Boolean = false\n        $limit: Int = 10,\n        $skip: Int = 0\n    ) {\n        contentCollections(\n            categories: $categories\n            includeRestricted: $includeRestricted\n            includeSpoilers: $includeSpoilers\n            limit: $limit\n            skip: $skip\n        ) {\n            title\n            category\n            contents {\n                assetTrackingKey\n                contentDate\n                contentId\n                contentRestrictions\n                description\n                duration\n                language\n                mediaId\n                officialDate\n                title\n                mediaState {\n                    state\n                    mediaType\n                }\n                thumbnails {\n                    thumbnailType\n                    templateUrl\n                    thumbnailUrl\n                }\n            }\n        }\n    }',
          'variables': {
            'categories': network,
            'limit': '25'
          }
        },
        json: true,
        gzip: true
      }
      var response = await this.httpPost(reqObj)
      if ( response ) {
        this.debuglog('getLinearStreamURL response : ' + JSON.stringify(response))
        if ( response.data && response.data.contentCollections && (response.data.contentCollections.length > 0) && response.data.contentCollections[0].contents ) {
          for (var i=0; i<response.data.contentCollections[0].contents.length; i++) {
            try {
              let streamInfo = await this.getStreamURL(response.data.contentCollections[0].contents[i].mediaId)
              if ( streamInfo.rawStreamURL ) {
                return streamInfo.rawStreamURL
              }
            } catch(e) {
              this.debuglog('getLinearStreamURL getStreamURL error : ' + e.message)
            }
          }
          this.log('getLinearStreamURL stream url not found')
        }
      }
    } catch(e) {
      this.log('getLinearStreamURL error : ' + e.message)
    }
  }

  // Get Recap Rundown data
  async getRecapRundownData(dateString) {
    try {
      this.debuglog('getRecapRundownData for ' + dateString)

      let cache_data
      let cache_name = 'recaprundown' + dateString
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.recapRundown || !this.cache.recapRundown[dateString] || !this.cache.recapRundown[dateString].recapRundownCacheExpiry || (currentDate > new Date(this.cache.recapRundown[dateString].recapRundownCacheExpiry)) ) {
        let reqObj = {
          url: 'https://dapi.mlbinfra.com/v2/content/en-us/videos/mlb-tv-recap-rundown-' + dateString,
          headers: {
            'Authorization': 'Bearer ' + await this.getLoginToken() || this.halt('missing loginToken'),
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com',
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 5 minutes from now
          let fiveMinutesFromNow = new Date()
          fiveMinutesFromNow.setMinutes(fiveMinutesFromNow.getMinutes()+5)
          let cacheExpiry = fiveMinutesFromNow

          // finally save the setting
          this.setRecapRundownCacheExpiry(dateString, cacheExpiry)
          this.save_cache_data()
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
          return
        }
      } else {
        this.debuglog('using cached Recap Rundown data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getRecapRundownData error : ' + e.message)
    }
  }

  // Get Recap Rundown URL, used to determine the stream URL if available
  async getRecapRundownURL(dateString) {
    try {
      this.debuglog('getRecapRundownURL for ' + dateString)

      let cache_data = await this.getRecapRundownData(dateString)

      if ( cache_data && cache_data.fields && cache_data.fields.playbackScenarios && cache_data.fields.playbackScenarios && (cache_data.fields.playbackScenarios.length > 0) ) {
        this.debuglog('getRecapRundownURL found ' + cache_data.fields.playbackScenarios.length + ' playbackScenarios')
        for (var i=0; i<cache_data.fields.playbackScenarios.length; i++) {
          if ( cache_data.fields.playbackScenarios[i].playback && (cache_data.fields.playbackScenarios[i].playback == 'hlsCloud') && cache_data.fields.playbackScenarios[i].location ) {
            this.debuglog('found Recap Rundown url at ' + cache_data.fields.playbackScenarios[i].location)
            return cache_data.fields.playbackScenarios[i].location
          }
        }
      }
    } catch(e) {
      this.log('getRecapRundownURL error : ' + e.message)
    }
  }

  // Get event stream URL
  async getEventStreamURL(eventName, gamePk=false) {
    if ( gamePk ) {
      eventName = gamePk
    }
    this.debuglog('getEventStreamURL for ' + eventName)
    if ( this.cache.media && this.cache.media[eventName] && this.cache.media[eventName].streamURL && this.cache.media[eventName].streamURLExpiry && (Date.parse(this.cache.media[eventName].streamURLExpiry) > new Date()) ) {
      this.log('using cached eventStreamURL')
      return this.cache.media[eventName].streamURL
    } else {
      var playbackURL
      if ( gamePk ) {
        playbackURL = 'https://dai.tv.milb.com/api/v2/playback-info/games/' + gamePk + '/contents/14862/products/milb-carousel'
      } else if ( eventName ) {
        if ( eventName.startsWith('RECAPRUNDOWN') ) {
          let dateString = eventName.substring(12)
          this.debuglog('getEventStreamURL RecapRundown for ' + dateString)
          playbackURL = await this.getRecapRundownURL(dateString)
        } else if ( eventName.toUpperCase() == 'MLBN' ) {
          playbackURL = 'https://falcon.mlbinfra.com/api/v1/linear/mlbn'
        } else if ( eventName.toUpperCase() == 'SNLA' ) {
          playbackURL = await this.getLinearStreamURL('SNLA_LIVE')
          return playbackURL
        } else if ( eventName.toUpperCase() == 'SNY' ) {
          playbackURL = await this.getLinearStreamURL('SNY_LIVE')
          return playbackURL
        } else {
          playbackURL = await this.getEventURL(eventName)
        }
      }
      if ( !playbackURL ) {
        this.debuglog('no active event url')
      } else {
        this.debuglog('getEventStreamURL from ' + playbackURL)
        let reqObj = {
          url: playbackURL,
          simple: false,
          headers: {
            'Authorization': 'Bearer ' + await this.getLoginToken() || this.halt('missing loginToken'),
            'User-agent': USER_AGENT,
            'Accept': '*/*',
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com/',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj)
        if ( response && this.isValidJson(response) ) {
          this.debuglog('getEventStreamURL response : ' + response)
          let obj = JSON.parse(response)
          if ( obj.success && (obj.success == true) ) {
            this.debuglog('found eventStreamURL : ' + obj.data[0].value)
            this.cacheStreamURL(eventName, obj.data[0].value)
            return obj.data[0].value
          } else {
            this.log('getEventStreamURL error')
            this.log(obj.errorCode)
            this.log(obj.message)
            return
          }
        } else if ( response.startsWith('#EXTM3U') ) {
          this.debuglog('getEventStreamURL is eventURL : ' + playbackURL)
          this.cacheStreamURL(eventName, playbackURL)
          return playbackURL
        }
      }
    }
  }

  // get blackouts data for a day
  async getBlackoutsData(dateString, endDate) {
    try {
      let cache_data
      let cache_name = 'b' + dateString
      let data_url = 'https://mastapi.mobile.mlbinfra.com/api/epg/v3/search?exp=MLB&date=' + dateString
      let utcHours = 10
      if ( dateString == 'guide' ) {
        cache_name = 'bweek'
        this.debuglog('getBlackoutsData for week')
        let startDate = this.liveDate(utcHours)
        let endDate = new Date(startDate)
        endDate.setDate(endDate.getDate()+20)
        endDate = endDate.toISOString().substring(0,10)
        data_url = 'https://mastapi.mobile.mlbinfra.com/api/epg/v3/search?exp=MLB&startDate=' + startDate + '&endDate=' + endDate
      } else {
        this.debuglog('getBlackoutsData for ' + dateString)
      }
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.blackouts || !this.cache.blackouts[cache_name] || !this.cache.blackouts[cache_name].blackoutsCacheExpiry || (currentDate > new Date(this.cache.blackouts[cache_name].blackoutsCacheExpiry)) ) {
        let reqObj = {
          url: data_url,
          headers: {
            'Accept': '*/*',
            'Accept-Language': 'en-US,en;q=0.9',
            'Content-Type': 'application/json',
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com/',
            'User-Agent': USER_AGENT
          }
        }
        if ( (this.credentials.account_username.length > 0) && (this.credentials.account_password.length > 0) ) {
          let access_token = await this.getLoginToken()
          let okta_id = await this.getOktaId()
          if ( access_token && okta_id ) {
            reqObj.headers['authorization'] = 'Bearer ' + access_token
            reqObj.headers['x-okta-id'] = okta_id
          }
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          //this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 day from now
          let today = this.liveDate()
          let tomorrowDate = new Date(today)
          tomorrowDate.setDate(tomorrowDate.getDate()+1)
          tomorrowDate.setHours(tomorrowDate.getHours()+utcHours)
          let cacheExpiry = tomorrowDate

          // finally save the setting
          this.setBlackoutsCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached date data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getBlackoutsData error : ' + e.message)
    }
  }

  // get all blackout games for a date
  async get_blackout_games(gameDate='guide', calculate_expiries=false) {
    this.debuglog('get_blackout_games')
    let blackouts = {}

    let cache_data
    cache_data = await this.getBlackoutsData(gameDate)
    
    let feedTypes = ['videoFeeds', 'audioFeeds']

    if ( cache_data && cache_data.results && (cache_data.results.length > 0) ) {
      for (var i = 0; i < cache_data.results.length; i++) {
        let game = cache_data.results[i]
        let game_pk = game.gamePk
        this.debuglog('get_blackout_games checking game ' + game_pk)
        let blackout_type = ''
        if ( game.blackedOutVideo || !game.entitledVideo || !game.entitledAudio ) {
          if ( !game.entitledVideo || !game.entitledAudio ) {
            this.debuglog('get_blackout_games found non-entitled game ' + game_pk)
            blackout_type = 'Not entitled'
          } else {
            this.debuglog('get_blackout_games found blackout game ' + game_pk)
          }
          blackouts[game_pk] = { blackout_type: blackout_type }       
        }
        
        let blackout_feeds = []
        for (var j = 0; j < feedTypes.length; j++) {
          let feedType = feedTypes[j]
          for (var k = 0; k < game[feedType].length; k++) {
            let feed = game[feedType][k]
            if ( !feed.entitled || ((j == 0) && feed.blackedOut) ) {
              blackout_feeds.push(feed['mediaId'])
              if ( !feed['entitled'] ) {
                this.debuglog('get_blackout_games found non-entitled feed ' + feed.callLetters)
                blackout_type = 'Not entitled'
              } else {
                this.debuglog('get_blackout_games found blackout feed ' + feed.callLetters)
              }
            }
          }
        }
        if ( blackout_feeds.length > 0 ) {
          if ( !blackouts[game_pk] ) {
            blackouts[game_pk] = { blackout_type: blackout_type }
          }
          blackouts[game_pk].blackout_feeds = blackout_feeds   
        }
        
        // add blackout expiry, if requested
        if ( blackouts[game_pk] && (blackouts[game_pk].blackout_type != 'Not entitled') && calculate_expiries && await this.check_game_time(game.gameData) ) {
          this.debuglog('get_blackout_games calculating blackout expiry')
          let date_cache_data = await this.getDayData(gameDate)
          if ( date_cache_data.dates && date_cache_data.dates[0] && date_cache_data.dates[0].games && (date_cache_data.dates[0].games.length > 0) ) {
            for (var j = 0; j < date_cache_data.dates[0].games.length; j++) {
              if ( game_pk == date_cache_data.dates[0].games[j].gamePk ) {
                this.debuglog('get_blackout_games found matching game')
                let blackoutExpiry = await this.get_blackout_expiry(date_cache_data.dates[0].games[j])
                this.debuglog('get_blackout_games calculated blackout expiry as ' + blackoutExpiry)
                blackouts[game_pk].blackoutExpiry = blackoutExpiry
                break
              }
            }
          }
        }
      }
    }

    return blackouts
  }

  // get all pre- and post-game for a date
  async get_pre_post_shows(gameDate='guide') {
    this.debuglog('get_pre_post_shows')
    let pregame_shows = {}
    let postgame_shows = {}

    let cache_data
    cache_data = await this.getBlackoutsData(gameDate)
    
    let teamTypes = ['home', 'away']
    let showTypes = ['preGame', 'postGame']

    if ( cache_data && cache_data.results && (cache_data.results.length > 0) ) {
      for (var i = 0; i < cache_data.results.length; i++) {
        let game = cache_data.results[i]
        if ( game.prePostShows ) {
          for (var j = 0; j < teamTypes.length; j++) {
            let teamType = teamTypes[j]
            if ( game.prePostShows[teamType] ) {
              for (var k = 0; k < showTypes.length; k++) {
                let showType = showTypes[k]
                if ( game.prePostShows[teamType][showType] && game.prePostShows[teamType][showType].hasShow ) {
                  this.debuglog('get_pre_post_shows found ' + teamType + ' ' + showType + ' ' + game.prePostShows[teamType].contentId)
                  if ( game.prePostShows[teamType][showType].startTime ) {
                    pregame_shows[game.prePostShows[teamType].contentId] = { team: teamType, start: game.prePostShows[teamType][showType].startTime }
                  } else {
                    postgame_shows[game.prePostShows[teamType].contentId] = { team: teamType }
                  }
                }
              }
            }
          }
        }
      }
    }

    return { pregame_shows, postgame_shows }
  }

  async resetGameChanger(id, includeTeams, excludeTeams) {
    let today = this.liveDate()
    if ( !this.temp_cache.gamechanger || !this.temp_cache.gamechanger.date || (this.temp_cache.gamechanger.date != today) ) {
      this.log('updating gamechanger for ' + today)
      let cache_data = await this.getDayData(today)
      let blackouts = {}
      let start
      let end
      if ( cache_data.dates && cache_data.dates[0] && cache_data.dates[0].games && (cache_data.dates[0].games.length > 0) ) {
        blackouts = await this.get_blackout_games(today)
        this.debuglog('Game changer blackouts ' + JSON.stringify(blackouts))

        let gameIndexes = await this.get_first_and_last_games(cache_data.dates[0].games, blackouts)
        if ( (typeof gameIndexes.firstGameIndex !== 'undefined') && (typeof gameIndexes.lastGameIndex !== 'undefined') ) {
          start = new Date(cache_data.dates[0].games[gameIndexes.firstGameIndex].gameDate)
          end = new Date(cache_data.dates[0].games[gameIndexes.lastGameIndex].gameDate)
          end.setHours(end.getHours()+4)
        }
      }
      this.debuglog('Game changer start ' + start)
      this.debuglog('Game changer end ' + end)
      this.temp_cache.gamechanger = {
        date: today,
        start: start,
        end: end,
        //dateString: today.substring(0,4) + '/month_' + today.substring(5,7) + '/day_' + today.substring(8,10),
        blackouts: blackouts,
        gamechangerCacheExpiry: null,
        cache_data: null
      }
    }

    this.temp_cache.gamechanger[id] = {
      lastAccess: null,
      segments: [],
      sequence: 0,
      discontinuitySequence: 0,
      playlist: {},
      includeTeams: includeTeams,
      excludeTeams: excludeTeams,
      streamURL: null,
      games: [],
      players: [],
      inning_states: [],
      break_expiries: {},
      gamePk: null,
      streamFinderData: {},
      stream_finder_settings: {},
      cur_game_pk: null,
      cur_game_high_LI_flag: 'N',
      cur_game_high_LI: -3,
      cur_pitchers: {},
      cur_batter: null
    }
  }

  // get Stream Finder data
  async getStreamFinderData(id) {
    try {
      var game_changer_title = 'Game changer ' + id
      this.debuglog('getStreamFinderData for ' + game_changer_title)
      let data_url = 'https://www.baseball-reference.com/stream-finder.shtml'
      let reqObj = {
        url: data_url,
        headers: {
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
          'Referer': 'https://www.baseball-reference.com/',
          'User-Agent': USER_AGENT
        }
      }
      var response = await this.httpGet(reqObj, false)
      if ( response ) {
        //this.debuglog(response)
        this.temp_cache.gamechanger[id].streamFinderData.team_data = JSON.parse(response.match(/var team_data\s*=\s*([{][^;]+);/)[1])
        this.temp_cache.gamechanger[id].streamFinderData.posPlayers = JSON.parse(response.match(/var posPlayers\s*=\s*([{][^}]+[}])/)[1])
        this.temp_cache.gamechanger[id].streamFinderData.games_CLI = JSON.parse(response.match(/var games_CLI\s+=\s+([{][^}]+[}])/)[1])
        this.temp_cache.gamechanger[id].streamFinderData.LI_table = JSON.parse(response.match(/var LI\s+=\s+([{][^;]+);/)[1])
      } else {
        this.log('error : invalid response from url ' + reqObj.url)
      }
    } catch(e) {
      this.log('getStreamFinderData error : ' + e.message)
    }
  }
  
  is_runner(base) {
    if (!base) {
      return '0'
    } else {
      return '1'
    }
  }
            
  basesit(first, second, third) {
    return BASESIT_TABLE[this.is_runner(first)][this.is_runner(second)][this.is_runner(third)]
  }
  
  getCurrentGame(game, team_data) {
    return team_data[game.away_team_id.toString()].teamName + ' @ ' + team_data[game.home_team_id.toString()].teamName
  }
  
  setCurrentGame(cur_game_pk, game, team_data, game_changer_title, priority) {
    if ( cur_game_pk != game.game_pk ) {
      this.debuglog(game_changer_title + ' set current game to ' + this.getCurrentGame(game, team_data) + ' due to ' + priority.type + ' ' + priority.data)
      return {'game_pk': game.game_pk, 'cur_batter': game.batter}
    }
  }
  
  sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms)
    })
  }

  // get best active live game by leverage
  async getStreamFinderGame(id) {
    var game_changer_title = 'Game changer Stream Finder ' + id + ' '

    try {
      let cache_data
      let cache_name = 'gamechanger'
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !this.temp_cache.gamechanger.cache_data || !this.temp_cache.gamechangerCacheExpiry || (currentDate > new Date(this.temp_cache.gamechangerCacheExpiry)) ) {
        this.debuglog(game_changer_title + 'fetching new gamechanger data')
        let cacheExpiry = new Date()
        cacheExpiry.setSeconds(cacheExpiry.getSeconds()+3)
        this.temp_cache.gamechangerCacheExpiry = cacheExpiry
        let reqObj = {
          url: 'https://statsapi.mlb.com/api/v1/schedule?sportId=1&startDate=' + this.temp_cache.gamechanger.date + '&endDate=' + this.temp_cache.gamechanger.date + '&hydrate=broadcasts(all),linescore,team,flags,gameInfo',
          headers: {
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com/',
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(game_changer_title + 'valid json response')
          //this.debuglog(response)
          this.temp_cache.gamechanger.cache_data = JSON.parse(response)
        } else {
          this.log(game_changer_title + 'error : invalid json from url ' + reqObj.url)
          return
        }
      } else {
        this.debuglog(game_changer_title + 'using cached gamechanger data')
      }
      cache_data = this.temp_cache.gamechanger.cache_data

      if ( cache_data ) {
        if ( cache_data.dates && cache_data.dates[0] && cache_data.dates[0].games && (cache_data.dates[0].games.length > 0) ) {
          let team_data = this.temp_cache.gamechanger[id].streamFinderData.team_data
        
          var games = []
          
          for (var i=0; i<cache_data.dates[0].games.length; i++) {
            let game = cache_data.dates[0].games[i]
            
            let gamePk = game.gamePk.toString()            
            let broadcast_count = await this.count_broadcasts(game.broadcasts, 'MLBTV')
            if ( this.temp_cache.gamechanger.blackouts[gamePk] && this.temp_cache.gamechanger.blackouts[gamePk].blackout_feeds && (this.temp_cache.gamechanger.blackouts[gamePk].blackout_feeds.length == broadcast_count) ) {
              continue
            }
            
            if (!game.linescore) {
              continue
            }
            
            let currentInning = 1
            if (game.linescore.currentInning) {
              currentInning = game.linescore.currentInning
            }
            let inningState = 'Top'
            if (game.linescore.inningState) {
              inningState = game.linescore.inningState
            }
            let balls = 0
            if (game.linescore.balls) {
              balls = game.linescore.balls
            }
            let strikes = 0
            if (game.linescore.strikes) {
              strikes = game.linescore.strikes
            }
            let outs = 0
            if (game.linescore.outs) {
              outs = game.linescore.outs
            }
            let status = 'scheduled'
            if ( game.status && game.status.detailedState && (game.status.detailedState == 'In Progress') ) {
              status = 'active'
            }
            let half = 1
            if ( game.linescore.inningHalf && (game.linescore.inningHalf == 'Bottom') ) {
              half = 2
            }
            let away_runs = 0
            let away_hits = 0
            if (game.linescore.teams && game.linescore.teams.away) {
              if (game.linescore.teams.away.runs) {
                away_runs = game.linescore.teams.away.runs
              }
              if (game.linescore.teams.away.hits) {
                away_hits = game.linescore.teams.away.hits
              }
            }
            let home_runs = 0
            let home_hits = 0
            if (game.linescore.teams && game.linescore.teams.home) {
              if (game.linescore.teams.home.runs) {
                home_runs = game.linescore.teams.home.runs
              }
              if (game.linescore.teams.home.hits) {
                home_hits = game.linescore.teams.home.hits
              }
            }
            let pitcher = false
            if (game.linescore.defense && game.linescore.defense.pitcher && game.linescore.defense.pitcher.id) {
              pitcher = game.linescore.defense.pitcher.id
            }
            let batter = false
            let onDeck = false
            let first = false
            let second = false
            let third = false
            if (game.linescore.offense) {
              if (game.linescore.offense.batter && game.linescore.offense.batter.id) {
                batter = game.linescore.offense.batter.id
              }
              if (game.linescore.offense.onDeck && game.linescore.offense.onDeck.id) {
                onDeck = game.linescore.offense.onDeck.id
              }
              if (game.linescore.offense.first && game.linescore.offense.first.id) {
                first = game.linescore.offense.first.id
              }
              if (game.linescore.offense.second && game.linescore.offense.second.id) {
                second = game.linescore.offense.second.id
              }
              if (game.linescore.offense.third && game.linescore.offense.third.id) {
                third = game.linescore.offense.third.id
              }
            }
            
            let basesit = this.basesit(first, second, third)
            let innbaseout = currentInning.toString() + half.toString() + basesit.toString() + outs.toString()
            
            games.push({
              'gamePk': game.gamePk,
              'codedGameState': game.status.codedGameState,
              'status': status,
              'scheduledInnings': game.scheduledInnings,
              'teams': {
                'away': {
                  'team': {
                    'id': game.teams.away.team.id
                  }
                },
                'home': {
                  'team': {
                    'id': game.teams.home.team.id
                  }
                },
              },
              'linescore': {
                'InnBaseOut': innbaseout,
                'RunDiff': Math.abs(away_runs - home_runs),
                'BaseSit': basesit,
                'balls': balls,
                'strikes': strikes,
                'outs': outs,
                'currentInning': currentInning,
                'inningState': inningState,
                'half': half,
                'teams': {
                  'away': {
                    'runs': home_runs,
                    'hits': home_hits
                  },
                  'home': {
                    'runs': home_runs,
                    'hits': home_hits
                  }
                },
                'defense': {
                  'pitcher': {
                    'id': pitcher
                  }
                },
                'offense': {
                  'onDeck': {
                    'id': onDeck
                  },
                  'third': {
                    'id': third
                  },
                  'second': {
                    'id': second
                  },
                  'first': {
                    'id': first
                  },
                  'batter': {
                    'id': batter
                  }
                }
              }
            })
          }
          
          let active_games = []
          let same_batter = 'N'
          
          let now = new Date()
          
          for (var i=0; i<games.length; i++) {
            let game = games[i]
            
            let run1 = false
            let run2 = false
            let run3 = false
            
            let gamePk = game.gamePk.toString()
            
            if ( !team_data[game.teams.away.team.id.toString()] || !team_data[game.teams.home.team.id.toString()] ) {
              continue
            }
            
            if ( game.linescore.outs == 3 ) {
              continue
            }
            
            if ( game.linescore.inningState && !['Top', 'Bottom'].includes(game.linescore.inningState) ) {
              continue
            }
            
            if ( !game.status || (game.status != 'active') ) {
              continue
            }
            
            if ( this.stream_finder_settings.ignore && (this.stream_finder_settings.ignore.length > 0) ) {
              let ignore = false
              for (var j=0; j<this.stream_finder_settings.ignore.length; j++) {
                let ignore_team = this.stream_finder_settings.ignore[j]
                if ( (ignore_team == game.teams.away.team.id.toString()) || (ignore_team == game.teams.home.team.id.toString()) ) {
                  ignore = true
                  break
                }
              }
              if ( ignore ) {
                continue
              }
            }
            
            if ( this.temp_cache.gamechanger[id].break_expiries[gamePk] ) {
              if ( this.temp_cache.gamechanger[id].break_expiries[gamePk] > now ) {
                this.debuglog(game_changer_title + ' pitching change in progress in game ' + gamePk)
                continue
              } else {
                this.debuglog(game_changer_title + ' pitching change complete in game ' + gamePk)
                this.removeBreakExpiry(id, gamePk)
              }
            }
            
            let pitching_team_id
            if ( game.linescore.half == 1 ) {
              pitching_team_id = game.teams.home.team.id.toString()
            }
            if ( game.linescore.half == 2 ) {
              pitching_team_id = game.teams.away.team.id.toString()
            }
            
            if ( pitching_team_id ) {
              if ( !this.temp_cache.gamechanger[id].cur_pitchers[gamePk] ) {
                this.temp_cache.gamechanger[id].cur_pitchers[gamePk] = {}
              }
              if ( !this.temp_cache.gamechanger[id].cur_pitchers[gamePk][pitching_team_id] ) {
                this.temp_cache.gamechanger[id].cur_pitchers[gamePk][pitching_team_id] = game.linescore.defense.pitcher.id
              } else {
                if ( game.linescore.defense.pitcher.id != this.temp_cache.gamechanger[id].cur_pitchers[gamePk][pitching_team_id] ) {
                  this.debuglog(game_changer_title + ' pitching change begun in game ' + gamePk)
                  this.setBreakExpiry(id, gamePk)
                  this.temp_cache.gamechanger[id].cur_pitchers[gamePk][pitching_team_id] = game.linescore.defense.pitcher.id
                  continue
                }
              }
            }
            
            let play_LI = 0.0
            try {
              play_LI = parseFloat(this.temp_cache.gamechanger[id].streamFinderData.LI_table[game.linescore.InnBaseOut.toString()][game.linescore.RunDiff.toString()])
            } catch(e) {
              // do nothing
            }
            
            let LI = play_LI
            let home_team = game.teams.home.team.id.toString()
            if ( this.stream_finder_settings.include_CLI && (this.stream_finder_settings.include_CLI == 'Y') && games_CLI[home_team] && (games_CLI[home_team] != '') ) {
              let CLI = parseFloat(games_CLI[home_team])
              LI = play_LI * CLI
            }
            
            // Baserunners
            if ( game.linescore.BaseSit > 1 ) {
              if ( game.linescore.offense.first ) {
                run1 = game.linescore.offense.first.id
              }
              if ( game.linescore.offense.second ) {
                run2 = game.linescore.offense.second.id
              }
              if ( game.linescore.offense.third ) {
                run3 = game.linescore.offense.third.id
              }
            }
            
            // Flag to stay on current game if same batter is still at bat
            if ( (game.gamePk == this.temp_cache.gamechanger[id].cur_game_pk) && (game.linescore.offense.batter.id == this.temp_cache.gamechanger[id].cur_batter) && (game.linescore.outs < 3) && ((game.linescore.balls && ![0,4].includes(game.linescore.balls)) || (game.linescore.strikes && ![0,3].includes(game.linescore.strikes))) ) {
              same_batter = 'Y'
            }
            
            // If this is the current game showing
            if ( game.gamePk == this.temp_cache.gamechanger[id].cur_game_pk ) {
              // Grabs that games LI to compare to the new high lev game
              this.temp_cache.gamechanger[id].cur_game_high_LI = LI
              this.temp_cache.gamechanger[id].cur_batter = game.linescore.offense.batter.id
            }
            
            active_games.push({
              'LI': LI,
              'outs': game.linescore.outs,
              'game_pk': game.gamePk,
              'away_team_id': game.teams.away.team.id,
              'home_team_id': game.teams.home.team.id,
              'batter': game.linescore.offense.batter.id,
              'pitcher': game.linescore.defense.pitcher.id,
              'ondeck': game.linescore.offense.onDeck.id,
              'run1': run1,
              'run2': run2,
              'run3': run3,
              'inning': game.linescore.currentInning,
              'half': game.linescore.half,
              'away_hits': game.linescore.teams.away.hits,
              'home_hits': game.linescore.teams.home.hits,
              'away_runs': game.linescore.teams.away.runs,
              'home_runs': game.linescore.teams.home.runs,
              'codedGameState': game.codedGameState,
              'scheduledInnings': game.scheduledInnings
            })
          }
          
          if ( !this.temp_cache.gamechanger[id].cur_game_pk && (active_games.length == 0) ) {
            this.debuglog(game_changer_title + ' no active games')
            return
          }
          
          if (active_games.length == 0) {
            return
          }
          
          // sort active games by LI
          games = active_games.sort(function (a, b) {
            return b.LI - a.LI;
          })
          
          this.debuglog(game_changer_title + ' active games ' + JSON.stringify(games))
          this.debuglog(game_changer_title + ' current pitchers ' + JSON.stringify(this.temp_cache.gamechanger[id].cur_pitchers))
          this.debuglog(game_changer_title + ' pitching changes ' + JSON.stringify(this.temp_cache.gamechanger[id].break_expiries))
          
          let game_pk = null
          let game_info = null
          if ( this.stream_finder_settings.priority ) {
            for (const [key, priority] of Object.entries(this.stream_finder_settings.priority)) {
              if ( (same_batter == 'N') || (priority.immediate == 'Y') ) {
                for (var i=0; i<games.length; i++) {
                  let game = games[i]
                  // Batter
                  if ( (priority.type == 'bat') && ((parseInt(priority.data) == game.batter) || ((parseInt(priority.data) == game.ondeck) && this.stream_finder_settings.on_deck && (this.stream_finder_settings.on_deck == 'Y') && (game.outs < 2))) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  //Pitcher
                  } else if ( (priority.type == 'pit') && (parseInt(priority.data) == game.pitcher) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  // Runner
                  } else if ( (priority.type == 'run') && (((parseInt(priority.data) == game.run1) && !game.run2) || ((parseInt(priority.data) == game.run2) && !game.run3)) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  // Team
                  } else if ( (priority.type == 'team') && ((parseInt(priority.data) == game.away_team_id) || (parseInt(priority.data) == game.home_team_id)) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  // Batting Team
                  } else if ( (priority.type == 'team_bat') && (((parseInt(priority.data) == game.away_team_id) && (game.half == 1)) || ((parseInt(priority.data) == game.home_team_id) && (game.half == 2))) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  // Pitching Team
                  } else if ( (priority.type == 'team_pit') && (((parseInt(priority.data) == game.away_team_id) && (game.half == 2)) || ((parseInt(priority.data) == game.home_team_id) && (game.half == 1))) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  // Leverage Index
                  } else if ( (priority.type == 'LI') && (parseFloat(priority.data) <= game.LI) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  // No Hitter
                  } else if ( (priority.type == 'NoNo') && (game.inning > parseInt(priority.data)) && (((game.half == 1) && (game.away_hits == 0)) || ((game.half == 2) && (game.home_hits == 0))) ) {
                    game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                    break
                  // Game Situation
                  } else if ( priority.type == 'GameSit' ) {
                    if ( (priority.data == 'through5_tie') && (game.inning > 5) && (game.away_runs == game.home_runs) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'through6_tie') && (game.inning > 6) && (game.away_runs == game.home_runs) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'through7_tie') && (game.inning > 7) && (game.away_runs == game.home_runs) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'through8_tie') && (game.inning > 8) && (game.away_runs == game.home_runs) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'through5_1run') && (game.inning > 5) && (Math.abs(game.away_runs - game.home_runs) == 1) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'through6_1run') && (game.inning > 6) && (Math.abs(game.away_runs - game.home_runs) == 1) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'through7_1run') && (game.inning > 7) && (Math.abs(game.away_runs - game.home_runs) == 1) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'through8_1run') && (game.inning > 8) && (Math.abs(game.away_runs - game.home_runs) == 1) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    }
                  // Misc
                  } else if ( priority.type == 'Misc' ) {
                    if ( (priority.data == 'PosP_pit') && posPlayers.includes(game.picher) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'extra') && (game.inning > game.scheduledInnings) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    } else if ( (priority.data == 'replay') && ['M','N'].includes(game.codedGameState) ) {
                      game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, game, team_data, game_changer_title, priority)
                      break
                    }
                  }
                }
                
                if (game_info) {
                  game_pk = game_info.game_pk
                  this.temp_cache.gamechanger[id].cur_batter = game_info.cur_batter
                  break
                }
              }
            }
          }
                                
          // If no preference items were met 
          if (!game_pk) {
            // if same batter is still at plate
            if (same_batter == 'Y') {
              game_pk = this.temp_cache.gamechanger[id].cur_game_pk
            } else {
              // Ignore if current game is not default high LI game
              if (!this.temp_cache.gamechanger[id].cur_game_high_LI) {
                this.temp_cache.gamechanger[id].cur_game_high_LI = -3
              }
              // When the current game showing is the high leverage game (not chosen from priority list) and there is now a different game that is the highest LI game.
              // New game's LI must be 0.5 higher than current game to switch
              if ( ((this.temp_cache.gamechanger[id].cur_game_high_LI_flag == 'Y') && (games[0].LI > (this.temp_cache.gamechanger[id].cur_game_high_LI + 0.5)) && ((games[0].LI > 1) || (this.temp_cache.gamechanger[id].cur_game_high_LI == -3))) || (this.temp_cache.gamechanger[id].cur_game_high_LI_flag == 'N') ) {
                game_info = this.setCurrentGame(this.temp_cache.gamechanger[id].cur_game_pk, games[0], team_data, game_changer_title, {'type': 'default', 'data': 'highest leverage'})
                game_pk = game_info.game_pk
                this.temp_cache.gamechanger[id].cur_batter = game_info.cur_batter
              } else {
                game_pk = this.temp_cache.gamechanger[id].cur_game_pk // Stay on current game
                // cur_batter and cur_game were set earlier while looping through games
              }
                
              this.temp_cache.gamechanger[id].cur_game_high_LI_flag = 'Y' // For next time through
              this.temp_cache.gamechanger[id].cur_game_high_LI = -3 // Sets to -3, just in case this game ends
            }
          } else {
            this.temp_cache.gamechanger[id].cur_game_high_LI_flag = 'N' // game was set by priority list
          }
          
          // Only update if this is a different game
          if (game_pk != this.temp_cache.gamechanger[id].cur_game_pk) {
            // delay untested, disabled
            /*if ( this.temp_cache.gamechanger[id].cur_game_pk && this.stream_finder_settings.delay && (parseInt(this.stream_finder_settings.delay) > 0) ) {
              this.debuglog(game_changer_title + ' delaying switch by ' + this.stream_finder_settings.delay)
              await this.sleep(this.stream_finder_settings.delay)
            }*/
            this.log(game_changer_title + 'loading game ' + game_pk)
            this.temp_cache.gamechanger[id].cur_game_pk = game_pk
            // get stream URL
            let favTeamBroadcast
            let mediaId
            let streamURL
            let streamInfo
            for (var x=0; x<cache_data.dates[0].games.length; x++) {
              if ( game_pk == cache_data.dates[0].games[x].gamePk ) {
                if ( cache_data.dates[0].games[x].broadcasts && (cache_data.dates[0].games[x].broadcasts.length > 0) ) {
                  let broadcasts = cache_data.dates[0].games[x].broadcasts
                  if ( await this.count_broadcasts(broadcasts, 'MLBTV') > 0 ) {
                    for (var y = 0; y < broadcasts.length; y++) {
                      let broadcast = broadcasts[y]
                      if ( (broadcast.availableForStreaming == true) && (broadcast.type == 'TV') && broadcast.mediaState && broadcast.mediaState.mediaStateCode && (broadcast.mediaState.mediaStateCode == 'MEDIA_ON') ) {
                        // skip blackout feeds
                        if ( this.temp_cache.gamechanger.blackouts[game_pk] && this.temp_cache.gamechanger.blackouts[game_pk].blackout_feeds && this.temp_cache.gamechanger.blackouts[game_pk].blackout_feeds.includes(broadcast.mediaId) ) {
                          continue
                        }
                        // prefer fav team broadcasts
                        if ( this.credentials.fav_teams.length > 0 ) {
                          for (var z = 0; z < this.credentials.fav_teams.length; z++) {
                            if ( ((broadcast.homeAway == 'home') && (cache_data.dates[0].games[x].teams.home.id == TEAM_IDS[this.credentials.fav_teams[z]])) || ((broadcast.homeAway == 'away') && (cache_data.dates[0].games[x].teams.away.id == TEAM_IDS[this.credentials.fav_teams[z]])) ) {
                              this.debuglog(game_changer_title + 'found fav team broadcast')
                              favTeamBroadcast = true
                              mediaId = broadcast.mediaId
                              break
                            }
                          }
                          if ( favTeamBroadcast ) {
                            break
                          }
                        }
                        // fall back to home or national broadcast
                        if ( !mediaId || (broadcast.homeAway == 'home') || (broadcast.isNational == true) ) {
                          this.debuglog(game_changer_title + 'found home or national broadcast')
                          mediaId = broadcast.mediaId
                        }
                      }
                    } // end broadcasts loop
                    if ( mediaId ) {
                       streamInfo = await this.getStreamURL(mediaId)
                       if ( streamInfo.streamURL ) {
                         // always convert the stream URL to variant form
                         streamInfo.streamURL = streamInfo.streamURL.substr(0,streamInfo.streamURL.length-5)
                         return streamInfo
                       } else {
                         this.log(game_changer_title + 'failed to find streamURL for ' + mediaId)
                       }
                    } else {
                      this.log(game_changer_title + 'failed to find mediaId for ' + game_pk)
                    }
                  } else {
                    this.log(game_changer_title + 'failed to find broadcasts for ' + game_pk)
                  } // end broadcast count
                } // end broadcasts check
                break
              } // end game match
            } // end game loop
          }
        } else {
          this.log(game_changer_title + 'error : no games in date from url ' + reqObj.url)
        }
      } else {
        this.log(game_changer_title + 'error : no data found or cached')
      }
    } catch(e) {
      this.log(game_changer_title + 'getStreamFinderGame error : ' + e.message)
    }

    return
  }

  // get best active live game by leverage
  async getBestGame(id) {
    var game_changer_title = 'Game changer ' + id + ' '

    try {
      let cache_data
      let cache_name = 'gamechanger'
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !this.temp_cache.gamechanger.cache_data || !this.temp_cache.gamechangerCacheExpiry || (currentDate > new Date(this.temp_cache.gamechangerCacheExpiry)) ) {
        this.debuglog(game_changer_title + 'fetching new gamechanger data')
        let cacheExpiry = new Date()
        cacheExpiry.setSeconds(cacheExpiry.getSeconds()+9)
        this.temp_cache.gamechangerCacheExpiry = cacheExpiry
        let reqObj = {
          //url: 'https://gd2.mlb.com/components/game/mlb/year_' + this.temp_cache.gamechanger.dateString + '/master_scoreboard.json',
          url: 'https://statsapi.mlb.com/api/v1/schedule?sportId=1&startDate=' + this.temp_cache.gamechanger.date + '&endDate=' + this.temp_cache.gamechanger.date + '&hydrate=broadcasts(all),linescore,team,flags,gameInfo',
          headers: {
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com/',
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(game_changer_title + 'valid json response')
          this.debuglog(response)
          this.temp_cache.gamechanger.cache_data = JSON.parse(response)
        } else {
          this.log(game_changer_title + 'error : invalid json from url ' + reqObj.url)
          return
        }
      } else {
        this.debuglog(game_changer_title + 'using cached gamechanger data')
      }
      cache_data = this.temp_cache.gamechanger.cache_data

      if ( cache_data ) {
        //if ( cache_data.data && cache_data.data.games && cache_data.data.games.game && (cache_data.data.games.game.length > 0) ) {
        if ( cache_data.dates && cache_data.dates[0] && cache_data.dates[0].games && (cache_data.dates[0].games.length > 0) ) {
          var games = []
          var best_games = []
          var players = {}
          var inning_states
          var omitted_games
          // if we don't have a current game, and no game is found on loop #1, incrementally expand the criteria to include:
          // 2. challenge/replay review games
          // 3. games in break
          // 4. warmup
          for (var x=1; x<5; x++) {
            inning_states = {}
            omitted_games = {'no_broadcast': [], 'excluded': [], 'blackout': [], 'warmup': [], 'inactive': [], 'break': [], 'pitching_change': [], 'review': []}

            // reset all break expiries if we're on our third loop and including games in break
            if ( x == 3 ) {
              this.temp_cache.gamechanger[id].break_expiries = {}
            }

            //for (var i=0; i<cache_data.data.games.game.length; i++) {
            for (var i=0; i<cache_data.dates[0].games.length; i++) {
              //let away_name_abbrev = cache_data.data.games.game[i].away_name_abbrev
              //let home_name_abbrev = cache_data.data.games.game[i].home_name_abbrev
              //let game_pk = cache_data.data.games.game[i].game_pk.toString()
              let away_name_abbrev = cache_data.dates[0].games[i].teams['away'].team.abbreviation
              let home_name_abbrev = cache_data.dates[0].games[i].teams['home'].team.abbreviation
              let game_pk = cache_data.dates[0].games[i].gamePk.toString()

              let teams = away_name_abbrev + '@' + home_name_abbrev

              // Check break expiry, if available
              if ( this.temp_cache.gamechanger[id].break_expiries[game_pk] && (this.temp_cache.gamechanger[id].break_expiries[game_pk] > currentDate) ) {
                this.debuglog(game_changer_title + teams + ' still in break')
                omitted_games.break.push(teams)
                continue
              }

              // Game is not broadcast
              if ( !cache_data.dates[0].games[i].broadcasts || (cache_data.dates[0].games[i].broadcasts.length == 0) ) {
                omitted_games.no_broadcast.push(teams)
                continue
              }
              let broadcast_count = await this.count_broadcasts(cache_data.dates[0].games[i].broadcasts, 'MLBTV')
              if ( broadcast_count == 0 ) {
                omitted_games.no_broadcast.push(teams)
                continue
              }

              // Game is not included
              if ( (this.temp_cache.gamechanger[id].includeTeams.length > 0) && !this.temp_cache.gamechanger[id].includeTeams.includes(away_name_abbrev) && !this.temp_cache.gamechanger[id].includeTeams.includes(home_name_abbrev) ) {
                omitted_games.excluded.push(teams)
                continue
              }

              // Game is excluded
              if ( (this.temp_cache.gamechanger[id].excludeTeams.length > 0) && (this.temp_cache.gamechanger[id].excludeTeams.includes(away_name_abbrev) || this.temp_cache.gamechanger[id].excludeTeams.includes(home_name_abbrev)) ) {
                omitted_games.excluded.push(teams)
                continue
              }

              // All feeds are blacked out or not entitled
              if ( this.temp_cache.gamechanger.blackouts[game_pk] && this.temp_cache.gamechanger.blackouts[game_pk].blackout_feeds && (this.temp_cache.gamechanger.blackouts[game_pk].blackout_feeds.length == broadcast_count) ) {
                omitted_games.blackout.push(teams)
                continue
              }

              //let status = cache_data.data.games.game[i].status.status
              let status = cache_data.dates[0].games[i].status.detailedState
              if ( status.toLowerCase().includes('challenge') || status.toLowerCase().includes('review') ) {
                // Game is in replay review
                if ( x < 2 ) {
                  omitted_games.review.push(teams)
                  continue
                }
              } else if ( status == 'Warmup' ) {
                // Game is in warmup
                if ( x < 4 ) {
                  omitted_games.warmup.push(teams)
                  continue
                }
              } else if ( status != 'In Progress' ) {
                // Game is otherwise not active (not started or game over)
                omitted_games.inactive.push(teams)
                continue
              }

              //let inning_half = cache_data.data.games.game[i].status.inning_state
              let inning_half = cache_data.dates[0].games[i].linescore.inningHalf
              if (inning_half == 'Bottom') {
                inning_half = 'bot'
              } else if (inning_half == 'Top') {
                inning_half = 'top'
              }

              //let inning_num = parseInt(cache_data.data.games.game[i].status.inning)
              let inning_num = parseInt(cache_data.dates[0].games[i].linescore.currentInning)
              if ( Number.isNaN(inning_num) ) {
                omitted_games.inactive.push(teams)
                continue
              }
              //let outs = parseInt(cache_data.data.games.game[i].status.o)
              let outs = parseInt(cache_data.dates[0].games[i].linescore.outs)
              if ( Number.isNaN(outs) ) {
                omitted_games.inactive.push(teams)
                continue
              }
              let runners_on_base = '_ _ _'
              //if ( cache_data.data.games.game[i].runners_on_base ) {
              if ( cache_data.dates[0].games[i].linescore.offense ) {
                //if ( cache_data.data.games.game[i].runners_on_base.runner_on_1b ) {
                if ( cache_data.dates[0].games[i].linescore.offense.first ) {
                  runners_on_base = '1 '
                } else {
                  runners_on_base = '_ '
                }
                //if ( cache_data.data.games.game[i].runners_on_base.runner_on_2b ) {
                if ( cache_data.dates[0].games[i].linescore.offense.second ) {
                  runners_on_base += '2 '
                } else {
                  runners_on_base += '_ '
                }
                //if ( cache_data.data.games.game[i].runners_on_base.runner_on_3b ) {
                if ( cache_data.dates[0].games[i].linescore.offense.third ) {
                  runners_on_base += '3'
                } else {
                  runners_on_base += '_'
                }
              }
              //let balls = parseInt(cache_data.data.games.game[i].status.b)
              //let strikes = parseInt(cache_data.data.games.game[i].status.s)
              //let away_score = parseInt(cache_data.data.games.game[i].linescore.r.away)
              //let home_score = parseInt(cache_data.data.games.game[i].linescore.r.home)
              let balls = parseInt(cache_data.dates[0].games[i].linescore.balls)
              let strikes = parseInt(cache_data.dates[0].games[i].linescore.strikes)
              let away_score = parseInt(cache_data.dates[0].games[i].linescore.teams.away.runs)
              let home_score = parseInt(cache_data.dates[0].games[i].linescore.teams.home.runs)

              // Game hasn't started yet
              if ( (x < 4) && (inning_num == 1) && (inning_half == 'top') && (outs == 0) && (balls == 0) && (strikes == 0) && (away_score == 0) && (runners_on_base == '_ _ _') ) {
                omitted_games.inactive.push(teams)
                continue
              }

              // Game is between innings
              if ( (inning_half == 'Middle') || (inning_half == 'End') || (outs == 3) ) {
                if ( outs == 3 ) {
                  if ( inning_half == 'top' ) {
                    inning_half = 'Middle'
                  } else if ( inning_half == 'bot' ) {
                    inning_half = 'End'
                  }
                }

                if ( (inning_half == 'Middle') || (inning_half == 'End') ) {
                  if (inning_half == 'Middle') {
                    // check for finished games
                    if ( (inning_num == 9) && (away_score < home_score) ) {
                      omitted_games.inactive.push(teams)
                      continue
                    }
                    inning_half = 'bot'
                  } else if (inning_half == 'End') {
                    // check for finished games
                    if ( (inning_num >= 9) && (away_score != home_score) ) {
                      omitted_games.inactive.push(teams)
                      continue
                    }
                    inning_half = 'top'
                    inning_num += 1
                  }

                  outs = 0
                  runners_on_base = '_ _ _'
                  balls = 0
                  strikes = 0
                }

                if ( x < 3 ) {
                  this.debuglog(game_changer_title + teams + ' inning break started or in progress')
                  omitted_games.break.push(teams)

                  // only set break expiry for active games (that already have a stored inning state)
                  if ( this.temp_cache.gamechanger[id].inning_states && (this.temp_cache.gamechanger[id].inning_states.length > 0) && this.temp_cache.gamechanger[id].inning_states[0][game_pk] ) {
                    this.setBreakExpiry(id, game_pk)
                  }

                  continue
                }
              }

              let inning_state = inning_half + ',' + inning_num
              inning_states[game_pk] = inning_state

              // if the inning state has changed, assume a break
              if ( (x < 3) && this.temp_cache.gamechanger[id].inning_states && (this.temp_cache.gamechanger[id].inning_states.length > 0) && this.temp_cache.gamechanger[id].inning_states[0][game_pk] && (inning_state != this.temp_cache.gamechanger[id].inning_states[0][game_pk]) ) {
                this.debuglog(game_changer_title + teams + ' inning break detected')
                omitted_games.break.push(teams)
                this.setBreakExpiry(id, game_pk)
                continue
              }

              // if the pitcher has changed, assume a break
              let pitcher = null
              //if ( cache_data.data.games.game[i].pitcher && cache_data.data.games.game[i].pitcher.id ) {
              if ( cache_data.dates[0].games[i].linescore.defense && cache_data.dates[0].games[i].linescore.defense.pitcher && cache_data.dates[0].games[i].linescore.defense.pitcher.id ) {
                //pitcher = cache_data.data.games.game[i].pitcher.id
                pitcher = cache_data.dates[0].games[i].linescore.defense.pitcher.id
                if ( (x < 3) && this.temp_cache.gamechanger[id].players && (this.temp_cache.gamechanger[id].players.length > 0) && this.temp_cache.gamechanger[id].players[0][game_pk] && (this.temp_cache.gamechanger[id].players[0][game_pk].pitcher != pitcher) ) {
                  this.debuglog(game_changer_title + teams + ' pitching change break detected')
                  omitted_games.pitching_change.push(teams)
                  this.setBreakExpiry(id, game_pk)
                  continue
                }
              }

              let batter = null
              //if ( cache_data.data.games.game[i].batter && cache_data.data.games.game[i].batter.id ) {
              if ( cache_data.dates[0].games[i].linescore.offense && cache_data.dates[0].games[i].linescore.offense.batter && cache_data.dates[0].games[i].linescore.offense.batter.id ) {
                //batter = cache_data.data.games.game[i].batter.id
                batter = cache_data.dates[0].games[i].linescore.offense.batter.id
              }
              let new_batter = false
              if ( ((balls == 0) && (strikes == 0)) || (balls == 4) || (strikes == 3) || (this.temp_cache.gamechanger[id].players && (this.temp_cache.gamechanger[id].players.length > 0) && this.temp_cache.gamechanger[id].players[0][game_pk] && (this.temp_cache.gamechanger[id].players[0][game_pk].batter != batter)) ) {
                new_batter = true
              }

              // bump perfect games or no hitters in the 9th inning to the top of the leverage list
              let leverage_adjust = 0
              //if ( (inning_num == 9) && ((cache_data.data.games.game[i].status.is_perfect_game == 'Y') || (cache_data.data.games.game[i].status.is_no_hitter == 'Y')) ) {
              if ( (inning_num == 9) && ((cache_data.dates[0].games[i].flags.perfectGame == true) || (cache_data.dates[0].games[i].flags.noHitter == true)) ) {
                //let away_hits = parseInt(cache_data.data.games.game[i].linescore.h.away)
                let away_hits = parseInt(cache_data.dates[0].games[i].linescore.teams.away.hits)
                if ( ((away_hits == 0) && (inning_half == 'top')) || (inning_half == 'bot') ) {
                  //if ( cache_data.data.games.game[i].status.is_perfect_game == 'Y' ) {
                  if ( cache_data.dates[0].games[i].flags.perfectGame == true ) {
                    this.debuglog(game_changer_title + 'adjusting ' + teams + ' for perfect game')
                    leverage_adjust = MAX_LEVERAGE * 2
                  } else{
                    this.debuglog(game_changer_title + 'adjusting ' + teams + ' for no hitter')
                    leverage_adjust = MAX_LEVERAGE
                  }
                }
              }

              let run_differential_index = Math.max(-4, Math.min((home_score - away_score), 4)) + 4
              let inning_num_index = Math.min(inning_num, 9)

              let leverage_index = LI_TABLE[inning_num_index][inning_half][runners_on_base][outs][run_differential_index] + leverage_adjust

              games.push({
                'leverage_index': leverage_index,
                'teams': teams,
                'away_score': away_score,
                'home_score': home_score,
                'inning_half': inning_half,
                'inning_num': inning_num,
                'outs': outs,
                'runners_on_base': runners_on_base,
                'balls': balls,
                'strikes': strikes,
                'new_batter': new_batter,
                'game_pk': game_pk
              })

              players[game_pk] = {'pitcher': pitcher, 'batter': batter}
            }

            if ( this.temp_cache.gamechanger[id].gamePk || (games.length > 0) ) {
              break
            }
          }
          this.debuglog(game_changer_title + 'omitted games ' + JSON.stringify(omitted_games))

          if ( games.length > 0 ) {
            //best_games = games.sort(this.GetSortOrderReverse('leverage_index'))
            // sort games by leverage index (desc), then inning number (desc), then inning half (bottom then top), then finally outs (desc)
            best_games = games.sort(function (a, b) {
              return b.leverage_index - a.leverage_index || b.inning_num - a.inning_num || a.inning_half.localeCompare(b.inning_half) || b.outs - a.outs;
            })
          }
          this.debuglog(game_changer_title + 'live sorted games ' + JSON.stringify(best_games))
          this.debuglog(game_changer_title + 'players ' + JSON.stringify(players))
          this.debuglog(game_changer_title + 'inning states ' + JSON.stringify(inning_states))
          this.debuglog(game_changer_title + 'break expiries ' + JSON.stringify(this.temp_cache.gamechanger[id].break_expiries))

          if ( !this.temp_cache.gamechanger[id].games ) this.temp_cache.gamechanger[id].games = []
          this.temp_cache.gamechanger[id].games.push(best_games)
          let maxlength = (this.gamechanger_delay + 10 + MLB_GAMECHANGER_PADDING) / 10
          while ( this.temp_cache.gamechanger[id].games.length > maxlength ) {
            this.temp_cache.gamechanger[id].games.shift()
          }
          if ( !this.temp_cache.gamechanger[id].players ) this.temp_cache.gamechanger[id].players = []
          this.temp_cache.gamechanger[id].players.push(players)
          while ( this.temp_cache.gamechanger[id].players.length > maxlength ) {
            this.temp_cache.gamechanger[id].players.shift()
          }
          if ( !this.temp_cache.gamechanger[id].inning_states ) this.temp_cache.gamechanger[id].inning_states = []
          this.temp_cache.gamechanger[id].inning_states.push(inning_states)
          while ( this.temp_cache.gamechanger[id].inning_states.length > maxlength ) {
            this.temp_cache.gamechanger[id].inning_states.shift()
          }

          best_games = this.temp_cache.gamechanger[id].games[0]
          if ( maxlength > 1 ) {
            this.debuglog(game_changer_title + 'delayed sorted games ' + JSON.stringify(best_games))
          }
          if ( (best_games.length == 0) || (this.temp_cache.gamechanger[id].gamePk && (best_games[0].game_pk == this.temp_cache.gamechanger[id].gamePk)) ) {
            this.debuglog(game_changer_title + 'best game has not changed')
            return
          } else {
            // Update state of curr_game
            let curr_game
            let curr_game_below_avg = false
            if ( this.temp_cache.gamechanger[id].gamePk ) {
              for (var i=0; i<best_games.length; i++) {
                if ( this.temp_cache.gamechanger[id].gamePk == best_games[i].game_pk ) {
                  curr_game = best_games[i]
                  if ( curr_game.leverage_index < 1.0 ) {
                    curr_game_below_avg = true
                  }
                  break
                }
              }
            }
            if ( curr_game && (best_games.length > 0) && (curr_game.leverage_index == best_games[0].game_pk) ) {
              this.debuglog(game_changer_title + 'current game still best or tied for best')
              return
            }
            // Only switch games if:
            //  curr_game is None (either no curr_game or it's in commercial break)
            //  The change in leverage is > 1.5 and there's a new batter in curr_game
            //  game has a better leverage than curr_game and curr_game is below average leverage (1.0) and there's a new batter in curr_game
            for (var i=0; i<best_games.length; i++) {
              let large_leverage_diff = false
              if ( curr_game && ((best_games[i].leverage_index - curr_game.leverage_index) > 1.5) ) {
                large_leverage_diff = true
              }
              let game_better = false
              if ( curr_game && (best_games[i].leverage_index > curr_game.leverage_index) ) {
                game_better = true
              }
              if ( !curr_game || (curr_game.new_batter && (large_leverage_diff || (curr_game_below_avg && game_better))) ) {
                curr_game = best_games[i]
                this.log(game_changer_title + 'loading game ' + curr_game.teams)
                this.temp_cache.gamechanger[id].gamePk = curr_game.game_pk
                // get stream URL
                let favTeamBroadcast
                let mediaId
                let streamURL
                let streamInfo
                for (var x=0; x<cache_data.dates[0].games.length; x++) {
                  if ( curr_game.game_pk == cache_data.dates[0].games[x].gamePk ) {
                    if ( cache_data.dates[0].games[x].broadcasts && (cache_data.dates[0].games[x].broadcasts.length > 0) ) {
                      let broadcasts = cache_data.dates[0].games[x].broadcasts
                      if ( await this.count_broadcasts(broadcasts, 'MLBTV') > 0 ) {
                        for (var y = 0; y < broadcasts.length; y++) {
                          let broadcast = broadcasts[y]
                          if ( (broadcast.availableForStreaming == true) && (broadcast.type == 'TV') && broadcast.mediaState && broadcast.mediaState.mediaStateCode && (broadcast.mediaState.mediaStateCode == 'MEDIA_ON') ) {
                            // skip blackout feeds
                            if ( this.temp_cache.gamechanger.blackouts[curr_game.game_pk] && this.temp_cache.gamechanger.blackouts[curr_game.game_pk].blackout_feeds && this.temp_cache.gamechanger.blackouts[curr_game.game_pk].blackout_feeds.includes(broadcast.mediaId) ) {
                              continue
                            }
                            // prefer fav team broadcasts
                            if ( this.credentials.fav_teams.length > 0 ) {
                              for (var z = 0; z < this.credentials.fav_teams.length; z++) {
                                if ( ((broadcast.homeAway == 'home') && (cache_data.dates[0].games[x].teams.home.id == TEAM_IDS[this.credentials.fav_teams[z]])) || ((broadcast.homeAway == 'away') && (cache_data.dates[0].games[x].teams.away.id == TEAM_IDS[this.credentials.fav_teams[z]])) ) {
                                  this.debuglog(game_changer_title + 'found fav team broadcast')
                                  favTeamBroadcast = true
                                  mediaId = broadcast.mediaId
                                  break
                                }
                              }
                              if ( favTeamBroadcast ) {
                                break
                              }
                            }

                            // fall back to home or national broadcast
                            if ( !mediaId || (broadcast.homeAway == 'home') || (broadcast.isNational == true) ) {
                              this.debuglog(game_changer_title + 'found home or national broadcast')
                              mediaId = broadcast.mediaId
                            }
                          }
                        } // end broadcasts loop
                        if ( mediaId ) {
                           streamInfo = await this.getStreamURL(mediaId)
                           if ( streamInfo.streamURL ) {
                             // always convert the stream URL to variant form
                             streamInfo.streamURL = streamInfo.streamURL.substr(0,streamInfo.streamURL.length-5)
                             return streamInfo
                           } else {
                             this.log(game_changer_title + 'failed to find streamURL for ' + mediaId)
                           }
                        } else {
                          this.log(game_changer_title + 'failed to find mediaId for ' + curr_game.game_pk)
                        }
                      } else {
                        this.log(game_changer_title + 'failed to find broadcasts for ' + curr_game.game_pk)
                      } // end broadcast count
                    } // end broadcasts check
                    break
                  } // end game match
                } // end game loop
              } else if ( large_leverage_diff ) {
                this.debuglog(game_changer_title + best_games[i].teams + ' is a better game, but ' + curr_game.teams + ' still has a batter at the plate')
              } else if ( game_better ) {
                this.debuglog(game_changer_title + best_games[i].teams + ' is a better game, but not enough better to switch from ' + curr_game.teams)
              }
            }
          }
        } else {
          this.log(game_changer_title + 'error : no games in date from url ' + reqObj.url)
        }
      } else {
        this.log(game_changer_title + 'error : no data found or cached')
      }
    } catch(e) {
      this.log(game_changer_title + 'getBestGame error : ' + e.message)
    }

    return
  }

  async get_first_and_last_games(games, blackouts) {
    let firstGameIndex
    for (var j = 0; j < games.length; j++) {
      let gamePk = games[j].gamePk.toString()
      if ( games[j].gameDate && (games[j].teams.home.team.sport.id == 1) && (games[j].teams.away.team.sport.id == 1) && !blackouts[gamePk] && !games[j].rescheduleDate && !games[j].status.startTimeTBD && games[j].broadcasts && (await this.count_broadcasts(games[j].broadcasts, 'MLBTV') > 0) ) {
        this.debuglog('get_first_and_last_games first : ' + j + ' ' + gamePk + ' at ' + games[j].gameDate)
        firstGameIndex = j
        break
      }
    }
    let lastGameIndex
    for (var j = (games.length-1); j >= 0; j--) {
      let gamePk = games[j].gamePk.toString()
      if ( games[j].gameDate && (games[j].teams.home.team.sport.id == 1) && (games[j].teams.away.team.sport.id == 1) && !blackouts[gamePk] && !games[j].rescheduleDate && games[j].broadcasts && (await this.count_broadcasts(games[j].broadcasts, 'MLBTV') > 0) ) {
        this.debuglog('get_first_and_last_games last : ' + j + ' ' + gamePk + ' at ' + games[j].gameDate)
        lastGameIndex = j
        break
      }
    }
    return { firstGameIndex, lastGameIndex }
  }

  async count_broadcasts(broadcasts, mediaType, language='') {
    let broadcast_count = 0
    for (var x = 0; x < broadcasts.length; x++) {
      let broadcast = broadcasts[x]
      let mediaTitle = 'Audio'
      if ( broadcast.type == 'TV' ) {
        mediaTitle = 'MLBTV'
      } else if ( broadcast.language == 'es' ) {
        mediaTitle = 'Spanish'
      }
      if ( (mediaType == mediaTitle) && (broadcast.availableForStreaming == true) && ((broadcast.type == 'TV') || ((mediaType == 'Audio') && (broadcast.language == language))) ) {
        broadcast_count++
      }
    }
    return broadcast_count
  }

  /*async check_in_market(item) {
    try {
      if ( item.mediaFeedType.startsWith('IN_MARKET_') ) {
        return true
      }
    } catch (e) {
      return false
    }
    return false
  }*/

  async check_pay_tv(item) {
    try {
      if ( item.mvpdAuthRequired == true ) {
        return true
      }
    } catch (e) {
      return false
    }
    return false
  }

  async get_scheduled_innings(game) {
    var scheduledInnings = '9'
    if ( game && game.linescore && game.linescore.scheduledInnings ) {
      scheduledInnings = game.linescore.scheduledInnings
      if ( (game.status.abstractGameState == 'Final') && game.linescore.currentInning && (game.linescore.currentInning < 9) ) {
        scheduledInnings = game.linescore.currentInning
      }
    }
    return scheduledInnings
  }

  async check_game_time(gameData) {
    if ( !gameData.resumeGameDate && !gameData.resumedFromDate && (gameData.startTimeTBD == false) ) {
      return true
    } else {
      return false
    }
  }

  async get_blackout_expiry(game) {
    let scheduledInnings = await this.get_scheduled_innings(game)
    this.debuglog('get_blackout_expiry scheduledInnings ' + scheduledInnings)
    // avg 9 inning game was 2:39 in 2023, or 17.66 minutes per inning
    let gameDurationMinutes = 17.66 * scheduledInnings
    // default to assuming the scheduled game time is the first pitch time
    let firstPitch = new Date(game.gameDate)
    this.debuglog('get_blackout_expiry gameDate ' + firstPitch)
    if ( game.gameInfo ) {
      // check if firstPitch has been updated with a valid time (later than the scheduled game time)
      if ( game.gameInfo.firstPitch && (game.gameInfo.firstPitch >= game.gameDate) ) {
        firstPitch = new Date(game.gameInfo.firstPitch)
        this.debuglog('get_blackout_expiry firstPitch ' + firstPitch)
        // for completed games, get the duration too
        if ( game.gameInfo.gameDurationMinutes ) {
          gameDurationMinutes = game.gameInfo.gameDurationMinutes
          this.debuglog('get_blackout_expiry gameDurationMinutes ' + gameDurationMinutes)
          // add any delays
          if ( game.gameInfo.delayDurationMinutes ) {
            gameDurationMinutes += game.gameInfo.delayDurationMinutes
            this.debuglog('get_blackout_expiry delayDurationMinutes ' + game.gameInfo.delayDurationMinutes)
          }
        }
      }
    }
    // blackout is officially 90 minutes after game ends, but in practice, we add an extra hour
    gameDurationMinutes += 150
    let blackoutExpiry = firstPitch
    blackoutExpiry.setMinutes(blackoutExpiry.getMinutes()+gameDurationMinutes)
    return blackoutExpiry
  }

  async check_media_state(broadcast, abstractGameState, mediaDate, gamePk) {
    let mediaInfo = {}
    if ( broadcast.mediaState && broadcast.mediaState.mediaStateCode && (broadcast.mediaState.mediaStateCode == 'MEDIA_ON') || ((mediaDate) && ((broadcast.mediaState.mediaStateCode == 'MEDIA_ARCHIVE') || (abstractGameState == 'Final'))) ) {
      mediaInfo.mediaId = broadcast.mediaId
      mediaInfo.gamePk = gamePk
    } else {
      this.log('event video not available')
    }
    return mediaInfo
  }

  date_to_ics_format(aDate) {
    return aDate.getUTCFullYear().toString() +
((aDate.getUTCMonth() + 1)<10? "0" + (aDate.getUTCMonth() + 1).toString():(aDate.getUTCMonth() + 1).toString()) +
(aDate.getUTCDate()<10? "0" + aDate.getUTCDate().toString():aDate.getUTCDate().toString()) + 'T' + (aDate.getUTCHours()<10? "0" + aDate.getUTCHours().toString():aDate.getUTCHours().toString()) + (aDate.getUTCMinutes()<10? "0" + aDate.getUTCMinutes().toString():aDate.getUTCMinutes().toString()) + '00Z';
  }

  async generate_ics_event(prefix, start, stop, title, description, location) {
    let ics_start = this.date_to_ics_format(start)
    return "\n" + 'BEGIN:VEVENT' + "\n" + 'UID:' + title.replace(/\W/g, '') + '@' + ics_start.replace(/\W/g, '') + "\n" + 'DTSTAMP:' + this.date_to_ics_format(new Date()) + "\n" + 'SUMMARY:' + prefix + ' ' + title + "\n" + 'DTSTART:' + ics_start + "\n" + 'DTEND:' + this.date_to_ics_format(stop) + "\n" + 'DESCRIPTION:' + description + "\n" + 'LOCATION:' + location + "\n" + 'BEGIN:VALARM' + "\n" + 'ACTION:DISPLAY' + "\n" + 'DESCRIPTION:Reminder' + "\n" + 'TRIGGER:-PT0M' + "\n" + 'END:VALARM' + "\n" + 'END:VEVENT'
  }

  async generate_xml_program(channelid, start, stop, title, description, icon, date, subtitle=false, teamId=false, gamePk=false, away_team=false, home_team=false) {
    let xml_output = "\n" + '    <programme channel="' + channelid + '" start="' + start + '" stop="' + stop + '">' + "\n" +
    '      <title lang="en">' + title + '</title>' + "\n"
    if ( subtitle ) {
      xml_output += '      <sub-title lang="en">' + subtitle + '</sub-title>' + "\n"
    }
    xml_output += '      <icon src="' + icon + '"></icon>' + "\n"
    if ( icon != OFF_AIR_LOGO ) {
      xml_output += '      <desc lang="en">' + description.trim() + '</desc>' + "\n" +
      '      <category lang="en">Sports</category>' + "\n" +
      '      <category lang="en">Baseball</category>' + "\n" +
      '      <category lang="en">Sports event</category>' + "\n" + 
      '      <episode-num system="original-air-date">' + date + '</episode-num>' + "\n" + 
      '      <new/>' + "\n" +
      '      <live/>' + "\n" +
      '      <sport>Baseball</sport>' + "\n"
    }
    if ( teamId ) {
      xml_output += '      <series-id system="team-id">' + teamId + '</series-id>' + "\n"
    }
    if ( gamePk ) {
      xml_output += '      <episode-num system="game-id">' + gamePk + '</episode-num>' + "\n"
    }
    if ( away_team ) {
      xml_output += '      <team lang="en">' + away_team + '</team>' + "\n"
    }
    if ( home_team ) {
      xml_output += '      <team lang="en">' + home_team + '</team>' + "\n"
    }
    xml_output += '    </programme>'
    return xml_output
  }

  async convert_stream_to_pipe(stream, channelid) {
    return 'pipe://ffmpeg -hide_banner -loglevel fatal -i "' + stream + '" -map 0:v -map 0:a -c copy -metadata service_provider="MLBTV" -metadata service_name="' + channelid + '" -f mpegts pipe:1'
  }

  async create_channel_object(channelid, logo, stream, channelMediaType) {
    let channel_object = {}
    channel_object.name = channelid
    channel_object.logo = logo
    channel_object.stream = stream
    channel_object.mediatype = channelMediaType
    channel_object.stop = false
    return channel_object
  }
  
  async generate_off_air_event(offAir, channelid, gameDate, start, stop, title) {
    try {
      if ( offAir != 'false' ) {
        let today = this.liveDate()
        let nextWeek = new Date(today)
        nextWeek.setDate(nextWeek.getDate()+6)
        nextWeek = nextWeek.toISOString().substring(0,10)
        if ( !start ) {
          start = this.convertDateToXMLTV(new Date(today + ' 00:00:00'))
        }
        let offAirTitle = 'Off Air'
        let offAirSubtitle = ''
        let day = new Date(gameDate + ' 00:00:00').toLocaleString('en-US', { weekday: 'long' })
        if ( gameDate == today ) {
          day = 'Today'
        }
        if ( gameDate > nextWeek ) {
          day += ' ' + this.channelsFormattedDate(stop)
        }
        let time = new Date(stop).toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true })
        if ( offAir == 'channels' ) {
          offAirTitle = 'Upcoming: ' + time + ' ' + day + ', ' + title
          offAirSubtitle = ''
        } else {
          offAirSubtitle = 'next ' + day + ' ' + time
        }
        return await this.generate_xml_program(channelid, start, this.convertDateToXMLTV(new Date(stop)), offAirTitle, '', OFF_AIR_LOGO, '', offAirSubtitle)
      }
    } catch(e) {
      this.log('generate_off_air_event error : ' + e.message)
    }
  }
  
  channelsFormattedTitle(subtitle, date) {
    return subtitle + ' *Live* ' + this.channelsFormattedDate(date)
  }
  
  channelsFormattedDate(date) {
    return new Date(date).toLocaleString('en-us', { month: 'short', day: 'numeric' })
  }
}

module.exports = sessionClass
