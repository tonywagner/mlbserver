#!/usr/bin/env node

// session.js defines the session class which handles API activity

// Required Node packages for the session class
const fs = require('fs')
const path = require('path')
const readlineSync = require('readline-sync')
const FileCookieStore = require('tough-cookie-filestore')
const parseString = require('xml2js').parseString

const MULTIVIEW_DIRECTORY_NAME = 'multiview'

// Default user agent to use for API requests
const USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:87.0) Gecko/20100101 Firefox/87.0'

// Other variables to use in API communications
const PLATFORM = "macintosh"
const BAM_SDK_VERSION = '4.3'
const BAM_TOKEN_URL = 'https://us.edge.bamgrid.com/token'

// Default date handling
const TODAY_UTC_HOURS = 8 // UTC hours (EST + 4) into tomorrow to still use today's date

const TEAM_IDS = {'ARI':'109','ATL':'144','BAL':'110','BOS':'111','CHC':'112','CWS':'145','CIN':'113','CLE':'114','COL':'115','DET':'116','HOU':'117','KC':'118','LAA':'108','LAD':'119','MIA':'146','MIL':'158','MIN':'142','NYM':'121','NYY':'147','OAK':'133','PHI':'143','PIT':'134','STL':'138','SD':'135','SF':'137','SEA':'136','TB':'139','TEX':'140','TOR':'141','WSH':'120'}

// These are the events to ignore, if we're skipping breaks
const BREAK_TYPES = ['Game Advisory', 'Pitching Substitution', 'Offensive Substitution', 'Defensive Sub', 'Defensive Switch', 'Runner Placed On Base']
// These are the events to keep, in addition to the last event of each at-bat, if we're skipping pitches
const ACTION_TYPES = ['Wild Pitch', 'Passed Ball', 'Stolen Base', 'Caught Stealing', 'Pickoff', 'Error', 'Out', 'Balk', 'Defensive Indiff', 'Other Advance']
const EVENT_START_PADDING = 0
const PITCH_END_PADDING = 7
const ACTION_END_PADDING = 10
const MINIMUM_BREAK_DURATION = 5

const LI_TABLE = {
    1: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.6, 0.7, 0.8, 0.9, 0.0, 0.0, 0.0, 0.0],
                1: [0.3, 0.4, 0.5, 0.6, 0.6, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.3, 0.3, 0.4, 0.4, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ _": {
                0: [0.7, 0.9, 1.1, 1.3, 1.4, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 0.7, 0.9, 1.0, 1.1, 0.0, 0.0, 0.0, 0.0],
                2: [0.4, 0.5, 0.6, 0.7, 0.8, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 _": {
                0: [0.6, 0.7, 0.9, 1.0, 1.2, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 0.8, 0.9, 1.1, 1.2, 0.0, 0.0, 0.0, 0.0],
                2: [0.6, 0.7, 0.9, 1.0, 1.1, 0.0, 0.0, 0.0, 0.0],
            },
            "_ _ 3": {
                0: [0.5, 0.6, 0.8, 0.9, 1.0, 0.0, 0.0, 0.0, 0.0],
                1: [0.7, 0.9, 1.0, 1.2, 1.3, 0.0, 0.0, 0.0, 0.0],
                2: [0.7, 0.9, 1.0, 1.2, 1.3, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 _": {
                0: [0.8, 1.1, 1.3, 1.6, 1.8, 0.0, 0.0, 0.0, 0.0],
                1: [0.9, 1.2, 1.5, 1.7, 1.9, 0.0, 0.0, 0.0, 0.0],
                2: [0.8, 1.0, 1.3, 1.5, 1.6, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ 3": {
                0: [0.6, 0.8, 1.1, 1.3, 1.5, 0.0, 0.0, 0.0, 0.0],
                1: [0.9, 1.1, 1.3, 1.6, 1.7, 0.0, 0.0, 0.0, 0.0],
                2: [0.9, 1.1, 1.4, 1.6, 1.7, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 3": {
                0: [0.6, 0.8, 1.0, 1.2, 1.3, 0.0, 0.0, 0.0, 0.0],
                1: [0.7, 0.9, 1.1, 1.3, 1.4, 0.0, 0.0, 0.0, 0.0],
                2: [1.0, 1.2, 1.5, 1.7, 1.9, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 3": {
                0: [0.8, 1.1, 1.4, 1.7, 2.0, 0.0, 0.0, 0.0, 0.0],
                1: [1.1, 1.5, 1.8, 2.1, 2.4, 0.0, 0.0, 0.0, 0.0],
                2: [1.4, 1.8, 2.1, 2.5, 2.7, 0.0, 0.0, 0.0, 0.0],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.7, 0.8, 0.9, 0.9, 0.9, 0.8, 0.6, 0.5, 0.4],
                1: [0.5, 0.6, 0.6, 0.7, 0.6, 0.6, 0.5, 0.4, 0.3],
                2: [0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.2],
            },
            "1 _ _": {
                0: [1.2, 1.4, 1.5, 1.5, 1.4, 1.2, 1.0, 0.8, 0.6],
                1: [1.0, 1.1, 1.2, 1.2, 1.1, 1.0, 0.8, 0.7, 0.5],
                2: [0.6, 0.7, 0.8, 0.8, 0.8, 0.7, 0.6, 0.5, 0.4],
            },
            "_ 2 _": {
                0: [1.1, 1.2, 1.3, 1.2, 1.1, 1.0, 0.8, 0.6, 0.5],
                1: [1.0, 1.1, 1.2, 1.2, 1.2, 1.0, 0.9, 0.7, 0.5],
                2: [0.8, 1.0, 1.1, 1.1, 1.1, 1.0, 0.8, 0.7, 0.5],
            },
            "_ _ 3": {
                0: [1.0, 1.1, 1.1, 1.1, 1.0, 0.8, 0.7, 0.5, 0.4],
                1: [1.0, 1.1, 1.3, 1.3, 1.3, 1.1, 1.0, 0.8, 0.6],
                2: [1.0, 1.1, 1.3, 1.3, 1.3, 1.2, 1.0, 0.8, 0.6],
            },
            "1 2 _": {
                0: [1.7, 1.9, 2.0, 1.9, 1.7, 1.5, 1.2, 0.9, 0.7],
                1: [1.7, 1.9, 2.0, 2.0, 1.8, 1.6, 1.3, 1.0, 0.8],
                2: [1.3, 1.5, 1.6, 1.7, 1.6, 1.4, 1.2, 0.9, 0.7],
            },
            "1 _ 3": {
                0: [1.6, 1.7, 1.7, 1.6, 1.4, 1.2, 1.0, 0.7, 0.5],
                1: [1.5, 1.7, 1.8, 1.8, 1.7, 1.5, 1.2, 1.0, 0.8],
                2: [1.4, 1.6, 1.7, 1.8, 1.7, 1.5, 1.3, 1.0, 0.8],
            },
            "_ 2 3": {
                0: [1.4, 1.5, 1.5, 1.4, 1.3, 1.1, 0.9, 0.7, 0.5],
                1: [1.4, 1.5, 1.6, 1.5, 1.4, 1.2, 1.0, 0.8, 0.6],
                2: [1.6, 1.8, 2.0, 2.0, 1.9, 1.7, 1.4, 1.1, 0.8],
            },
            "1 2 3": {
                0: [2.2, 2.3, 2.3, 2.1, 1.9, 1.6, 1.2, 0.9, 0.7],
                1: [2.4, 2.6, 2.6, 2.6, 2.3, 2.0, 1.6, 1.3, 1.0],
                2: [2.4, 2.7, 2.9, 2.9, 2.7, 2.4, 2.0, 1.5, 1.2],
            },
        },
    },
    2: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7],
                1: [0.3, 0.4, 0.5, 0.6, 0.7, 0.7, 0.6, 0.6, 0.5],
                2: [0.2, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3],
            },
            "1 _ _": {
                0: [0.7, 0.9, 1.1, 1.3, 1.5, 1.5, 1.5, 1.4, 1.2],
                1: [0.6, 0.7, 0.9, 1.1, 1.2, 1.3, 1.2, 1.1, 0.9],
                2: [0.4, 0.5, 0.7, 0.8, 0.8, 0.9, 0.8, 0.7, 0.6],
            },
            "_ 2 _": {
                0: [0.5, 0.7, 0.9, 1.1, 1.2, 1.3, 1.3, 1.2, 1.0],
                1: [0.6, 0.8, 1.0, 1.1, 1.2, 1.3, 1.2, 1.1, 0.9],
                2: [0.6, 0.8, 0.9, 1.1, 1.2, 1.2, 1.1, 0.9, 0.8],
            },
            "_ _ 3": {
                0: [0.4, 0.6, 0.8, 0.9, 1.1, 1.1, 1.2, 1.1, 0.9],
                1: [0.7, 0.9, 1.1, 1.2, 1.3, 1.3, 1.3, 1.1, 0.9],
                2: [0.7, 0.9, 1.1, 1.3, 1.4, 1.4, 1.2, 1.1, 0.9],
            },
            "1 2 _": {
                0: [0.8, 1.1, 1.4, 1.6, 1.9, 2.0, 2.0, 1.9, 1.7],
                1: [0.9, 1.2, 1.5, 1.8, 2.0, 2.1, 2.0, 1.8, 1.6],
                2: [0.8, 1.0, 1.3, 1.5, 1.7, 1.7, 1.6, 1.4, 1.2],
            },
            "1 _ 3": {
                0: [0.6, 0.8, 1.1, 1.3, 1.6, 1.7, 1.8, 1.7, 1.5],
                1: [0.9, 1.1, 1.4, 1.6, 1.8, 1.8, 1.8, 1.6, 1.4],
                2: [0.9, 1.1, 1.4, 1.6, 1.8, 1.8, 1.7, 1.5, 1.3],
            },
            "_ 2 3": {
                0: [0.6, 0.8, 1.0, 1.2, 1.4, 1.5, 1.6, 1.5, 1.4],
                1: [0.7, 0.9, 1.1, 1.3, 1.5, 1.6, 1.6, 1.5, 1.3],
                2: [1.0, 1.2, 1.5, 1.8, 2.0, 2.1, 2.0, 1.7, 1.4],
            },
            "1 2 3": {
                0: [0.8, 1.1, 1.4, 1.7, 2.0, 2.3, 2.4, 2.3, 2.1],
                1: [1.1, 1.5, 1.8, 2.2, 2.5, 2.7, 2.7, 2.6, 2.3],
                2: [1.3, 1.7, 2.2, 2.6, 2.9, 3.0, 2.9, 2.6, 2.2],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 0.9, 1.0, 1.0, 0.9, 0.8, 0.6, 0.5, 0.4],
                1: [0.5, 0.6, 0.7, 0.7, 0.7, 0.6, 0.5, 0.4, 0.3],
                2: [0.3, 0.4, 0.4, 0.5, 0.4, 0.4, 0.3, 0.2, 0.2],
            },
            "1 _ _": {
                0: [1.3, 1.5, 1.6, 1.6, 1.5, 1.2, 1.0, 0.8, 0.6],
                1: [1.0, 1.2, 1.3, 1.3, 1.2, 1.0, 0.8, 0.6, 0.5],
                2: [0.6, 0.8, 0.9, 0.9, 0.8, 0.7, 0.6, 0.5, 0.3],
            },
            "_ 2 _": {
                0: [1.1, 1.3, 1.3, 1.3, 1.2, 1.0, 0.8, 0.6, 0.4],
                1: [1.0, 1.2, 1.3, 1.3, 1.2, 1.1, 0.9, 0.7, 0.5],
                2: [0.8, 1.0, 1.2, 1.2, 1.2, 1.0, 0.9, 0.7, 0.5],
            },
            "_ _ 3": {
                0: [1.0, 1.2, 1.2, 1.2, 1.0, 0.9, 0.7, 0.5, 0.4],
                1: [1.0, 1.2, 1.3, 1.4, 1.4, 1.2, 1.0, 0.8, 0.6],
                2: [1.0, 1.2, 1.3, 1.4, 1.4, 1.2, 1.0, 0.8, 0.6],
            },
            "1 2 _": {
                0: [1.8, 2.0, 2.1, 2.0, 1.8, 1.5, 1.2, 0.9, 0.7],
                1: [1.7, 2.0, 2.1, 2.1, 2.0, 1.7, 1.3, 1.0, 0.7],
                2: [1.3, 1.6, 1.8, 1.8, 1.7, 1.5, 1.2, 0.9, 0.7],
            },
            "1 _ 3": {
                0: [1.6, 1.8, 1.8, 1.7, 1.5, 1.2, 0.9, 0.7, 0.5],
                1: [1.5, 1.8, 1.9, 1.9, 1.8, 1.6, 1.3, 1.0, 0.7],
                2: [1.4, 1.7, 1.9, 1.9, 1.8, 1.6, 1.3, 1.0, 0.7],
            },
            "_ 2 3": {
                0: [1.5, 1.6, 1.6, 1.5, 1.3, 1.1, 0.9, 0.7, 0.5],
                1: [1.4, 1.6, 1.7, 1.6, 1.5, 1.3, 1.0, 0.8, 0.6],
                2: [1.6, 1.9, 2.1, 2.1, 2.0, 1.7, 1.4, 1.1, 0.8],
            },
            "1 2 3": {
                0: [2.3, 2.4, 2.4, 2.2, 1.9, 1.6, 1.2, 0.9, 0.6],
                1: [2.5, 2.7, 2.8, 2.7, 2.4, 2.1, 1.7, 1.3, 0.9],
                2: [2.5, 2.8, 3.1, 3.1, 2.9, 2.5, 2.0, 1.5, 1.1],
            },
        },
    },
    3: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.6, 0.7, 0.9, 1.0, 1.0, 1.0, 0.9, 0.7],
                1: [0.3, 0.4, 0.5, 0.6, 0.7, 0.7, 0.7, 0.6, 0.5],
                2: [0.2, 0.3, 0.4, 0.4, 0.5, 0.5, 0.4, 0.4, 0.3],
            },
            "1 _ _": {
                0: [0.6, 0.9, 1.1, 1.4, 1.6, 1.7, 1.6, 1.4, 1.2],
                1: [0.5, 0.7, 1.0, 1.2, 1.3, 1.4, 1.3, 1.1, 0.9],
                2: [0.4, 0.5, 0.7, 0.8, 0.9, 0.9, 0.8, 0.7, 0.6],
            },
            "_ 2 _": {
                0: [0.5, 0.7, 0.9, 1.1, 1.3, 1.4, 1.4, 1.2, 1.0],
                1: [0.6, 0.8, 1.0, 1.2, 1.3, 1.4, 1.3, 1.1, 0.9],
                2: [0.6, 0.8, 1.0, 1.1, 1.3, 1.3, 1.1, 1.0, 0.8],
            },
            "_ _ 3": {
                0: [0.4, 0.6, 0.8, 1.0, 1.1, 1.2, 1.2, 1.1, 1.0],
                1: [0.6, 0.9, 1.1, 1.3, 1.5, 1.5, 1.3, 1.1, 0.9],
                2: [0.7, 0.9, 1.1, 1.3, 1.5, 1.5, 1.3, 1.1, 0.9],
            },
            "1 2 _": {
                0: [0.8, 1.0, 1.4, 1.7, 2.0, 2.2, 2.1, 2.0, 1.7],
                1: [0.9, 1.2, 1.5, 1.8, 2.1, 2.2, 2.1, 1.9, 1.6],
                2: [0.8, 1.0, 1.3, 1.6, 1.8, 1.9, 1.8, 1.5, 1.2],
            },
            "1 _ 3": {
                0: [0.6, 0.8, 1.1, 1.4, 1.6, 1.8, 1.9, 1.8, 1.6],
                1: [0.8, 1.1, 1.4, 1.7, 1.9, 2.0, 1.9, 1.7, 1.5],
                2: [0.8, 1.1, 1.4, 1.7, 1.9, 2.0, 1.9, 1.6, 1.3],
            },
            "_ 2 3": {
                0: [0.5, 0.8, 1.0, 1.2, 1.5, 1.6, 1.7, 1.6, 1.4],
                1: [0.7, 0.9, 1.2, 1.4, 1.6, 1.7, 1.7, 1.6, 1.3],
                2: [0.9, 1.2, 1.6, 1.9, 2.2, 2.2, 2.1, 1.8, 1.5],
            },
            "1 2 3": {
                0: [0.7, 1.0, 1.4, 1.8, 2.1, 2.4, 2.6, 2.5, 2.3],
                1: [1.1, 1.4, 1.9, 2.3, 2.7, 2.9, 2.9, 2.7, 2.4],
                2: [1.3, 1.7, 2.2, 2.7, 3.1, 3.3, 3.1, 2.7, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 0.9, 1.0, 1.1, 1.0, 0.8, 0.6, 0.5, 0.3],
                1: [0.5, 0.7, 0.7, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3],
                2: [0.3, 0.4, 0.5, 0.5, 0.5, 0.4, 0.3, 0.2, 0.2],
            },
            "1 _ _": {
                0: [1.3, 1.6, 1.7, 1.7, 1.5, 1.3, 1.0, 0.7, 0.5],
                1: [1.0, 1.2, 1.4, 1.4, 1.3, 1.1, 0.8, 0.6, 0.4],
                2: [0.6, 0.8, 0.9, 1.0, 0.9, 0.8, 0.6, 0.5, 0.3],
            },
            "_ 2 _": {
                0: [1.2, 1.3, 1.5, 1.4, 1.3, 1.1, 0.8, 0.6, 0.4],
                1: [1.0, 1.3, 1.4, 1.4, 1.3, 1.1, 0.9, 0.6, 0.5],
                2: [0.9, 1.1, 1.3, 1.3, 1.3, 1.1, 0.9, 0.6, 0.5],
            },
            "_ _ 3": {
                0: [1.1, 1.2, 1.3, 1.2, 1.1, 0.9, 0.7, 0.5, 0.3],
                1: [1.0, 1.3, 1.4, 1.5, 1.5, 1.3, 1.0, 0.7, 0.5],
                2: [1.0, 1.2, 1.4, 1.6, 1.5, 1.3, 1.0, 0.8, 0.5],
            },
            "1 2 _": {
                0: [1.9, 2.1, 2.3, 2.2, 1.9, 1.6, 1.2, 0.9, 0.6],
                1: [1.8, 2.1, 2.3, 2.3, 2.1, 1.7, 1.3, 1.0, 0.7],
                2: [1.4, 1.7, 1.9, 2.0, 1.8, 1.5, 1.2, 0.9, 0.6],
            },
            "1 _ 3": {
                0: [1.7, 1.9, 2.0, 1.8, 1.5, 1.2, 0.9, 0.7, 0.4],
                1: [1.6, 1.9, 2.0, 2.1, 1.9, 1.6, 1.3, 0.9, 0.7],
                2: [1.4, 1.8, 2.0, 2.1, 1.9, 1.6, 1.3, 1.0, 0.7],
            },
            "_ 2 3": {
                0: [1.6, 1.7, 1.8, 1.6, 1.4, 1.1, 0.9, 0.6, 0.4],
                1: [1.5, 1.7, 1.8, 1.7, 1.6, 1.3, 1.0, 0.8, 0.5],
                2: [1.6, 2.0, 2.3, 2.3, 2.2, 1.8, 1.4, 1.0, 0.7],
            },
            "1 2 3": {
                0: [2.4, 2.6, 2.6, 2.4, 2.0, 1.6, 1.2, 0.8, 0.6],
                1: [2.6, 2.9, 3.1, 2.9, 2.6, 2.1, 1.6, 1.2, 0.8],
                2: [2.5, 3.0, 3.3, 3.4, 3.1, 2.5, 2.0, 1.5, 1.0],
            },
        },
    },
    4: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 0.9, 0.7],
                1: [0.3, 0.4, 0.5, 0.7, 0.8, 0.8, 0.7, 0.6, 0.5],
                2: [0.2, 0.3, 0.4, 0.5, 0.5, 0.5, 0.5, 0.4, 0.3],
            },
            "1 _ _": {
                0: [0.6, 0.8, 1.1, 1.4, 1.7, 1.8, 1.7, 1.5, 1.2],
                1: [0.5, 0.7, 1.0, 1.2, 1.4, 1.5, 1.4, 1.2, 0.9],
                2: [0.4, 0.5, 0.7, 0.9, 1.0, 1.0, 0.9, 0.7, 0.6],
            },
            "_ 2 _": {
                0: [0.5, 0.7, 0.9, 1.2, 1.4, 1.5, 1.5, 1.3, 1.1],
                1: [0.5, 0.7, 1.0, 1.2, 1.5, 1.5, 1.4, 1.2, 0.9],
                2: [0.5, 0.7, 1.0, 1.2, 1.4, 1.4, 1.2, 1.0, 0.7],
            },
            "_ _ 3": {
                0: [0.4, 0.6, 0.8, 1.0, 1.2, 1.3, 1.3, 1.2, 1.0],
                1: [0.6, 0.9, 1.1, 1.4, 1.6, 1.6, 1.4, 1.2, 0.9],
                2: [0.6, 0.9, 1.2, 1.4, 1.6, 1.6, 1.4, 1.1, 0.8],
            },
            "1 2 _": {
                0: [0.7, 1.0, 1.4, 1.8, 2.1, 2.3, 2.3, 2.1, 1.8],
                1: [0.8, 1.1, 1.5, 1.9, 2.3, 2.4, 2.3, 2.0, 1.6],
                2: [0.7, 1.0, 1.4, 1.7, 2.0, 2.1, 1.9, 1.6, 1.2],
            },
            "1 _ 3": {
                0: [0.5, 0.8, 1.0, 1.4, 1.7, 2.0, 2.1, 1.9, 1.7],
                1: [0.8, 1.1, 1.4, 1.8, 2.1, 2.2, 2.1, 1.8, 1.5],
                2: [0.8, 1.1, 1.5, 1.8, 2.1, 2.2, 2.0, 1.7, 1.3],
            },
            "_ 2 3": {
                0: [0.5, 0.7, 1.0, 1.3, 1.6, 1.8, 1.8, 1.7, 1.5],
                1: [0.6, 0.9, 1.2, 1.5, 1.7, 1.9, 1.9, 1.7, 1.4],
                2: [0.9, 1.2, 1.6, 2.0, 2.4, 2.5, 2.3, 1.9, 1.5],
            },
            "1 2 3": {
                0: [0.7, 1.0, 1.4, 1.8, 2.2, 2.6, 2.8, 2.7, 2.4],
                1: [1.0, 1.4, 1.9, 2.4, 2.9, 3.1, 3.2, 2.9, 2.4],
                2: [1.2, 1.7, 2.3, 2.9, 3.4, 3.6, 3.4, 2.9, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.0, 1.1, 1.2, 1.1, 0.9, 0.6, 0.4, 0.3],
                1: [0.5, 0.7, 0.8, 0.9, 0.8, 0.6, 0.5, 0.3, 0.2],
                2: [0.3, 0.4, 0.5, 0.6, 0.5, 0.4, 0.3, 0.2, 0.2],
            },
            "1 _ _": {
                0: [1.4, 1.7, 1.9, 1.9, 1.7, 1.3, 1.0, 0.7, 0.5],
                1: [1.0, 1.3, 1.5, 1.6, 1.4, 1.1, 0.8, 0.6, 0.4],
                2: [0.7, 0.8, 1.0, 1.1, 1.0, 0.8, 0.6, 0.4, 0.3],
            },
            "_ 2 _": {
                0: [1.2, 1.4, 1.6, 1.6, 1.4, 1.1, 0.8, 0.5, 0.4],
                1: [1.1, 1.3, 1.5, 1.6, 1.4, 1.2, 0.9, 0.6, 0.4],
                2: [0.9, 1.1, 1.4, 1.5, 1.4, 1.1, 0.9, 0.6, 0.4],
            },
            "_ _ 3": {
                0: [1.1, 1.3, 1.4, 1.4, 1.1, 0.9, 0.6, 0.4, 0.3],
                1: [1.0, 1.3, 1.6, 1.7, 1.6, 1.3, 1.0, 0.7, 0.5],
                2: [1.0, 1.3, 1.6, 1.7, 1.6, 1.3, 1.0, 0.7, 0.5],
            },
            "1 2 _": {
                0: [2.0, 2.3, 2.5, 2.4, 2.0, 1.6, 1.1, 0.8, 0.5],
                1: [1.8, 2.2, 2.5, 2.5, 2.2, 1.8, 1.3, 0.9, 0.6],
                2: [1.4, 1.8, 2.1, 2.2, 2.0, 1.6, 1.2, 0.8, 0.6],
            },
            "1 _ 3": {
                0: [1.8, 2.1, 2.1, 2.0, 1.6, 1.2, 0.9, 0.6, 0.4],
                1: [1.7, 2.0, 2.2, 2.3, 2.1, 1.7, 1.3, 0.9, 0.6],
                2: [1.5, 1.9, 2.2, 2.3, 2.1, 1.7, 1.3, 0.9, 0.6],
            },
            "_ 2 3": {
                0: [1.7, 1.9, 1.9, 1.8, 1.5, 1.1, 0.8, 0.6, 0.4],
                1: [1.6, 1.8, 2.0, 1.9, 1.7, 1.4, 1.0, 0.7, 0.5],
                2: [1.7, 2.1, 2.5, 2.6, 2.3, 1.9, 1.4, 1.0, 0.7],
            },
            "1 2 3": {
                0: [2.6, 2.8, 2.8, 2.6, 2.1, 1.6, 1.1, 0.8, 0.5],
                1: [2.7, 3.2, 3.3, 3.2, 2.8, 2.2, 1.6, 1.1, 0.7],
                2: [2.6, 3.2, 3.6, 3.7, 3.3, 2.6, 1.9, 1.4, 0.9],
            },
        },
    },
    5: {
        "top": {
            "_ _ _": {
                0: [0.4, 0.5, 0.7, 1.0, 1.2, 1.3, 1.1, 0.9, 0.7],
                1: [0.3, 0.4, 0.6, 0.7, 0.9, 0.9, 0.8, 0.6, 0.5],
                2: [0.2, 0.3, 0.4, 0.5, 0.6, 0.6, 0.5, 0.4, 0.3],
            },
            "1 _ _": {
                0: [0.5, 0.8, 1.1, 1.5, 1.9, 2.0, 1.9, 1.6, 1.2],
                1: [0.5, 0.7, 1.0, 1.3, 1.6, 1.7, 1.5, 1.2, 0.9],
                2: [0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.0, 0.8, 0.6],
            },
            "_ 2 _": {
                0: [0.4, 0.6, 0.9, 1.2, 1.5, 1.7, 1.6, 1.4, 1.1],
                1: [0.5, 0.7, 1.0, 1.3, 1.6, 1.7, 1.5, 1.2, 0.9],
                2: [0.5, 0.7, 1.0, 1.3, 1.6, 1.6, 1.3, 1.0, 0.7],
            },
            "_ _ 3": {
                0: [0.3, 0.5, 0.7, 1.0, 1.3, 1.5, 1.5, 1.3, 1.1],
                1: [0.6, 0.8, 1.1, 1.5, 1.8, 1.8, 1.5, 1.2, 0.9],
                2: [0.6, 0.8, 1.2, 1.5, 1.8, 1.8, 1.5, 1.1, 0.8],
            },
            "1 2 _": {
                0: [0.6, 0.9, 1.3, 1.8, 2.3, 2.6, 2.5, 2.3, 1.8],
                1: [0.7, 1.1, 1.5, 2.0, 2.5, 2.7, 2.5, 2.1, 1.6],
                2: [0.7, 1.0, 1.4, 1.8, 2.2, 2.3, 2.1, 1.6, 1.2],
            },
            "1 _ 3": {
                0: [0.5, 0.7, 1.0, 1.4, 1.8, 2.2, 2.3, 2.1, 1.7],
                1: [0.7, 1.0, 1.4, 1.9, 2.3, 2.4, 2.3, 1.9, 1.5],
                2: [0.7, 1.1, 1.5, 1.9, 2.4, 2.5, 2.2, 1.7, 1.3],
            },
            "_ 2 3": {
                0: [0.4, 0.7, 1.0, 1.3, 1.7, 1.9, 2.0, 1.9, 1.6],
                1: [0.6, 0.8, 1.2, 1.5, 1.9, 2.1, 2.1, 1.8, 1.4],
                2: [0.8, 1.1, 1.6, 2.1, 2.6, 2.8, 2.5, 2.0, 1.4],
            },
            "1 2 3": {
                0: [0.6, 0.9, 1.3, 1.8, 2.4, 2.8, 3.0, 2.9, 2.5],
                1: [0.9, 1.3, 1.9, 2.5, 3.1, 3.5, 3.5, 3.1, 2.5],
                2: [1.1, 1.6, 2.2, 3.0, 3.7, 4.0, 3.7, 3.0, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.1, 1.3, 1.3, 1.2, 0.9, 0.6, 0.4, 0.3],
                1: [0.5, 0.7, 0.9, 1.0, 0.9, 0.7, 0.5, 0.3, 0.2],
                2: [0.3, 0.4, 0.6, 0.6, 0.6, 0.4, 0.3, 0.2, 0.1],
            },
            "1 _ _": {
                0: [1.4, 1.8, 2.1, 2.1, 1.8, 1.3, 0.9, 0.6, 0.4],
                1: [1.1, 1.4, 1.7, 1.8, 1.5, 1.2, 0.8, 0.5, 0.3],
                2: [0.6, 0.9, 1.1, 1.2, 1.1, 0.8, 0.6, 0.4, 0.2],
            },
            "_ 2 _": {
                0: [1.2, 1.6, 1.8, 1.8, 1.5, 1.1, 0.7, 0.5, 0.3],
                1: [1.1, 1.4, 1.7, 1.8, 1.6, 1.2, 0.8, 0.5, 0.3],
                2: [0.8, 1.2, 1.5, 1.7, 1.6, 1.2, 0.8, 0.6, 0.4],
            },
            "_ _ 3": {
                0: [1.2, 1.5, 1.6, 1.5, 1.2, 0.9, 0.6, 0.4, 0.2],
                1: [1.0, 1.4, 1.7, 2.0, 1.8, 1.4, 1.0, 0.6, 0.4],
                2: [0.9, 1.3, 1.7, 2.0, 1.9, 1.4, 1.0, 0.7, 0.4],
            },
            "1 2 _": {
                0: [2.1, 2.5, 2.7, 2.6, 2.2, 1.6, 1.1, 0.7, 0.4],
                1: [1.9, 2.4, 2.8, 2.8, 2.4, 1.8, 1.2, 0.8, 0.5],
                2: [1.4, 1.9, 2.3, 2.5, 2.2, 1.6, 1.1, 0.8, 0.5],
            },
            "1 _ 3": {
                0: [1.9, 2.3, 2.4, 2.2, 1.7, 1.2, 0.8, 0.5, 0.3],
                1: [1.7, 2.2, 2.5, 2.6, 2.3, 1.7, 1.2, 0.8, 0.5],
                2: [1.5, 2.0, 2.4, 2.6, 2.4, 1.8, 1.2, 0.8, 0.5],
            },
            "_ 2 3": {
                0: [1.8, 2.1, 2.1, 2.0, 1.6, 1.1, 0.8, 0.5, 0.3],
                1: [1.6, 2.0, 2.2, 2.1, 1.9, 1.4, 1.0, 0.6, 0.4],
                2: [1.7, 2.3, 2.8, 3.0, 2.6, 1.9, 1.3, 0.9, 0.6],
            },
            "1 2 3": {
                0: [2.8, 3.1, 3.1, 2.8, 2.2, 1.5, 1.0, 0.7, 0.4],
                1: [2.9, 3.4, 3.7, 3.5, 3.0, 2.2, 1.5, 1.0, 0.6],
                2: [2.7, 3.4, 4.0, 4.2, 3.6, 2.7, 1.8, 1.2, 0.8],
            },
        },
    },
    6: {
        "top": {
            "_ _ _": {
                0: [0.3, 0.5, 0.7, 1.0, 1.3, 1.4, 1.3, 1.0, 0.7],
                1: [0.2, 0.4, 0.5, 0.8, 1.0, 1.1, 0.9, 0.7, 0.4],
                2: [0.2, 0.3, 0.4, 0.5, 0.7, 0.7, 0.5, 0.4, 0.2],
            },
            "1 _ _": {
                0: [0.5, 0.7, 1.1, 1.6, 2.1, 2.3, 2.1, 1.7, 1.2],
                1: [0.4, 0.6, 0.9, 1.3, 1.8, 1.9, 1.7, 1.3, 0.9],
                2: [0.3, 0.5, 0.7, 1.0, 1.3, 1.3, 1.1, 0.8, 0.5],
            },
            "_ 2 _": {
                0: [0.4, 0.6, 0.9, 1.3, 1.7, 1.9, 1.8, 1.5, 1.1],
                1: [0.4, 0.6, 1.0, 1.4, 1.8, 2.0, 1.7, 1.3, 0.9],
                2: [0.4, 0.7, 1.0, 1.4, 1.8, 1.8, 1.4, 1.0, 0.7],
            },
            "_ _ 3": {
                0: [0.3, 0.5, 0.7, 1.0, 1.4, 1.7, 1.7, 1.4, 1.1],
                1: [0.5, 0.8, 1.1, 1.6, 2.0, 2.1, 1.6, 1.3, 0.9],
                2: [0.5, 0.8, 1.2, 1.6, 2.1, 2.1, 1.6, 1.1, 0.7],
            },
            "1 2 _": {
                0: [0.5, 0.8, 1.3, 1.8, 2.5, 2.9, 2.8, 2.4, 1.9],
                1: [0.6, 1.0, 1.5, 2.1, 2.8, 3.1, 2.8, 2.2, 1.6],
                2: [0.6, 0.9, 1.3, 1.9, 2.5, 2.6, 2.3, 1.7, 1.1],
            },
            "1 _ 3": {
                0: [0.4, 0.6, 0.9, 1.4, 1.9, 2.4, 2.6, 2.3, 1.8],
                1: [0.6, 0.9, 1.4, 2.0, 2.6, 2.8, 2.5, 2.1, 1.5],
                2: [0.6, 1.0, 1.4, 2.0, 2.7, 2.8, 2.4, 1.8, 1.2],
            },
            "_ 2 3": {
                0: [0.4, 0.6, 0.9, 1.3, 1.8, 2.2, 2.3, 2.1, 1.7],
                1: [0.5, 0.8, 1.1, 1.6, 2.1, 2.3, 2.3, 1.9, 1.5],
                2: [0.7, 1.0, 1.6, 2.2, 2.9, 3.2, 2.7, 2.0, 1.4],
            },
            "1 2 3": {
                0: [0.5, 0.8, 1.2, 1.8, 2.5, 3.1, 3.4, 3.2, 2.7],
                1: [0.8, 1.2, 1.8, 2.6, 3.4, 3.9, 3.9, 3.3, 2.6],
                2: [0.9, 1.4, 2.2, 3.1, 4.1, 4.5, 4.1, 3.2, 2.3],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.1, 1.4, 1.6, 1.3, 0.9, 0.6, 0.3, 0.2],
                1: [0.5, 0.8, 1.0, 1.2, 1.0, 0.7, 0.4, 0.3, 0.2],
                2: [0.3, 0.4, 0.6, 0.8, 0.7, 0.5, 0.3, 0.2, 0.1],
            },
            "1 _ _": {
                0: [1.4, 1.9, 2.3, 2.4, 2.0, 1.3, 0.8, 0.5, 0.3],
                1: [1.0, 1.5, 1.9, 2.1, 1.7, 1.1, 0.7, 0.4, 0.3],
                2: [0.6, 0.9, 1.2, 1.5, 1.3, 0.8, 0.5, 0.3, 0.2],
            },
            "_ 2 _": {
                0: [1.3, 1.7, 2.0, 2.0, 1.6, 1.1, 0.7, 0.4, 0.2],
                1: [1.1, 1.5, 1.9, 2.1, 1.8, 1.2, 0.8, 0.5, 0.3],
                2: [0.8, 1.2, 1.6, 2.0, 1.8, 1.2, 0.8, 0.5, 0.3],
            },
            "_ _ 3": {
                0: [1.2, 1.6, 1.8, 1.7, 1.3, 0.8, 0.5, 0.3, 0.2],
                1: [1.0, 1.4, 1.9, 2.3, 2.1, 1.4, 0.9, 0.5, 0.3],
                2: [0.9, 1.3, 1.9, 2.4, 2.2, 1.4, 0.9, 0.6, 0.3],
            },
            "1 2 _": {
                0: [2.2, 2.7, 3.1, 3.0, 2.3, 1.5, 0.9, 0.6, 0.3],
                1: [1.9, 2.6, 3.1, 3.3, 2.7, 1.8, 1.1, 0.7, 0.4],
                2: [1.4, 2.0, 2.6, 2.9, 2.5, 1.6, 1.0, 0.6, 0.4],
            },
            "1 _ 3": {
                0: [2.0, 2.5, 2.7, 2.4, 1.7, 1.1, 0.7, 0.4, 0.2],
                1: [1.8, 2.4, 2.8, 3.0, 2.6, 1.7, 1.1, 0.7, 0.4],
                2: [1.4, 2.1, 2.7, 3.1, 2.7, 1.8, 1.1, 0.7, 0.4],
            },
            "_ 2 3": {
                0: [1.9, 2.3, 2.4, 2.2, 1.7, 1.1, 0.7, 0.4, 0.2],
                1: [1.7, 2.2, 2.5, 2.5, 2.1, 1.4, 0.9, 0.5, 0.3],
                2: [1.6, 2.4, 3.1, 3.5, 2.9, 1.9, 1.2, 0.7, 0.4],
            },
            "1 2 3": {
                0: [3.0, 3.5, 3.6, 3.1, 2.2, 1.4, 0.9, 0.5, 0.3],
                1: [3.0, 3.8, 4.2, 4.0, 3.3, 2.2, 1.4, 0.8, 0.5],
                2: [2.7, 3.7, 4.5, 4.9, 4.0, 2.6, 1.7, 1.0, 0.6],
            },
        },
    },
    7: {
        "top": {
            "_ _ _": {
                0: [0.2, 0.4, 0.7, 1.0, 1.5, 1.7, 1.4, 1.0, 0.6],
                1: [0.2, 0.3, 0.5, 0.8, 1.2, 1.3, 1.0, 0.6, 0.4],
                2: [0.1, 0.2, 0.4, 0.5, 0.8, 0.8, 0.6, 0.3, 0.2],
            },
            "1 _ _": {
                0: [0.4, 0.6, 1.0, 1.6, 2.4, 2.7, 2.3, 1.7, 1.2],
                1: [0.3, 0.5, 0.9, 1.4, 2.0, 2.3, 1.8, 1.3, 0.8],
                2: [0.2, 0.4, 0.6, 1.0, 1.5, 1.6, 1.2, 0.7, 0.4],
            },
            "_ 2 _": {
                0: [0.3, 0.5, 0.8, 1.2, 1.9, 2.3, 2.0, 1.5, 1.1],
                1: [0.3, 0.6, 0.9, 1.4, 2.1, 2.3, 1.8, 1.3, 0.8],
                2: [0.3, 0.6, 0.9, 1.4, 2.1, 2.2, 1.5, 0.9, 0.6],
            },
            "_ _ 3": {
                0: [0.2, 0.4, 0.6, 1.0, 1.5, 2.0, 1.9, 1.5, 1.1],
                1: [0.4, 0.7, 1.1, 1.6, 2.4, 2.5, 1.8, 1.3, 0.8],
                2: [0.4, 0.7, 1.1, 1.7, 2.5, 2.5, 1.7, 1.1, 0.6],
            },
            "1 2 _": {
                0: [0.4, 0.7, 1.1, 1.8, 2.7, 3.4, 3.2, 2.6, 1.9],
                1: [0.5, 0.8, 1.3, 2.1, 3.2, 3.6, 3.1, 2.3, 1.6],
                2: [0.4, 0.8, 1.2, 1.9, 2.9, 3.2, 2.5, 1.7, 1.0],
            },
            "1 _ 3": {
                0: [0.3, 0.5, 0.8, 1.3, 2.0, 2.8, 3.0, 2.5, 1.8],
                1: [0.5, 0.8, 1.3, 2.0, 3.1, 3.3, 2.9, 2.2, 1.5],
                2: [0.5, 0.8, 1.4, 2.1, 3.1, 3.4, 2.6, 1.7, 1.1],
            },
            "_ 2 3": {
                0: [0.3, 0.5, 0.8, 1.3, 2.0, 2.5, 2.6, 2.3, 1.7],
                1: [0.4, 0.7, 1.1, 1.6, 2.5, 2.8, 2.7, 2.1, 1.4],
                2: [0.5, 0.9, 1.5, 2.3, 3.4, 3.9, 3.1, 2.0, 1.2],
            },
            "1 2 3": {
                0: [0.4, 0.6, 1.1, 1.7, 2.6, 3.5, 3.9, 3.6, 2.8],
                1: [0.6, 1.0, 1.6, 2.6, 3.9, 4.5, 4.4, 3.6, 2.6],
                2: [0.7, 1.2, 2.0, 3.1, 4.7, 5.4, 4.5, 3.3, 2.1],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.8, 1.2, 1.6, 1.9, 1.5, 0.8, 0.4, 0.2, 0.1],
                1: [0.5, 0.8, 1.1, 1.4, 1.2, 0.6, 0.3, 0.2, 0.1],
                2: [0.2, 0.4, 0.7, 1.0, 0.8, 0.4, 0.2, 0.1, 0.1],
            },
            "1 _ _": {
                0: [1.4, 2.0, 2.6, 3.0, 2.3, 1.2, 0.7, 0.4, 0.2],
                1: [1.0, 1.5, 2.1, 2.5, 2.0, 1.1, 0.6, 0.3, 0.2],
                2: [0.5, 0.9, 1.4, 1.8, 1.5, 0.8, 0.4, 0.2, 0.1],
            },
            "_ 2 _": {
                0: [1.3, 1.8, 2.3, 2.4, 1.8, 0.9, 0.5, 0.3, 0.1],
                1: [1.0, 1.5, 2.1, 2.6, 2.1, 1.1, 0.6, 0.3, 0.2],
                2: [0.7, 1.1, 1.8, 2.6, 2.2, 1.1, 0.7, 0.4, 0.2],
            },
            "_ _ 3": {
                0: [1.3, 1.8, 2.2, 2.0, 1.5, 0.8, 0.4, 0.2, 0.1],
                1: [1.0, 1.5, 2.1, 2.9, 2.5, 1.3, 0.7, 0.4, 0.2],
                2: [0.8, 1.3, 2.0, 3.0, 2.6, 1.4, 0.8, 0.4, 0.2],
            },
            "1 2 _": {
                0: [2.2, 3.0, 3.6, 3.5, 2.5, 1.3, 0.8, 0.4, 0.2],
                1: [1.9, 2.7, 3.6, 4.0, 3.0, 1.6, 0.9, 0.5, 0.3],
                2: [1.2, 2.0, 2.9, 3.6, 2.9, 1.5, 0.8, 0.5, 0.2],
            },
            "1 _ 3": {
                0: [2.1, 2.8, 3.3, 2.8, 1.7, 0.9, 0.5, 0.3, 0.1],
                1: [1.8, 2.6, 3.2, 3.7, 3.1, 1.6, 0.9, 0.5, 0.3],
                2: [1.3, 2.1, 3.0, 3.8, 3.1, 1.6, 0.9, 0.5, 0.3],
            },
            "_ 2 3": {
                0: [2.0, 2.6, 2.9, 2.6, 1.7, 0.9, 0.5, 0.3, 0.1],
                1: [1.7, 2.4, 3.0, 3.0, 2.5, 1.3, 0.7, 0.4, 0.2],
                2: [1.5, 2.4, 3.6, 4.3, 3.3, 1.7, 1.0, 0.5, 0.3],
            },
            "1 2 3": {
                0: [3.3, 4.0, 4.1, 3.5, 2.3, 1.2, 0.7, 0.4, 0.2],
                1: [3.1, 4.2, 4.9, 4.8, 3.7, 2.0, 1.1, 0.6, 0.3],
                2: [2.6, 3.9, 5.2, 5.9, 4.5, 2.4, 1.3, 0.7, 0.4],
            },
        },
    },
    8: {
        "top": {
            "_ _ _": {
                0: [0.2, 0.3, 0.6, 1.0, 1.9, 2.2, 1.5, 0.9, 0.6],
                1: [0.1, 0.2, 0.4, 0.7, 1.4, 1.6, 1.0, 0.6, 0.3],
                2: [0.1, 0.2, 0.3, 0.5, 1.0, 1.1, 0.6, 0.3, 0.1],
            },
            "1 _ _": {
                0: [0.2, 0.4, 0.8, 1.5, 2.8, 3.4, 2.6, 1.7, 1.0],
                1: [0.2, 0.4, 0.7, 1.3, 2.4, 2.9, 2.0, 1.2, 0.7],
                2: [0.2, 0.3, 0.5, 1.0, 1.8, 2.1, 1.3, 0.7, 0.3],
            },
            "_ 2 _": {
                0: [0.2, 0.4, 0.6, 1.1, 2.2, 2.8, 2.3, 1.6, 1.0],
                1: [0.2, 0.4, 0.8, 1.3, 2.5, 2.9, 2.0, 1.2, 0.7],
                2: [0.2, 0.4, 0.8, 1.4, 2.7, 2.8, 1.5, 0.8, 0.4],
            },
            "_ _ 3": {
                0: [0.2, 0.3, 0.5, 0.9, 1.8, 2.4, 2.3, 1.6, 1.0],
                1: [0.3, 0.5, 0.9, 1.6, 3.1, 3.2, 2.0, 1.3, 0.7],
                2: [0.3, 0.5, 0.9, 1.6, 3.2, 3.3, 1.7, 0.9, 0.4],
            },
            "1 2 _": {
                0: [0.3, 0.5, 0.9, 1.6, 3.1, 4.1, 3.7, 2.8, 1.8],
                1: [0.3, 0.6, 1.1, 2.0, 3.7, 4.5, 3.5, 2.4, 1.4],
                2: [0.3, 0.6, 1.0, 1.8, 3.5, 4.0, 2.7, 1.6, 0.8],
            },
            "1 _ 3": {
                0: [0.2, 0.3, 0.6, 1.1, 2.1, 3.3, 3.6, 2.8, 1.8],
                1: [0.3, 0.6, 1.1, 2.0, 3.8, 4.2, 3.3, 2.3, 1.4],
                2: [0.3, 0.6, 1.1, 2.0, 3.8, 4.3, 2.8, 1.6, 0.8],
            },
            "_ 2 3": {
                0: [0.2, 0.3, 0.6, 1.1, 2.1, 3.1, 3.2, 2.6, 1.7],
                1: [0.3, 0.5, 0.9, 1.6, 3.0, 3.4, 3.2, 2.2, 1.3],
                2: [0.3, 0.7, 1.2, 2.1, 4.0, 4.9, 3.5, 1.9, 1.0],
            },
            "1 2 3": {
                0: [0.2, 0.4, 0.8, 1.5, 2.8, 4.1, 4.6, 4.0, 3.0],
                1: [0.4, 0.7, 1.4, 2.4, 4.6, 5.6, 5.2, 3.9, 2.6],
                2: [0.5, 0.9, 1.6, 2.9, 5.6, 6.8, 5.1, 3.3, 1.9],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.7, 1.1, 1.8, 2.5, 1.8, 0.6, 0.3, 0.1, 0.1],
                1: [0.4, 0.7, 1.2, 1.9, 1.4, 0.5, 0.2, 0.1, 0.0],
                2: [0.2, 0.4, 0.7, 1.3, 1.1, 0.3, 0.2, 0.1, 0.0],
            },
            "1 _ _": {
                0: [1.3, 2.1, 3.1, 3.8, 2.6, 0.9, 0.4, 0.2, 0.1],
                1: [0.8, 1.5, 2.4, 3.4, 2.4, 0.8, 0.4, 0.2, 0.1],
                2: [0.4, 0.8, 1.6, 2.5, 1.8, 0.6, 0.3, 0.1, 0.1],
            },
            "_ 2 _": {
                0: [1.2, 1.9, 2.7, 3.1, 2.0, 0.7, 0.3, 0.1, 0.1],
                1: [0.8, 1.5, 2.4, 3.4, 2.5, 0.8, 0.4, 0.2, 0.1],
                2: [0.5, 1.0, 1.9, 3.5, 2.8, 0.9, 0.4, 0.2, 0.1],
            },
            "_ _ 3": {
                0: [1.2, 1.9, 2.7, 2.5, 1.7, 0.6, 0.3, 0.1, 0.1],
                1: [0.9, 1.5, 2.4, 3.9, 3.2, 1.0, 0.5, 0.2, 0.1],
                2: [0.5, 1.1, 2.1, 4.1, 3.4, 1.0, 0.5, 0.2, 0.1],
            },
            "1 2 _": {
                0: [2.2, 3.3, 4.2, 4.4, 2.8, 0.9, 0.4, 0.2, 0.1],
                1: [1.7, 2.9, 4.1, 5.1, 3.5, 1.1, 0.5, 0.3, 0.1],
                2: [1.0, 2.0, 3.3, 4.7, 3.5, 1.1, 0.5, 0.2, 0.1],
            },
            "1 _ 3": {
                0: [2.2, 3.2, 4.1, 3.3, 1.8, 0.6, 0.3, 0.1, 0.1],
                1: [1.7, 2.7, 3.9, 4.9, 3.8, 1.2, 0.6, 0.3, 0.1],
                2: [1.0, 2.0, 3.4, 5.1, 3.8, 1.2, 0.6, 0.3, 0.1],
            },
            "_ 2 3": {
                0: [2.1, 3.0, 3.6, 3.3, 1.8, 0.6, 0.3, 0.1, 0.1],
                1: [1.6, 2.6, 3.7, 4.0, 3.0, 0.9, 0.4, 0.2, 0.1],
                2: [1.2, 2.3, 4.2, 5.8, 3.9, 1.3, 0.6, 0.3, 0.1],
            },
            "1 2 3": {
                0: [3.5, 4.6, 5.0, 4.2, 2.2, 0.8, 0.4, 0.2, 0.1],
                1: [3.1, 4.6, 5.9, 6.2, 4.4, 1.4, 0.7, 0.3, 0.1],
                2: [2.3, 4.0, 6.1, 7.7, 5.3, 1.7, 0.8, 0.4, 0.2],
            },
        },
    },
    9: {
        "top": {
            "_ _ _": {
                0: [0.1, 0.2, 0.3, 0.7, 2.4, 2.9, 1.6, 0.8, 0.4],
                1: [0.1, 0.1, 0.3, 0.6, 1.9, 2.2, 1.0, 0.5, 0.2],
                2: [0.0, 0.1, 0.2, 0.4, 1.4, 1.5, 0.5, 0.2, 0.1],
            },
            "1 _ _": {
                0: [0.1, 0.2, 0.5, 1.1, 3.4, 4.6, 2.9, 1.6, 0.8],
                1: [0.1, 0.2, 0.5, 1.0, 3.1, 3.9, 2.2, 1.0, 0.4],
                2: [0.1, 0.2, 0.3, 0.7, 2.4, 2.9, 1.3, 0.4, 0.1],
            },
            "_ 2 _": {
                0: [0.1, 0.2, 0.4, 0.8, 2.6, 3.7, 2.7, 1.5, 0.8],
                1: [0.1, 0.2, 0.5, 1.0, 3.3, 4.0, 2.2, 1.0, 0.5],
                2: [0.1, 0.2, 0.5, 1.1, 3.7, 4.0, 1.4, 0.5, 0.2],
            },
            "_ _ 3": {
                0: [0.1, 0.2, 0.3, 0.7, 2.3, 3.1, 2.9, 1.6, 0.8],
                1: [0.1, 0.3, 0.6, 1.2, 4.3, 4.4, 2.3, 1.1, 0.5],
                2: [0.1, 0.3, 0.6, 1.3, 4.4, 4.6, 1.4, 0.5, 0.2],
            },
            "1 2 _": {
                0: [0.1, 0.3, 0.6, 1.2, 3.6, 5.3, 4.4, 2.9, 1.6],
                1: [0.1, 0.3, 0.7, 1.4, 4.6, 6.1, 4.0, 2.3, 1.1],
                2: [0.1, 0.3, 0.7, 1.4, 4.5, 5.5, 2.9, 1.3, 0.4],
            },
            "1 _ 3": {
                0: [0.1, 0.2, 0.4, 0.8, 2.3, 4.2, 4.6, 3.0, 1.7],
                1: [0.1, 0.3, 0.7, 1.5, 5.0, 5.7, 4.0, 2.3, 1.1],
                2: [0.2, 0.3, 0.7, 1.5, 5.0, 5.9, 2.9, 1.3, 0.4],
            },
            "_ 2 3": {
                0: [0.1, 0.2, 0.4, 0.8, 2.4, 4.0, 4.0, 2.9, 1.6],
                1: [0.1, 0.3, 0.6, 1.2, 3.9, 4.6, 3.9, 2.3, 1.1],
                2: [0.2, 0.3, 0.7, 1.6, 5.1, 6.9, 3.9, 1.4, 0.5],
            },
            "1 2 3": {
                0: [0.1, 0.2, 0.5, 1.0, 2.9, 5.2, 5.7, 4.6, 3.1],
                1: [0.2, 0.4, 0.8, 1.8, 5.7, 7.3, 6.2, 4.2, 2.4],
                2: [0.2, 0.5, 1.0, 2.1, 6.9, 9.1, 5.7, 3.1, 1.4],
            },
        },
        "bot": {
            "_ _ _": {
                0: [0.5, 1.0, 2.0, 3.6, 2.3, 0.0, 0.0, 0.0, 0.0],
                1: [0.2, 0.6, 1.3, 2.8, 1.9, 0.0, 0.0, 0.0, 0.0],
                2: [0.1, 0.2, 0.6, 1.9, 1.5, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ _": {
                0: [1.0, 2.0, 3.6, 5.4, 3.1, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 1.3, 2.8, 4.8, 3.0, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.5, 1.7, 3.7, 2.4, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 _": {
                0: [1.0, 1.9, 3.3, 4.3, 2.5, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 1.3, 2.7, 5.0, 3.2, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.6, 1.8, 5.2, 3.9, 0.0, 0.0, 0.0, 0.0],
            },
            "_ _ 3": {
                0: [1.1, 2.0, 3.6, 3.5, 2.1, 0.0, 0.0, 0.0, 0.0],
                1: [0.6, 1.4, 2.9, 5.8, 4.5, 0.0, 0.0, 0.0, 0.0],
                2: [0.2, 0.7, 1.8, 6.1, 4.7, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 _": {
                0: [2.0, 3.6, 5.2, 6.0, 3.2, 0.0, 0.0, 0.0, 0.0],
                1: [1.3, 2.9, 4.8, 7.2, 4.3, 0.0, 0.0, 0.0, 0.0],
                2: [0.6, 1.7, 3.7, 6.8, 4.4, 0.0, 0.0, 0.0, 0.0],
            },
            "1 _ 3": {
                0: [2.1, 3.7, 5.5, 4.3, 2.1, 0.0, 0.0, 0.0, 0.0],
                1: [1.4, 2.9, 4.9, 7.1, 5.0, 0.0, 0.0, 0.0, 0.0],
                2: [0.6, 1.7, 3.7, 7.4, 5.0, 0.0, 0.0, 0.0, 0.0],
            },
            "_ 2 3": {
                0: [2.0, 3.5, 4.7, 4.3, 2.0, 0.0, 0.0, 0.0, 0.0],
                1: [1.4, 2.8, 4.8, 5.7, 4.0, 0.0, 0.0, 0.0, 0.0],
                2: [0.7, 1.8, 5.1, 8.4, 4.7, 0.0, 0.0, 0.0, 0.0],
            },
            "1 2 3": {
                0: [3.7, 5.4, 6.4, 5.3, 2.4, 0.0, 0.0, 0.0, 0.0],
                1: [3.0, 5.1, 7.3, 8.6, 5.4, 0.0, 0.0, 0.0, 0.0],
                2: [1.8, 3.9, 7.0, 10.9, 6.4, 0.0, 0.0, 0.0, 0.0],
            },
        },
    },
}

class sessionClass {
  // Initialize the class
  constructor(argv = {}) {
    this.debug = argv.debug

    let dirname = __dirname
    if ( argv.data_directory ) {
      dirname = argv.data_directory
    }

    // Define some file paths and names
    this.DATA_DIRECTORY = path.join(dirname, 'data')
    this.CACHE_DIRECTORY = path.join(dirname, 'cache')

    this.CREDENTIALS_FILE = path.join(dirname, 'credentials.json')
    this.PROTECTION_FILE = path.join(dirname, 'protection.json')
    this.COOKIE_FILE = path.join(this.DATA_DIRECTORY, 'cookies.json')
    this.DATA_FILE = path.join(this.DATA_DIRECTORY, 'data.json')
    this.CACHE_FILE = path.join(this.CACHE_DIRECTORY, 'cache.json')

    // Read credentials from file, if present
    this.credentials = this.readFileToJson(this.CREDENTIALS_FILE) || {}

    // Check if account credentials were provided and if they are different from the stored credentials
    if ( argv.account_username && argv.account_password && ((argv.account_username != this.credentials.account_username) || (argv.account_password != this.credentials.account_password)) ) {
      this.log('updating account credentials')
      this.credentials.account_username = argv.account_username
      this.credentials.account_password = argv.account_password
      this.save_credentials()
      this.clear_session_data()
    } else {
      // Prompt for credentials if they don't exist
      if ( !this.credentials.account_username || !this.credentials.account_password ) {
        this.debuglog('prompting for account credentials')
        this.credentials.account_username = readlineSync.question('Enter account username (email address): ')
        this.credentials.account_password = readlineSync.question('Enter account password: ', { hideEchoBack: true })
        this.save_credentials()
        this.clear_session_data()
      }
    }

    // If page username/password protection is specified, retrieve or generate a random string of random length
    // to protect non-page content (streams, playlists, guides, images)
    this.protection = {}
    if ( argv.page_username && argv.page_password ) {
      // Read protection data from file, if present
      this.protection = this.readFileToJson(this.PROTECTION_FILE) || {}

      // Check if content_protect key was provided and if it is different from the stored one
      if ( argv.content_protect && (argv.content_protect != this.protection.content_protect) ) {
        this.log('using specified content protection key')
        this.log('you may need to update any content URLs you have copied outside of mlbserver')
        this.protection.content_protect = argv.content_protect
      } else {
        // Generate a content_protect key if it doesn't exist
        if ( !this.protection.content_protect ) {
          this.log('generating new content protection key')
          this.log('** YOU WILL NEED TO UPDATE ANY CONTENT URLS YOU HAVE COPIED OUTSIDE OF MLBSERVER **')
          this.protection.content_protect = this.getRandomString(this.getRandomInteger(32,64))
          this.save_protection()
        }
      }
    }

    // Create storage directory if it doesn't already exist
    this.createDirectory(this.DATA_DIRECTORY)

    // Set multiview path
    if ( argv.multiview_path ) {
      this.multiview_path = path.join(argv.multiview_path, path.basename(dirname))
      this.createDirectory(this.multiview_path)
      this.multiview_path = path.join(this.multiview_path, MULTIVIEW_DIRECTORY_NAME)
    } else {
      this.multiview_path = path.join(dirname, MULTIVIEW_DIRECTORY_NAME)
    }
    this.createDirectory(this.multiview_path)

    // Create cookie storage file if it doesn't already exist
    this.createFile(this.COOKIE_FILE)
    // Verify its contents are valid
    let cookieStr = fs.readFileSync(this.COOKIE_FILE)
    if ( (cookieStr != '') && !this.isValidJson(cookieStr) ) {
      this.log('invalid cookie storage file contents, resetting')
      fs.unlinkSync(this.COOKIE_FILE)
      this.createFile(this.COOKIE_FILE)
    }

    // Set up http requests with the cookie jar
    this.request = require('request-promise')
    this.jar = this.request.jar(new FileCookieStore(this.COOKIE_FILE))
    this.request = this.request.defaults({timeout:15000, agent:false, jar: this.request.jar()})

    // Load session data and cache from files
    this.data = this.readFileToJson(this.DATA_FILE) || {}
    this.cache = this.readFileToJson(this.CACHE_FILE) || {}

    // Define empty temporary cache (for skip, gamechanger, and key data)
    this.temp_cache = {}
    // Store previous keys, for return without retrieval
    this.temp_cache.prevKeys = {}

    // Default scan_mode and linkType values
    if ( !this.data.scan_mode ) {
      this.setScanMode('on')
    }
    if ( !this.data.linkType ) {
      this.setLinkType('embed')
    }

    // Check if zip code was provided and if it is different from the stored one
    if ( argv.zip_code ) {
      let zip_code_arg = argv.zip_code.toString().toUpperCase()
      if ( zip_code_arg == 'TRUE' ) {
        zip_code_arg = ''
      }
      if ( (typeof(this.credentials.zip_code) === 'undefined') || (zip_code_arg != this.credentials.zip_code) ) {
        this.log('updating zip code and blackout teams')
        this.credentials.zip_code = zip_code_arg
        this.updateBlackoutTeams()
      }
    } else {
      // Prompt for zip code if it doesn't exist
      if ( typeof(this.credentials.zip_code) === 'undefined' ) {
        this.debuglog('prompting for zip code')
        this.credentials.zip_code = readlineSync.question('Enter 5-digit zip code (optional, for USA blackout labels): ').toString()
        this.updateBlackoutTeams()
      }
    }

    // Check if fav teams was provided and if they are different from the stored fav teams
    if ( argv.fav_teams ) {
      let fav_teams_arg = argv.fav_teams.toString().toUpperCase()
      if ( fav_teams_arg == 'TRUE' ) {
        fav_teams_arg = []
      } else {
        fav_teams_arg = fav_teams_arg.replace(/[^A-Z,]+/g,'').split(',')
      }
      if ( (typeof(this.credentials.fav_teams) === 'undefined') || (fav_teams_arg.toString() != this.credentials.fav_teams.toString()) ) {
        this.log('updating fav teams')
        this.credentials.fav_teams = fav_teams_arg
        this.save_credentials()
      }
    } else {
      // Prompt for fav_teams
      if ( typeof(this.credentials.fav_teams) === 'undefined' ) {
        this.debuglog('prompting for fav teams')
        let team_abbreviations = Object.keys(TEAM_IDS)
        this.credentials.fav_teams = readlineSync.question('Enter favorite team(s) (optional, separate by comma from ' + team_abbreviations.join() + '): ').toUpperCase().replace(/[^A-Z,]+/g,'').split(',')
        this.save_credentials()
      }
    }

    // Check if free account
    this.free = false
    if (argv.free) {
      this.debuglog('labeling free games')
      this.free = true
    }

    // Check if extra gamechanger delay is specified
    this.gamechanger_delay = 0
    if (argv.gamechanger_delay && Number.isInteger(parseInt(argv.gamechanger_delay))) {
      this.gamechanger_delay = Math.round(parseInt(argv.gamechanger_delay) / 10) * 10
      this.debuglog('adding ' + this.gamechanger_delay + ' seconds extra delay to gamechanger')
    }
  }

  // Store the ports, used for generating URLs
  setPorts(port, multiviewPort) {
    this.data.port = port
    this.data.multiviewPort = multiviewPort
    this.save_session_data()
  }

  // Set the scan_mode
  // "on" will return the sample stream for all live channels.m3u stream requests
  setScanMode(x) {
    this.log('scan_mode set to ' + x)
    this.data.scan_mode = x
    this.save_session_data()
  }

  // Set the linkType
  // used for storing the desired page type across throughout site navigation
  setLinkType(x) {
    this.data.linkType = x
    this.save_session_data()
  }

  // Set the multiview stream URL path
  setMultiviewStreamURLPath(url_path) {
    this.data.multiviewStreamURLPath = url_path
    this.save_session_data()
  }

  // Some basic self-explanatory functions
  createDirectory(directoryPath) {
    if (fs.existsSync(directoryPath) && !fs.lstatSync(directoryPath).isDirectory() ){
      fs.unlinkSync(directoryPath);
    }
    if (!fs.existsSync(directoryPath)){
      fs.mkdirSync(directoryPath);
    }
  }

  createFile(filePath) {
    if (!fs.existsSync(filePath)) {
      fs.closeSync(fs.openSync(filePath, 'w'))
    }
  }

  isValidJson(str) {
    try {
      JSON.parse(str);
    } catch (e) {
      return false;
    }
    return true;
  }

  readFileToJson(filePath) {
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath))
    }
  }

  writeJsonToFile(jsonStr, filePath) {
    if (this.isValidJson(jsonStr)) {
      fs.writeFileSync(filePath, jsonStr)
    }
  }

  checkValidItem(item, obj) {
    if (obj.includes(item)) {
      return true
    }
    return false
  }

  returnValidItem(item, obj) {
    if (!obj.includes(item)) return obj[0]
    else return item
  }

  sortObj(obj) {
    return Object.keys(obj).sort().reduce(function (result, key) {
      result[key] = obj[key];
      return result;
    }, {});
  }

  localTimeString() {
    let curDate = new Date()
    return curDate.toLocaleString()
  }

  getTodayUTCHours() {
    return TODAY_UTC_HOURS
  }

  getUserAgent() {
    return USER_AGENT
  }

  // the live date is today's date, or if before a specified hour (UTC time), then use yesterday's date
  liveDate(hour = TODAY_UTC_HOURS) {
    let curDate = new Date()
    if ( curDate.getUTCHours() < hour ) {
      curDate.setDate(curDate.getDate()-1)
    }
    return curDate.toISOString().substring(0,10)
  }

  yesterdayDate() {
    let curDate = new Date(this.liveDate())
    curDate.setDate(curDate.getDate()-1)
    return curDate.toISOString().substring(0,10)
  }

  convertDateToXMLTV(x) {
    let newDate = String(x.getFullYear()) + String(x.getMonth() + 1).padStart(2, '0') + String(x.getDate()).padStart(2, '0') + String(x.getHours()).padStart(2, '0') + String(x.getMinutes()).padStart(2, '0') + String(x.getSeconds()).padStart(2, '0') + " "
    let offset = x.getTimezoneOffset()
    if ( offset > 0 ) {
      newDate += "-"
    } else {
      newDate += "+"
    }
    newDate += String((offset / 60)).padStart(2, '0') + "00"
    return newDate
  }

  getCacheUpdatedDate(dateString) {
    return this.cache.dates[dateString].updated
  }

  setHighlightsCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.highlights ) {
      this.cache.highlights={}
    }
    if ( !this.cache.highlights[cache_name] ) {
      this.cache.highlights[cache_name] = {}
    }
    this.cache.highlights[cache_name].highlightsCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setDateCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.dates ) {
      this.cache.dates={}
    }
    if ( !this.cache.dates[cache_name] ) {
      this.cache.dates[cache_name] = {}
    }
    this.cache.dates[cache_name].dateCacheExpiry = expiryDate
    this.cache.dates[cache_name].updated = this.localTimeString()
    this.save_cache_data()
  }

  setAiringsCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.airings ) {
      this.cache.airings={}
    }
    if ( !this.cache.airings[cache_name] ) {
      this.cache.airings[cache_name] = {}
    }
    this.cache.airings[cache_name].airingsCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setGamedayCacheExpiry(cache_name, expiryDate) {
    if ( !this.cache.gameday ) {
      this.cache.gameday={}
    }
    if ( !this.cache.gameday[cache_name] ) {
      this.cache.gameday[cache_name] = {}
    }
    this.cache.gameday[cache_name].gamedayCacheExpiry = expiryDate
    this.save_cache_data()
  }

  setBreakExpiry(id, game_pk) {
    let currentDate = new Date()
    currentDate.setSeconds(currentDate.getSeconds()+109)
    this.temp_cache.gamechanger[id].break_expiries[game_pk] = currentDate
  }

  createContentCache(contentId) {
    if ( !this.cache.content ) {
      this.cache.content = {}
    }
    if ( !this.cache.content[contentId] ) {
      this.cache.content[contentId] = {}
    }
  }

  createMediaCache(mediaId) {
    if ( !this.cache.media ) {
      this.cache.media = {}
    }
    if ( !this.cache.media[mediaId] ) {
      this.cache.media[mediaId] = {}
    }
  }

  cacheMediaId(contentId, mediaId, alternateAudioTracks) {
    this.createContentCache(contentId)
    this.cache.content[contentId].mediaId = mediaId
    this.cache.content[contentId].alternateAudioTracks = JSON.stringify(alternateAudioTracks)
    this.save_cache_data()
  }

  cacheGamePk(contentId, gamePk) {
    this.createContentCache(contentId)
    this.cache.content[contentId].gamePk = gamePk
    this.save_cache_data()
  }

  cacheStreamURL(mediaId, streamURL) {
    this.createMediaCache(mediaId)
    this.cache.media[mediaId].streamURL = streamURL
    // Expire it in 1 minute
    let seconds_to_expire = 60
    this.cache.media[mediaId].streamURLExpiry = new Date(new Date().getTime() + seconds_to_expire * 1000)
    this.save_cache_data()
  }

  markBlackoutError(mediaId) {
    this.createMediaCache(mediaId)
    this.log('saving blackout error to prevent repeated access attempts')
    this.cache.media[mediaId].blackout = true
    // Expire it in 1 hour
    let seconds_to_expire = 60*60
    this.cache.media[mediaId].blackoutExpiry = new Date(new Date().getTime() + seconds_to_expire * 1000)
    this.save_cache_data()
  }

  log(msg) {
    console.log(this.localTimeString() + ' ' + msg)
  }

  debuglog(msg) {
    if (this.debug) this.log(msg)
  }

  requestlog(type, req, debug=false) {
    if ( req.url ) {
      let msg = type + ' request : ' + req.url
      if ( req.connection && req.connection.remoteAddress ) msg += ' from: ' + req.connection.remoteAddress
      if ( req.headers && req.headers['user-agent'] ) msg += ' using: ' + req.headers['user-agent']
      if (!debug || this.debug) this.log(msg)
    }
  }

  halt(msg) {
    this.log(msg)
    process.exit(1)
  }

  logout() {
    try {
      fs.unlinkSync(this.CREDENTIALS_FILE)
    } catch(e){
      this.debuglog('credentials cannot be cleared or do not exist yet : ' + e.message)
    }
  }

  clear_session_data() {
    try {
      fs.unlinkSync(this.COOKIE_FILE)
      fs.unlinkSync(this.DATA_FILE)
    } catch(e){
      this.debuglog('session cannot be cleared or does not exist yet : ' + e.message)
    }
  }

  clear_cache() {
    try {
      fs.unlinkSync(this.CACHE_FILE)
    } catch(e){
      this.debuglog('cache cannot be cleared or does not exist yet : ' + e.message)
    }
  }

  get_multiview_directory() {
    return this.multiview_path
  }

  clear_multiview_files() {
    try {
      if ( this.multiview_path ) {
        fs.readdir(this.multiview_path, (err, files) => {
          if (err) throw err

          for (const file of files) {
            fs.unlink(path.join(this.multiview_path, file), err => {
              if (err) throw err
            })
          }
        })
      }
    } catch(e){
      this.debuglog('clear multiview files error : ' + e.message)
    }
  }

  save_credentials() {
    this.writeJsonToFile(JSON.stringify(this.credentials), this.CREDENTIALS_FILE)
    this.debuglog('credentials saved to file')
  }

  save_protection() {
    this.writeJsonToFile(JSON.stringify(this.protection), this.PROTECTION_FILE)
    this.debuglog('protection data saved to file')
  }

  save_session_data() {
    this.createDirectory(this.DATA_DIRECTORY)
    this.writeJsonToFile(JSON.stringify(this.data), this.DATA_FILE)
    this.debuglog('session data saved to file')
  }

  save_cache_data() {
    this.createDirectory(this.CACHE_DIRECTORY)
    this.writeJsonToFile(JSON.stringify(this.cache), this.CACHE_FILE)
    this.debuglog('cache data saved to file')
  }

  save_json_cache_file(cache_name, cache_data) {
    this.createDirectory(this.CACHE_DIRECTORY)
    this.writeJsonToFile(JSON.stringify(cache_data), path.join(this.CACHE_DIRECTORY, cache_name+'.json'))
    this.debuglog('cache file saved')
  }

  // Generate a random integer in a range
  getRandomInteger(min, max) {
    return Math.floor(Math.random() * (max - min) ) + min;
  }

  // Generate a random string of specified length
  getRandomString(length) {
    var s = ''
    do {
      s += Math.random().toString(36).substr(2);
    } while (s.length < length)
    s = s.substr(0, length)

    return s
  }

  // Generic http GET request function
  httpGet(reqObj, exit=true) {
    reqObj.jar = this.jar
    return new Promise((resolve, reject) => {
      this.request.get(reqObj)
      .then(function(body) {
        resolve(body)
      })
      .catch(function(e) {
        console.log('http get failed : ' + e.message)
        console.log(reqObj)
        if ( exit ) {
          process.exit(1)
        } else {
          resolve(false)
        }
      })
    })
  }

  // Generic http POST request function
  httpPost(reqObj) {
    reqObj.jar = this.jar
    return new Promise((resolve, reject) => {
      this.request.post(reqObj)
      .then(function(body) {
        resolve(body)
      })
      .catch(function(e) {
        console.log('http post failed : ' + e.message)
        console.log(reqObj)
        process.exit(1)
      })
    })
  }

  // request to use when fetching videos
  streamVideo(u, opts, tries, cb) {
    opts.jar = this.jar
    opts.headers = {
      'Authorization': this.data.bamAccessToken,
      'User-Agent': USER_AGENT
    }
    if ( opts.referer ) {
      opts.headers['Referer'] = opts.referer
      delete opts.headers.Authorization
    }
    if ( opts.origin ) {
      opts.headers['Origin'] = opts.origin
    }
    this.request(u, opts, cb)
    .catch(function(e) {
      let curDate = new Date()
      console.log(curDate.toLocaleString() + ' stream video failed on url : ' + u)
      console.log(curDate.toLocaleString() + ' stream video failed with error : ' + e.message.toString())
      if ( tries == 0 ) process.exit(1)
    })
  }

  async getXApiKey() {
    this.debuglog('getXApiKey')
    if ( !this.data.xApiKey || !this.data.xApiKey ) {
      await this.getApiKeys()
      if ( this.data.xApiKey ) return this.data.xApiKey
    } else {
      return this.data.xApiKey
    }
  }

  async getClientApiKey() {
    this.debuglog('getClientApiKey')
    if ( !this.data.clientApiKey ) {
      await this.getApiKeys()
      if ( this.data.clientApiKey ) return this.data.clientApiKey
    } else {
      return this.data.clientApiKey
    }
  }

  // API call
  async getApiKeys() {
    this.debuglog('getApiKeys')
    let reqObj = {
      url: 'https://www.mlb.com/tv/g632102/',
      headers: {
        'User-agent': USER_AGENT,
        'Origin': 'https://www.mlb.com',
        'Accept-Encoding': 'gzip, deflate, br'
      },
      gzip: true
    }
    var response = await this.httpGet(reqObj)
    if ( response ) {
      // disabled because it's very big!
      //this.debuglog('getApiKeys response : ' + response)
      var parsed = response.match('"x-api-key","value":"([^"]+)"')
      if ( parsed[1] ) {
        this.data.xApiKey = parsed[1]
        this.save_session_data()
      } else {
        this.log('getApiKeys xApiKey parse failure')
      }
      parsed = response.match('"clientApiKey":"([^"]+)"')
      if ( parsed[1] ) {
        this.data.clientApiKey = parsed[1]
        this.save_session_data()
      } else {
        this.log('getApiKeys clientApiKey parse failure')
      }
    } else {
      this.log('getApiKeys response failure')
    }
  }

  // API call
  async getOktaClientId() {
    this.debuglog('getOktaClientId')
    if ( !this.data.oktaClientId ) {
      this.debuglog('need to get oktaClientId')
      let reqObj = {
        url: 'https://www.mlbstatic.com/mlb.com/vendor/mlb-okta/mlb-okta.js',
        headers: {
          'User-agent': USER_AGENT,
          'Origin': 'https://www.mlb.com',
          'Accept-Encoding': 'gzip, deflate, br'
        },
        gzip: true
      }
      var response = await this.httpGet(reqObj)
      if ( response ) {
        // disabled because it's very big!
        //this.debuglog('getOktaClientId response : ' + response)
        var parsed = response.match('production:{clientId:"([^"]+)",')
        if ( parsed[1] ) {
          this.data.oktaClientId = parsed[1]
          this.save_session_data()
          return this.data.oktaClientId
        } else {
          this.log('getOktaClientId parse failure')
        }
      } else {
        this.log('getOktaClientId response failure')
      }
    } else {
      return this.data.oktaClientId
    }
  }

  // API call
  async getMediaIdFromContentId(gamePk, contentId) {
    this.debuglog('getMediaIdFromContentId from ' + gamePk + ' and ' + contentId)
    if ( this.cache.content && this.cache.content[contentId] && this.cache.content[contentId].mediaId ) {
      this.debuglog('using cached mediaId')
      let mediaId = this.cache.content[contentId].mediaId
      let alternateAudioTracks = {}
      if ( this.cache.content[contentId].alternateAudioTracks ) {
        alternateAudioTracks = JSON.parse(this.cache.content[contentId].alternateAudioTracks)
      }
      return { mediaId, alternateAudioTracks }
    } else {
      let cache_data = await this.getAiringsData('', gamePk)
      if ( cache_data.data && cache_data.data.Airings && (cache_data.data.Airings.length > 0) ) {
        let mediaId
        let feedType
        let mediaType
        let broadcast_count = 0
        let alternateAudioTracks = {}
        for (var i=0; i<cache_data.data.Airings.length; i++) {
          if ( cache_data.data.Airings[i].contentId == contentId ) {
            mediaId = cache_data.data.Airings[i].mediaId
            feedType = cache_data.data.Airings[i].feedType
            mediaType = cache_data.data.Airings[i].mediaConfig.type
          }
          if ( cache_data.data.Airings[i].mediaConfig.type == 'VIDEO' ) {
            broadcast_count++
          }
        }
        if ( mediaId ) {
          // add alternate audio tracks, if necessary
          if ( mediaType == 'VIDEO' && (broadcast_count == 1) ) {
            if ( feedType == 'National' ) {
              feedType = 'Home'
            }
            for (var i=0; i<cache_data.data.Airings.length; i++) {
              if ( (cache_data.data.Airings[i].mediaConfig.type == 'AUDIO') && (cache_data.data.Airings[i].feedType != feedType) ) {
                if ( cache_data.data.Airings[i].feedLanguage == 'en' ) {
                  alternateAudioTracks.English = cache_data.data.Airings[i].mediaId
                } else if ( cache_data.data.Airings[i].feedLanguage == 'es' ) {
                  alternateAudioTracks.Spanish = cache_data.data.Airings[i].mediaId
                }
              }
            }
          }

          this.cacheMediaId(contentId, mediaId, alternateAudioTracks)
          return { mediaId, alternateAudioTracks }
        }
      }
    }
  }

  // API call
  async getGamePkFromContentId(contentId) {
    this.debuglog('getGamePkFromContentId from ' + contentId)
    if ( this.cache.content && this.cache.content[contentId] && this.cache.content[contentId].gamePk ) {
      this.debuglog('using cached gamePk')
      return this.cache.content[contentId].gamePk
    } else {
      let cache_data = await this.getAiringsData(contentId)
      let gamePk = cache_data.data.Airings[0].partnerProgramId
      this.cacheGamePk(contentId, gamePk)
      return gamePk
    }
  }

  // API call
  async getStreamURL(mediaId) {
    this.debuglog('getStreamURL from ' + mediaId)
    if ( this.cache.media && this.cache.media[mediaId] && this.cache.media[mediaId].streamURL && this.cache.media[mediaId].streamURLExpiry && (Date.parse(this.cache.media[mediaId].streamURLExpiry) > new Date()) ) {
      this.debuglog('using cached streamURL')
      return this.cache.media[mediaId].streamURL
    } else if ( this.cache.media && this.cache.media[mediaId] && this.cache.media[mediaId].blackout && this.cache.media[mediaId].blackoutExpiry && (Date.parse(this.cache.media[mediaId].blackoutExpiry) > new Date()) ) {
      this.log('mediaId recently blacked out, skipping')
    } else {
      let playbackURL = 'https://edge.svcs.mlb.com/media/' + mediaId + '/scenarios/browser~csai'
      let reqObj = {
        url: playbackURL,
        simple: false,
        headers: {
          'Authorization': await this.getBamAccessToken() || this.halt('missing bamAccessToken'),
          'User-agent': USER_AGENT,
          'Accept': 'application/vnd.media-service+json; version=1',
          'x-bamsdk-version': BAM_SDK_VERSION,
          'x-bamsdk-platform': PLATFORM,
          'Origin': 'https://www.mlb.com',
          'Accept-Encoding': 'gzip, deflate, br',
          'Content-type': 'application/json'
        },
        gzip: true
      }
      var response = await this.httpGet(reqObj)
      if ( response && this.isValidJson(response) ) {
        this.debuglog('getStreamURL response : ' + response)
        let obj = JSON.parse(response)
        if ( obj.errors && (obj.errors[0] == 'blackout') ) {
          this.log('blackout error')
          this.markBlackoutError(mediaId)
        } else {
          let streamURL = obj.stream.complete
          this.debuglog('getStreamURL : ' + streamURL)
          this.cacheStreamURL(mediaId, streamURL)
          return streamURL
        }
      } else {
        this.log('getStreamURL response failure')
      }
    }
  }

  // API call
  async getBamAccessToken() {
    this.debuglog('getBamAccessToken')
    if ( !this.data.bamAccessToken || !this.data.bamAccessTokenExpiry || (Date.parse(this.data.bamAccessTokenExpiry) < new Date()) ) {
      this.debuglog('need to get new bamAccessToken')
      let reqObj = {
        url: BAM_TOKEN_URL,
        headers: {
          'Authorization': 'Bearer ' + await this.getClientApiKey() || this.halt('missing clientApiKey'),
          'User-agent': USER_AGENT,
          'Accept': 'application/vnd.media-service+json; version=1',
          'x-bamsdk-version': BAM_SDK_VERSION,
          'x-bamsdk-platform': PLATFORM,
          'Origin': 'https://www.mlb.com',
          'Accept-Encoding': 'gzip, deflate, br',
          'Content-type': 'application/json'
        },
        form: {
          'grant_type': 'urn:ietf:params:oauth:grant-type:token-exchange',
          'platform': 'browser',
          'subject_token': await this.getEntitlementToken() || this.halt('missing EntitlementToken'),
          'subject_token_type': 'urn:bamtech:params:oauth:token-type:account'
        },
        gzip: true
      }
      var response = await this.httpPost(reqObj)
      if ( this.isValidJson(response) ) {
        let obj = JSON.parse(response)
        this.debuglog('getBamAccessToken : ' + obj.access_token)
        this.debuglog('getBamAccessToken expires in : ' + obj.expires_in)
        this.data.bamAccessToken = obj.access_token
        this.data.bamAccessTokenExpiry = new Date(new Date().getTime() + obj.expires_in * 1000)
        this.save_session_data()
        return this.data.bamAccessToken
      } else {
        this.log('getBamAccessToken response failure')
      }
    } else {
      return this.data.bamAccessToken
    }
  }

  // API call
  async getEntitlementToken() {
    this.debuglog('getEntitlementToken')
    let reqObj = {
      url: 'https://media-entitlement.mlb.com/api/v3/jwt',
      headers: {
        'Authorization': 'Bearer ' + await this.getOktaAccessToken() || this.halt('missing OktaAccessToken'),
        'Origin': 'https://www.mlb.com',
        'x-api-key': await this.getXApiKey() || this.halt('missing xApiKey'),
        'Accept-Encoding': 'gzip, deflate, br'
      },
      qs: {
        'os': PLATFORM,
        'did': await this.getDeviceId() || this.halt('missing deviceId'),
        'appname': 'mlbtv_web'
      },
      gzip: true
    }
    var response = await this.httpGet(reqObj)
    if ( response ) {
      this.debuglog('getEntitlementToken response : ' + response)
      this.debuglog('getEntitlementToken : ' + response)
      return response
    } else {
      this.log('getEntitlementToken response failure')
    }
  }

  async getDeviceId() {
    this.debuglog('getDeviceId')
    let reqObj = {
      url: 'https://us.edge.bamgrid.com/session',
      headers: {
        'Authorization': await this.getDeviceAccessToken() || this.halt('missing device_access_token'),
        'User-agent': USER_AGENT,
        'Origin': 'https://www.mlb.com',
        'Accept': 'application/vnd.session-service+json; version=1',
        'Accept-Encoding': 'gzip, deflate, br',
        'Accept-Language': 'en-US,en;q=0.5',
        'x-bamsdk-version': BAM_SDK_VERSION,
        'x-bamsdk-platform': PLATFORM,
        'Content-type': 'application/json',
        'TE': 'Trailers'
      },
      gzip: true
    }
    var response = await this.httpGet(reqObj)
    if ( response && this.isValidJson(response) ) {
      this.debuglog('getDeviceId response : ' + response)
      let obj = JSON.parse(response)
      this.debuglog('getDeviceId : ' + obj.device.id)
      return obj.device.id
    } else {
      this.log('getDeviceId response failure')
    }
  }

  // API call
  async getDeviceAccessToken() {
    this.debuglog('getDeviceAccessToken')
    let reqObj = {
      url: BAM_TOKEN_URL,
      headers: {
        'Authorization': 'Bearer ' + await this.getClientApiKey() || this.halt('missing clientApiKey'),
        'Origin': 'https://www.mlb.com'
      },
      form: {
        'grant_type': 'urn:ietf:params:oauth:grant-type:token-exchange',
        'latitude': '0',
        'longitude': '0',
        'platform': 'browser',
        'subject_token': await this.getDevicesAssertion() || this.halt('missing devicesAssertion'),
        'subject_token_type': 'urn:bamtech:params:oauth:token-type:device'
      }
    }
    var response = await this.httpPost(reqObj)
    if ( this.isValidJson(response) ) {
      this.debuglog('getDeviceAccessToken response : ' + response)
      let obj = JSON.parse(response)
      this.debuglog('getDeviceAccessToken : ' + obj.access_token)
      return obj.access_token
    } else {
      this.log('getDeviceAccessToken response failure')
    }
  }

  // API call
  async getDevicesAssertion() {
    this.debuglog('getDevicesAssertion')
    let reqObj = {
      url: 'https://us.edge.bamgrid.com/devices',
      headers: {
        'Authorization': 'Bearer ' + await this.getClientApiKey() || this.halt('missing clientApiKey'),
        'Origin': 'https://www.mlb.com'
      },
      json: {
        'applicationRuntime': 'firefox',
        'attributes': {},
        'deviceFamily': 'browser',
        'deviceProfile': 'macosx'
      }
    }
    var response = await this.httpPost(reqObj)
    if ( response.assertion ) {
      this.debuglog('getDevicesAssertion response : ' + JSON.stringify(response))
      this.debuglog('getDevicesAssertion : ' + response.assertion)
      return response.assertion
    } else {
      this.log('getDevicesAssertion response failure')
    }
  }

  async getOktaAccessToken() {
    this.debuglog('getOktaAccessToken')
    let oktaAccessToken = await this.retrieveOktaAccessToken()
    if ( oktaAccessToken ) return oktaAccessToken
    else {
      oktaAccessToken = await this.retrieveOktaAccessToken()
      if ( oktaAccessToken ) return oktaAccessToken
    }
  }

  // API call
  async retrieveOktaAccessToken() {
    this.debuglog('retrieveOktaAccessToken')
    if ( !this.data.oktaAccessToken || !this.data.oktaAccessTokenExpiry || (Date.parse(this.data.oktaAccessTokenExpiry) < new Date()) ) {
      this.debuglog('need to get new oktaAccessToken')
      let state = this.getRandomString(64)
      let nonce = this.getRandomString(64)
      let reqObj = {
        url: 'https://ids.mlb.com/oauth2/aus1m088yK07noBfh356/v1/authorize',
        headers: {
          'user-agent': USER_AGENT,
          'accept-encoding': 'identity'
        },
        qs: {
          'client_id': await this.getOktaClientId() || this.halt('missing oktaClientId'),
          'redirect_uri': 'https://www.mlb.com/login',
          'response_type': 'id_token token',
          'response_mode': 'okta_post_message',
          'state': state,
          'nonce': nonce,
          'prompt': 'none',
          'sessionToken': await this.getAuthnSessionToken() || this.halt('missing authnSessionToken'),
          'scope': 'openid email'
        }
      }
      var response = await this.httpGet(reqObj)
      if ( response ) {
        var str = response.toString()
        this.debuglog('retrieveOktaAccessToken response : ' + str)
        if ( str.match ) {
          var errorParsed = str.match("data.error = 'login_required'")
          if ( errorParsed ) {
            // Need to log in again
            this.log('Logging in...')
            delete this.data.authnSessionToken
            this.save_session_data()
          } else {
            var parsed_token = str.match("data.access_token = '([^']+)'")
            var parsed_expiry = str.match("data.expires_in = '([^']+)'")
            if ( parsed_token && parsed_token[1] && parsed_expiry && parsed_expiry[1] ) {
              let oktaAccessToken = parsed_token[1].split('\\x2D').join('-')
              let oktaAccessTokenExpiry = parsed_expiry[1]
              this.debuglog('retrieveOktaAccessToken : ' + oktaAccessToken)
              this.debuglog('retrieveOktaAccessToken expires in : ' + oktaAccessTokenExpiry)
              this.data.oktaAccessToken = oktaAccessToken
              this.data.oktaAccessTokenExpiry = new Date(new Date().getTime() + oktaAccessTokenExpiry * 1000)
              this.save_session_data()
              return this.data.oktaAccessToken
            } else {
              this.log('retrieveOktaAccessToken parse failure')
            }
          }
        } else {
          this.log('retrieveOktaAccessToken string response failure')
        }
      } else {
        this.log('retrieveOktaAccessToken response failure')
      }
    } else {
      return this.data.oktaAccessToken
    }
  }

  // API call
  async getAuthnSessionToken() {
    this.debuglog('getAuthnSessionToken')
    if ( !this.data.authnSessionToken ) {
      this.debuglog('need to get authnSessionToken')
      let reqObj = {
        url: 'https://ids.mlb.com/api/v1/authn',
        headers: {
          'user-agent': USER_AGENT,
          'accept-encoding': 'identity',
          'content-type': 'application/json'
        },
        json: {
          'username': this.credentials.account_username || this.halt('missing account username'),
          'password': this.credentials.account_password || this.halt('missing account password'),
          'options': {
            'multiOptionalFactorEnroll': false,
            'warnBeforePasswordExpired': true
          }
        }
      }
      var response = await this.httpPost(reqObj)
      if ( response.sessionToken ) {
        this.debuglog('getAuthnSessionToken response : ' + JSON.stringify(response))
        this.debuglog('getAuthnSessionToken : ' + response.sessionToken)
        this.data.authnSessionToken = response.sessionToken
        this.save_session_data()
        return this.data.authnSessionToken
      } else {
        this.log('getAuthnSessionToken response failure')
      }
    } else {
      this.debuglog('using cached authnSessionToken')
      return this.data.authnSessionToken
    }
  }

  // get mediaId for a live channel request
  async getMediaId(team, mediaType, mediaDate, gameNumber, includeBlackouts) {
    try {
      this.debuglog('getMediaId')

      var mediaFeedType = 'mediaFeedType'
      var language = 'en'
      if ( mediaType == 'Video' ) {
        mediaType = 'MLBTV'
      } else if ( (mediaType == 'Audio') || (mediaType == 'Spanish') ) {
        mediaFeedType = 'type'
        if ( mediaType == 'Spanish' ) {
          mediaType = 'Audio'
          language = 'es'
        }
      }

      let today = this.liveDate()
      let gameDate = today
      if ( mediaDate == 'yesterday' ) {
        gameDate = this.yesterdayDate()
      } else if ( (mediaDate) && (mediaDate != 'today') ) {
        gameDate = mediaDate
      }

      if ( gameDate <= today ) {
        // no blackouts on previous days
        if ( gameDate < today ) {
          includeBlackouts = 'true'
        }

        let mediaInfo = {}

        let cache_data
        let cache_name = gameDate
        let cache_file = path.join(this.CACHE_DIRECTORY, gameDate+'.json')
        let currentDate = new Date()
        cache_data = await this.getDayData(gameDate)

        if ( cache_data ) {
          let nationalCount = 0
          let freeCount = 0
          let blackouts = {}
          if ( includeBlackouts == 'false' ) blackouts = await this.get_blackout_games(cache_data.dates[0].games, true)

          for (var j = 0; j < cache_data.dates[0].games.length; j++) {
            if ( mediaInfo.mediaId ) break

            // check blackout status, if necessary
            let gamePk = cache_data.dates[0].games[j].gamePk.toString()
            if ( (mediaType == 'MLBTV') && (includeBlackouts == 'false') && blackouts[gamePk] ) {
              if ( !blackouts[gamePk].blackoutExpiry || (currentDate < blackouts[gamePk].blackoutExpiry) ) {
                this.debuglog('getMediaId requested game is blacked out')
                continue
              }
            }

            if ( (typeof cache_data.dates[0].games[j] !== 'undefined') && cache_data.dates[0].games[j].content && cache_data.dates[0].games[j].content.media && cache_data.dates[0].games[j].content.media.epg ) {
              let home_team = cache_data.dates[0].games[j].teams['home'].team.abbreviation
              let away_team = cache_data.dates[0].games[j].teams['away'].team.abbreviation

              // check that that game involves the requested team, or if it's a national or free game and we've requested that
              if ( (team.toUpperCase() == home_team) || (team.toUpperCase() == away_team) || ((team.toUpperCase().indexOf('NATIONAL.') == 0) && ((cache_data.dates[0].games[j].content.media.epg[k].items[x][mediaFeedType] == 'NATIONAL') || ((mediaType == 'MLBTV') && (cache_data.dates[0].games[j].seriesDescription != 'Regular Season') && (cache_data.dates[0].games[j].seriesDescription != 'Spring Training')))) || (team.toUpperCase().startsWith('FREE.') && cache_data.dates[0].games[j].content.media.freeGame) ) {

                let teamType
                let broadcast_count = 0
                for (var k = 0; k < cache_data.dates[0].games[j].content.media.epg.length; k++) {
                  if ( mediaInfo.mediaId ) break
                  let mediaTitle = cache_data.dates[0].games[j].content.media.epg[k].title
                  if ( mediaType == mediaTitle ) {
                    // initial loop will count number of broadcasts
                    broadcast_count = await this.count_broadcasts(cache_data.dates[0].games[j].content.media.epg[k].items, mediaType, mediaTitle, language)

                    for (var x = 0; x < cache_data.dates[0].games[j].content.media.epg[k].items.length; x++) {
                      // for video, check that it's not in-market
                      if ( (mediaType == 'MLBTV') && await this.check_in_market(cache_data.dates[0].games[j].content.media.epg[k].items[x]) ) {
                        continue
                      }

                      if ( ((typeof cache_data.dates[0].games[j].content.media.epg[k].items[x].language) == 'undefined') || (cache_data.dates[0].games[j].content.media.epg[k].items[x].language == language) ) {
                        teamType = cache_data.dates[0].games[j].content.media.epg[k].items[x][mediaFeedType]

                        let station = cache_data.dates[0].games[j].content.media.epg[k].items[x].callLetters

                        // process requested national games (with the team/channel NATIONAL.x)
                        if ( (team.toUpperCase().indexOf('NATIONAL.') == 0) && ((cache_data.dates[0].games[j].content.media.epg[k].items[x][mediaFeedType] == 'NATIONAL') || ((mediaType == 'MLBTV') && (cache_data.dates[0].games[j].seriesDescription != 'Regular Season') && (cache_data.dates[0].games[j].seriesDescription != 'Spring Training'))) ) {

                          nationalCount += 1
                          let nationalArray = team.split('.')
                          if ( (nationalArray.length == 2) && (nationalArray[1] == nationalCount) ) {
                            this.debuglog('matched national event')
                            mediaInfo = await this.check_media_state(cache_data.dates[0].games[j].content.media.epg[k].items[x], cache_data.dates[0].games[j].status.abstractGameState, mediaDate)
                            break
                          }

                        // process requested free games (with the team/channel FREE.x)
                        } else if ( team.toUpperCase().startsWith('FREE.') && cache_data.dates[0].games[j].content.media.freeGame ) {

                          freeCount += 1
                          let freeArray = team.split('.')
                          if ( (freeArray.length == 2) && (freeArray[1] == freeCount) ) {
                            this.debuglog('matched free event')
                            mediaInfo = await this.check_media_state(cache_data.dates[0].games[j].content.media.epg[k].items[x], cache_data.dates[0].games[j].status.abstractGameState, mediaDate)
                            break
                          }

                        // process requested team games
                        } else if ( (team.toUpperCase() == home_team) || (team.toUpperCase() == away_team) ) {

                          if ( ((team.toUpperCase() == home_team) && (teamType == 'HOME')) || ((team.toUpperCase() == away_team) && (teamType == 'AWAY')) || (broadcast_count == 1) ) {
                            if ( gameNumber && (gameNumber > 1) ) {
                              this.debuglog('matched team for game number 1')
                              gameNumber--
                            } else {
                              this.debuglog('matched team for event')
                              mediaInfo = await this.check_media_state(cache_data.dates[0].games[j].content.media.epg[k].items[x], cache_data.dates[0].games[j].status.abstractGameState, mediaDate)
                              break
                            }
                          }

                        }
                      }
                    }
                  }
                }

                // grab any alternate audio tracks, if necessary
                if ( mediaInfo.mediaId && (mediaType == 'MLBTV') && (broadcast_count == 1) ) {
                  mediaInfo.alternateAudioTracks = await this.getAlternateAudioTracks(cache_data.dates[0].games[j].content.media.epg, teamType)
                }

              }
            }
          }

          if (mediaInfo.mediaId) {
            return mediaInfo
          }
        }
        this.log('could not find mediaId')
      } else {
        this.log('will not find mediaId for future date')
      }
    } catch(e) {
      this.log('getMediaId error : ' + e.message)
    }
  }

  // get highlights for a game
  async getHighlightsData(gamePk, gameDate) {
    try {
      this.debuglog('getHighlightsData for ' + gamePk)

      let cache_data
      let cache_name = 'h' + gamePk
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.highlights || !this.cache.highlights[cache_name] || !this.cache.highlights[cache_name].highlightsCacheExpiry || (currentDate > new Date(this.cache.highlights[cache_name].highlightsCacheExpiry)) ) {
        let reqObj = {
          url: 'https://statsapi.mlb.com/api/v1/game/' + gamePk + '/content',
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          //this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 hour from now
          let oneHourFromNow = new Date()
          oneHourFromNow.setHours(oneHourFromNow.getHours()+1)
          let cacheExpiry = oneHourFromNow

          let today = this.liveDate()
          let yesterday = this.yesterdayDate()
          if ( gameDate == today ) {
            if ( (cache_data.media) && (cache_data.media.epg) ) {
              for (var i = 0; i < cache_data.media.epg.length; i++) {
                if ( cache_data.media.epg[i].items && cache_data.media.epg[i].items[0] && cache_data.media.epg[i].items[0].mediaState && (cache_data.media.epg[i].items[0].mediaState == 'MEDIA_ON') ) {
                  this.debuglog('setting cache expiry to 5 minute due to in progress games')
                  currentDate.setMinutes(currentDate.getMinutes()+5)
                  cacheExpiry = currentDate
                  break
                }
              }
            }
          } else if ( gameDate < today ) {
            this.debuglog('1+ days old, setting cache expiry to forever')
            cacheExpiry = new Date(8640000000000000)
          }

          // finally save the setting
          this.setHighlightsCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached highlight data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data && cache_data.highlights && cache_data.highlights.highlights && cache_data.highlights.highlights.items) {
        var array = cache_data.highlights.highlights.items
        return array.sort(this.GetSortOrder('date'))
      }
    } catch(e) {
      this.log('getHighlightsData error : ' + e.message)
    }
  }

  GetSortOrder(prop) {
    return function(a, b) {
      if (a[prop] > b[prop]) {
        return 1
      } else if (a[prop] < b[prop]) {
        return -1
      }
      return 0
    }
  }

  GetSortOrderReverse(prop) {
    return function(a, b) {
      if (a[prop] < b[prop]) {
        return 1
      } else if (a[prop] > b[prop]) {
        return -1
      }
      return 0
    }
  }

  // get data for a day, either from cache or an API call
  async getDayData(dateString, team = false) {
    try {
      let cache_data
      let cache_name = dateString
      //let data_url = 'https://bdfed.stitch.mlbinfra.com/bdfed/transform-mlb-scoreboard?stitch_env=prod&sortTemplate=2&sportId=1&sportId=17&startDate=' + dateString + '&endDate=' + dateString + '&gameType=E&&gameType=S&&gameType=R&&gameType=F&&gameType=D&&gameType=L&&gameType=W&&gameType=A&language=en&leagueId=104&leagueId=103&leagueId=131&contextTeamId='
      let data_url = 'http://statsapi.mlb.com/api/v1/schedule?sportId=1&startDate=' + dateString + '&endDate=' + dateString + '&hydrate=game(content(media(epg))),probablePitcher,linescore,team,flags,gameInfo'
      if ( team && !team.toUpperCase().startsWith('NATIONAL.') && !team.toUpperCase().startsWith('FREE.') ) {
        this.debuglog('getDayData for team ' + team + ' on date ' + dateString)
        cache_name = team.toUpperCase() + dateString
        data_url = 'http://statsapi.mlb.com/api/v1/schedule?sportId=1&teamId=' + TEAM_IDS[team.toUpperCase()] + '&startDate=' + dateString + '&endDate=' + dateString + '&hydrate=team,game(content(media(epg)))'
      } else {
        this.debuglog('getDayData for date ' + dateString)
      }
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.dates || !this.cache.dates[cache_name] || !this.cache.dates[cache_name].dateCacheExpiry || (currentDate > new Date(this.cache.dates[cache_name].dateCacheExpiry)) ) {
        let reqObj = {
          url: data_url,
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          //this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 hour from now
          let oneHourFromNow = new Date()
          oneHourFromNow.setHours(oneHourFromNow.getHours()+1)
          let cacheExpiry = oneHourFromNow

          let today = this.liveDate()
          let yesterday = this.yesterdayDate()
          if ( (dateString == today) && cache_data.dates && cache_data.dates[0] && cache_data.dates[0].games && (cache_data.dates[0].games.length > 1) ) {
            let finals = false
            for (var i = 0; i < cache_data.dates[0].games.length; i++) {
              if ( ((cache_data.dates[0].games[i].status.abstractGameState == 'Live') && (cache_data.dates[0].games[i].status.detailedState.indexOf('Suspended') != 0)) || ((cache_data.dates[0].games[i].status.startTimeTBD == true) && (cache_data.dates[0].games[i].status.abstractGameState != 'Final') && (i > 0) && (cache_data.dates[0].games[i-1].status.abstractGameState == 'Final')) ) {
                this.debuglog('setting cache expiry to 1 minute due to in progress games or upcoming TBD game')
                currentDate.setMinutes(currentDate.getMinutes()+1)
                cacheExpiry = currentDate
                break
              } else if ( cache_data.dates[0].games[i].status.abstractGameState == 'Final' ) {
                finals = true
              } else if ( (finals == false) && (cache_data.dates[0].games[i].status.startTimeTBD == false) ) {
                let nextGameDate = new Date(cache_data.dates[0].games[i].gameDate)
                nextGameDate.setHours(nextGameDate.getHours()-1)
                this.debuglog('setting cache expiry to 1 hour before next live game')
                cacheExpiry = nextGameDate
                break
              }
            }
          } else if ( dateString > today ) {
            this.debuglog('1+ days in the future, setting cache expiry to tomorrow')
            let tomorrowDate = new Date(today)
            tomorrowDate.setDate(tomorrowDate.getDate()+1)
            let utcHours = 10
            tomorrowDate.setHours(tomorrowDate.getHours()+utcHours)
            cacheExpiry = tomorrowDate
          } else if ( dateString < yesterday ) {
            this.debuglog('2+ days old, setting cache expiry to forever')
            cacheExpiry = new Date(8640000000000000)
          }

          // finally save the setting
          this.setDateCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached date data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getDayData error : ' + e.message)
    }
  }

  // get data for 3 weeks, either from cache or an API call
  async getWeeksData() {
    try {
      this.debuglog('getWeeksData')

      // use 5 AM UTC time as the threshold to advance 1 day
      let utcHours = 5

      let cache_data
      let cache_name = 'week'
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.weekCacheExpiry || (currentDate > new Date(this.cache.weekCacheExpiry)) ) {
        let startDate = this.liveDate(utcHours)
        let endDate = new Date(startDate)
        endDate.setDate(endDate.getDate()+20)
        endDate = endDate.toISOString().substring(0,10)
        let reqObj = {
          url: 'https://bdfed.stitch.mlbinfra.com/bdfed/transform-mlb-scoreboard?stitch_env=prod&sortTemplate=2&sportId=1&sportId=17&startDate=' + startDate + '&endDate=' + endDate + '&gameType=E&&gameType=S&&gameType=R&&gameType=F&&gameType=D&&gameType=L&&gameType=W&&gameType=A&language=en&leagueId=104&leagueId=103&leagueId=131&contextTeamId=',
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          //this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)
          this.debuglog('setting channels cache expiry to next day')
          let nextDate = new Date(startDate)
          nextDate.setDate(nextDate.getDate()+1)
          nextDate.setHours(nextDate.getHours()+utcHours)
          this.cache.weekCacheExpiry = nextDate
          this.save_cache_data()
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached channel data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getWeeksData error : ' + e.message)
    }
  }

  // get TV data (channels or guide)
  async getTVData(dataType, mediaType, includeTeams, excludeTeams, server, includeBlackouts, resolution='best', pipe='false', startingChannelNumber=1) {
    try {
      this.debuglog('getTVData for ' + dataType)

      var mediaFeedType = 'mediaFeedType'
      var language = 'en'
      if ( mediaType == 'Video' ) {
        mediaType = 'MLBTV'
      } else if ( (mediaType == 'Audio') || (mediaType == 'Spanish') ) {
        mediaFeedType = 'type'
        if ( mediaType == 'Spanish' ) {
          mediaType = 'Audio'
          language = 'es'
        }
      }

      let cache_data = await this.getWeeksData()
      if (cache_data) {
        let today = this.liveDate()
        var channels = {}
        var nationalChannels = {}
        var programs = ""
        let prevDateIndex = {MLBTV:-1,Free:-1,Audio:-1}

        let gameIndexes_obj = {}

        for (var i = 0; i < cache_data.dates.length; i++) {
          let dateIndex = {MLBTV:i,Free:i,Audio:i}
          let gameCounter = {MLBTV:0,Free:0,Audio:0}

          let blackouts = await this.get_blackout_games(cache_data.dates[i].games)
          let gameIndexes = await this.get_first_and_last_games(cache_data.dates[i].games, blackouts)
          // store gameIndexes for gamechanger/multiview reference later
          gameIndexes_obj[cache_data.dates[i].date] = gameIndexes

          for (var j = 0; j < cache_data.dates[i].games.length; j++) {
            // First check if Winter League games
            if ( cache_data.dates[i].games[j].teams['home'].team.sport.name == 'Winter Leagues' ) {
              if ( (excludeTeams.length > 0) && excludeTeams.includes('LIDOM') ) {
                continue
              } else if ( (includeTeams.length == 0) || includeTeams.includes('LIDOM') ) {
                if ( cache_data.dates[i].games[j].broadcasts ) {
                  for (var k = 0; k < cache_data.dates[i].games[j].broadcasts.length; k++) {
                    if ( (mediaType == 'MLBTV') && (cache_data.dates[i].games[j].broadcasts[k].name == 'MLB.TV') ) {
                      let team = cache_data.dates[i].games[j].teams['home'].team.clubName.toUpperCase()
                      let channelid = mediaType + '.' + team
                      let logo = server + '/image.svg?teamId=MLB'
                      let streamMediaType = 'Video'
                      let stream = server + '/stream.m3u8?event=' + encodeURIComponent(team) + '&mediaType=' + streamMediaType
                      stream += '&resolution=' + resolution
                      if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
                      if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
                      channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

                      let title = cache_data.dates[i].games[j].teams['home'].team.league.name + ': ' + cache_data.dates[i].games[j].teams['away'].team.name + ' at ' + cache_data.dates[i].games[j].teams['home'].team.name

                      let description = ''
                      if ( cache_data.dates[i].games[j].doubleHeader != 'N' ) {
                        description += 'Game ' + cache_data.dates[i].games[j].gameNumber + '. '
                      }
                      description += 'In Spanish. From ' + cache_data.dates[i].games[j].teams['home'].team.venue.name + '. '

                      let gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                      let gameHours = 3
                      // Handle suspended, TBD, and doubleheaders
                      if ( cache_data.dates[i].games[j].status.resumedFrom ) {
                        gameHours = 1
                        if ( cache_data.dates[i].games[j].description ) {
                          description += cache_data.dates[i].games[j].description
                        } else {
                          description += 'Resumption of suspended game.'
                        }
                        gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                        gameDate.setHours(gameDate.getHours()+1)
                      } else if ( (cache_data.dates[i].games[j].status.startTimeTBD == true) && (cache_data.dates[i].games[j].doubleHeader == 'Y') && (cache_data.dates[i].games[j].gameNumber == 2) ) {
                        description += 'Start time TBD.'
                        gameDate = new Date(cache_data.dates[i].games[j-1].gameDate)
                        gameDate.setHours(gameDate.getHours()+4)
                      } else if ( cache_data.dates[i].games[j].status.startTimeTBD == true ) {
                        continue
                      }
                      let start = this.convertDateToXMLTV(gameDate)
                      gameDate.setHours(gameDate.getHours()+gameHours)
                      let stop = this.convertDateToXMLTV(gameDate)

                      programs += await this.generate_xml_program(channelid, start, stop, title, description, logo)

                      break
                    }
                  }
                }
              }
            } else {
              // Begin MLB games
              // check blackout status, if necessary
              let gamePk = cache_data.dates[i].games[j].gamePk.toString()
              if ( (mediaType == 'MLBTV') && (includeBlackouts == 'false') && blackouts[gamePk] ) {
                continue
              }

              if ( cache_data.dates[i].games[j].content && cache_data.dates[i].games[j].content.media && cache_data.dates[i].games[j].content.media.epg ) {
                for (var k = 0; k < cache_data.dates[i].games[j].content.media.epg.length; k++) {
                  let mediaTitle = cache_data.dates[i].games[j].content.media.epg[k].title
                  if ( mediaType == mediaTitle ) {
                    // initial loop will count number of broadcasts
                    let broadcast_count = await this.count_broadcasts(cache_data.dates[i].games[j].content.media.epg[k].items, mediaType, mediaTitle, language)

                    for (var x = 0; x < cache_data.dates[i].games[j].content.media.epg[k].items.length; x++) {
                      // for video, check that it's not in-market
                      if ( (mediaType == 'MLBTV') && await this.check_in_market(cache_data.dates[i].games[j].content.media.epg[k].items[x]) ) {
                        continue
                      }

                      if ( ((typeof cache_data.dates[i].games[j].content.media.epg[k].items[x].language) == 'undefined') || ((mediaType == 'Audio') && (cache_data.dates[i].games[j].content.media.epg[k].items[x].language == language)) ) {
                        let teamType = cache_data.dates[i].games[j].content.media.epg[k].items[x][mediaFeedType]

                        if ( (mediaType == 'MLBTV') && (cache_data.dates[i].games[j].seriesDescription != 'Regular Season') && (cache_data.dates[i].games[j].seriesDescription != 'Spring Training') ) {
                          teamType = 'NATIONAL'
                        }
                        let team = cache_data.dates[i].games[j].teams['home'].team.abbreviation
                        let opponent_team = cache_data.dates[i].games[j].teams['away'].team.abbreviation

                        let station = cache_data.dates[i].games[j].content.media.epg[k].items[x].callLetters

                        if ( teamType == 'NATIONAL' ) {
                          if ( dateIndex[mediaTitle] > prevDateIndex[mediaTitle] ) {
                            prevDateIndex[mediaTitle] = dateIndex[mediaTitle]
                            gameCounter[mediaTitle] = 1
                          } else {
                            gameCounter[mediaTitle] += 1
                          }
                        } else {
                          teamType = teamType.toLowerCase()
                          let opponent_teamType = 'away'
                          if ( teamType == 'away' ) {
                            opponent_teamType = 'home'
                          }
                          team = cache_data.dates[i].games[j].teams[teamType].team.abbreviation
                          opponent_team = cache_data.dates[i].games[j].teams[opponent_teamType].team.abbreviation
                        }
                        if ( (excludeTeams.length > 0) && (excludeTeams.includes(team) || excludeTeams.includes(opponent_team) || ((teamType == 'NATIONAL') && excludeTeams.includes(teamType))) ) {
                          continue
                        } else if ( (includeTeams.length == 0) || includeTeams.includes(team) || ((teamType == 'NATIONAL') && (includeTeams.includes(teamType) || includeTeams.includes(opponent_team))) || ((broadcast_count == 1) && includeTeams.includes(opponent_team)) || (cache_data.dates[i].games[j].content.media.freeGame && includeTeams.includes('FREE')) ) {
                          if ( (broadcast_count == 1) && !includeTeams.includes(team) && includeTeams.includes(opponent_team) ) {
                            team = opponent_team
                          }
                          if ( (teamType == 'NATIONAL') && ((includeTeams.length == 0) || ((includeTeams.length > 0) && includeTeams.includes(teamType))) ) {
                            team = teamType + '.' + gameCounter[mediaTitle]
                          } else if ( includeTeams.includes('FREE') && cache_data.dates[i].games[j].content.media.freeGame ) {
                            if ( dateIndex['Free'] > prevDateIndex['Free'] ) {
                              prevDateIndex['Free'] = dateIndex['Free']
                              gameCounter['Free'] = 1
                            } else {
                              gameCounter['Free'] += 1
                            }
                            team = 'FREE.' + gameCounter['Free']
                          }

                          let icon
                          if ( cache_data.dates[i].games[j].seriesDescription == 'All-Star Game' ) {
                            icon = server + '/image.svg?teamId=' + cache_data.dates[i].games[j].content.media.epg[k].items[x].mediaFeedSubType
                            if ( this.protection.content_protect ) icon += '&content_protect=' + this.protection.content_protect
                          } else {
                            icon = 'https://img.mlbstatic.com/mlb-photos/image/upload/ar_167:215,c_crop/fl_relative,l_team:' + cache_data.dates[i].games[j].teams['home'].team.id + ':fill:spot.png,w_1.0,h_1,x_0.5,y_0,fl_no_overflow,e_distort:100p:0:200p:0:200p:100p:0:100p/fl_relative,l_team:' + cache_data.dates[i].games[j].teams['away'].team.id + ':logo:spot:current,w_0.38,x_-0.25,y_-0.16/fl_relative,l_team:' + cache_data.dates[i].games[j].teams['home'].team.id + ':logo:spot:current,w_0.38,x_0.25,y_0.16/w_750/team/' + cache_data.dates[i].games[j].teams['away'].team.id + '/fill/spot.png'
                          }

                          let channelid = mediaType
                          if ( language == 'es' ) {
                            channelid = 'Spanish'
                          }
                          channelid += '.' + team
                          let streamMediaType = mediaType
                          let channelMediaType = mediaType
                          if ( mediaType == 'MLBTV' ) {
                            streamMediaType = 'Video'
                          } else if ( language == 'es' ) {
                            streamMediaType = 'Spanish'
                            channelMediaType = 'Spanish'
                          }
                          let stream = server + '/stream.m3u8?team=' + encodeURIComponent(team) + '&mediaType=' + streamMediaType
                          if ( streamMediaType == 'Video' ) {
                            stream += '&resolution=' + resolution
                          }
                          if ( includeBlackouts == 'true' ) stream += '&includeBlackouts=' + includeBlackouts
                          if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
                          if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)

                          let logo = server
                          if ( (teamType == 'NATIONAL') && ((includeTeams.length == 0) || ((includeTeams.length > 0) && includeTeams.includes(teamType))) ) {
                            logo += '/image.svg?teamId=MLB'
                            if ( this.protection.content_protect ) logo += '&content_protect=' + this.protection.content_protect
                            nationalChannels[channelid] = await this.create_channel_object(channelid, logo, stream, channelMediaType)
                          } else {
                            logo += '/image.svg?teamId=' + cache_data.dates[i].games[j].content.media.epg[k].items[x].mediaFeedSubType
                            if ( this.protection.content_protect ) logo += '&content_protect=' + this.protection.content_protect
                            channels[channelid] = await this.create_channel_object(channelid, logo, stream, channelMediaType)
                          }

                          let title = 'MLB Baseball: ' + cache_data.dates[i].games[j].teams['away'].team.teamName + ' at ' + cache_data.dates[i].games[j].teams['home'].team.teamName + ' (' + station
                          if ( language == 'es' ) {
                            title += ' Spanish'
                          }
                          if ( mediaType == 'Audio' ) {
                            title += ' Radio'
                          }
                          title += ')'

                          let description = ''
                          if ( cache_data.dates[i].games[j].doubleHeader != 'N' ) {
                            description += 'Game ' + cache_data.dates[i].games[j].gameNumber + '. '
                          }
                          if ( (cache_data.dates[i].games[j].teams['away'].probablePitcher && cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName) || (cache_data.dates[i].games[j].teams['home'].probablePitcher && cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName) ) {
                            if ( cache_data.dates[i].games[j].teams['away'].probablePitcher && cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName ) {
                              description += cache_data.dates[i].games[j].teams['away'].probablePitcher.fullName
                            } else {
                              description += 'TBD'
                            }
                            description += ' vs. '
                            if ( cache_data.dates[i].games[j].teams['home'].probablePitcher && cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName ) {
                              description += cache_data.dates[i].games[j].teams['home'].probablePitcher.fullName
                            } else {
                              description += 'TBD'
                            }
                            description += '. '
                          }

                          let gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                          let gameHours = 3
                          // Handle suspended, TBD, and doubleheaders
                          if ( cache_data.dates[i].games[j].status.resumedFrom ) {
                            gameHours = 1
                            if ( cache_data.dates[i].games[j].description ) {
                              description += cache_data.dates[i].games[j].description
                            } else {
                              description += 'Resumption of suspended game.'
                            }
                            gameDate = new Date(cache_data.dates[i].games[j].gameDate)
                            gameDate.setHours(gameDate.getHours()+1)
                          } else if ( (cache_data.dates[i].games[j].status.startTimeTBD == true) && (cache_data.dates[i].games[j].doubleHeader == 'Y') && (cache_data.dates[i].games[j].gameNumber == 2) ) {
                            description += 'Start time TBD.'
                            gameDate = new Date(cache_data.dates[i].games[j-1].gameDate)
                            gameDate.setHours(gameDate.getHours()+4)
                          } else if ( cache_data.dates[i].games[j].status.startTimeTBD == true ) {
                            continue
                          }
                          let start = this.convertDateToXMLTV(gameDate)
                          gameDate.setHours(gameDate.getHours()+gameHours)
                          let stop = this.convertDateToXMLTV(gameDate)

                          programs += await this.generate_xml_program(channelid, start, stop, title, description, icon)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        channels = this.sortObj(channels)
        channels = Object.assign(channels, nationalChannels)

        // Big Inning
        if ( mediaType == 'MLBTV' ) {
          if ( (excludeTeams.length > 0) && excludeTeams.includes('BIGINNING') ) {
            // do nothing
          } else if ( (includeTeams.length == 0) || includeTeams.includes('BIGINNING') ) {
            let logo = 'https://img.mlbstatic.com/mlb-images/image/private/ar_16:9,g_auto,q_auto:good,w_372,c_fill,f_jpg/mlb/uwr8vepua4t1fe8uwyki'
            let channelid = mediaType + '.BIGINNING'
            if ( this.protection.content_protect ) logo += '&content_protect=' + this.protection.content_protect
            let stream = server + '/stream.m3u8?event=biginning&mediaType=Video&resolution=' + resolution
            if ( this.protection.content_protect ) stream += '&content_protect=' + this.protection.content_protect
            if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
            channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

            let title = 'MLB Big Inning'
            let description = 'Live look-ins and big moments from around the league'

            if ( cache_data.dates && cache_data.dates[0] && (cache_data.dates[0].date >= today) && cache_data.dates[0].games && (cache_data.dates[0].games.length > 0) && cache_data.dates[0].games[0] && (cache_data.dates[0].games[0].seriesDescription == 'Regular Season') ) {
              await this.getBigInningSchedule()
            }

            for (var i = 0; i < cache_data.dates.length; i++) {
              let gameDate = cache_data.dates[i].date
              if ( this.cache.bigInningSchedule[gameDate] && this.cache.bigInningSchedule[gameDate].start ) {
                let start = this.convertDateToXMLTV(new Date(this.cache.bigInningSchedule[gameDate].start))
                let stop = this.convertDateToXMLTV(new Date(this.cache.bigInningSchedule[gameDate].end))

                programs += await this.generate_xml_program(channelid, start, stop, title, description, logo)
              }
            }
          }
        }

        // Game Changer
        if ( mediaType == 'MLBTV' ) {
          if ( (excludeTeams.length > 0) && excludeTeams.includes('GAMECHANGER') ) {
            // do nothing
          } else if ( (includeTeams.length == 0) || includeTeams.includes('GAMECHANGER') ) {
            let channelid = mediaType + '.GAMECHANGER'
            let logo = server + '/image.svg?teamId=MLB'
            if ( this.protection.content_protect ) logo += '&content_protect=' + this.protection.content_protect
            let stream = server + '/gamechanger.m3u8?resolution=' + resolution
            if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
            channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

            let title = 'MLB.TV Game Changer'
            let description = 'Automatically switches between the highest leverage active live games.'

            for (var i = 0; i < cache_data.dates.length; i++) {
              if ( cache_data.dates[i].games.length > 1 ) {
                let gameIndexes = gameIndexes_obj[cache_data.dates[i].date]
                if ( (typeof gameIndexes.firstGameIndex !== 'undefined') && (typeof gameIndexes.lastGameIndex !== 'undefined') && (gameIndexes.firstGameIndex !== gameIndexes.lastGameIndex) ) {
                  let gameDate = new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate)
                  let start = this.convertDateToXMLTV(gameDate)
                  gameDate = new Date(cache_data.dates[i].games[gameIndexes.lastGameIndex].gameDate)
                  gameDate.setHours(gameDate.getHours()+4)
                  let stop = this.convertDateToXMLTV(gameDate)

                  programs += await this.generate_xml_program(channelid, start, stop, title, description, logo)
                }
              }
            }
          }
        }

        // Multiview
        if ( (mediaType == 'MLBTV') && (typeof this.data.multiviewStreamURLPath !== 'undefined') ) {
          if ( (excludeTeams.length > 0) && excludeTeams.includes('MULTIVIEW') ) {
            // do nothing
          } else if ( (includeTeams.length == 0) || includeTeams.includes('MULTIVIEW') ) {
            let channelid = mediaType + '.MULTIVIEW'
            let logo = server + '/image.svg?teamId=MLB'
            if ( this.protection.content_protect ) logo += '&content_protect=' + this.protection.content_protect
            let stream = server.replace(':' + this.data.port, ':' + this.data.multiviewPort) + this.data.multiviewStreamURLPath
            if ( pipe == 'true' ) stream = await this.convert_stream_to_pipe(stream, channelid)
            channels[channelid] = await this.create_channel_object(channelid, logo, stream, mediaType)

            let title = 'MLB.TV Multiview'
            let description = 'Watch up to 4 games at once. Requires starting the multiview stream in the web interface first, and stopping it when done.'

            for (var i = 0; i < cache_data.dates.length; i++) {
              if ( cache_data.dates[i].games.length > 1 ) {
                let gameIndexes = gameIndexes_obj[cache_data.dates[i].date]
                if ( (typeof gameIndexes.firstGameIndex !== 'undefined') && (typeof gameIndexes.lastGameIndex !== 'undefined') ) {
                  let gameDate = new Date(cache_data.dates[i].games[gameIndexes.firstGameIndex].gameDate)
                  let start = this.convertDateToXMLTV(gameDate)
                  gameDate = new Date(cache_data.dates[i].games[gameIndexes.lastGameIndex].gameDate)
                  gameDate.setHours(gameDate.getHours()+4)
                  let stop = this.convertDateToXMLTV(gameDate)

                  programs += await this.generate_xml_program(channelid, start, stop, title, description, logo)
                }
              }
            }
          }
        }

        var body = ''

        // output M3U channel data, if requested
        if ( dataType == 'channels' ) {
          let channelnumber = startingChannelNumber
          body = '#EXTM3U' + "\n"
          for (const [key, value] of Object.entries(channels)) {
            body += '#EXTINF:-1 CUID="' + key + '" channelID="' + key + '" tvg-num="1.' + channelnumber + '" tvg-chno="1.' + channelnumber + '" tvg-id="' + key + '" tvg-name="' + key + '" tvg-logo="' + value.logo + '" group-title="' + value.mediatype + '",' + key + "\n"
            body += value.stream + "\n"
            channelnumber++
          }
        // otherwise output XML guide data
        } else {
          body = '<?xml version="1.0" encoding="UTF-8"?>' + "\n" +
          '<!DOCTYPE tv SYSTEM "xmltv.dd">' + "\n" +
          '  <tv generator-info-name="mlbserver" source-info-name="mlbserver">'
          for (const [key, value] of Object.entries(channels)) {
            body += "\n" + '    <channel id="' + key + '">' + "\n" +
            '      <display-name>' + value.name + '</display-name>' + "\n" +
            '      <icon src="' + value.logo + '"></icon>' + "\n" +
            '    </channel>'
          }
          body += programs + "\n" + '  </tv>'
        }

        return body
      }
    } catch(e) {
      this.log('getTVData error : ' + e.message)
    }
  }

  // Get image from cache or request
  async getImage(teamId) {
    this.debuglog('getImage ' + teamId)
    let imagePath = path.join(this.CACHE_DIRECTORY, teamId + '.svg')
    if ( fs.existsSync(imagePath) ) {
      this.debuglog('using cached image for ' + teamId)
      return fs.readFileSync(imagePath)
    } else {
      this.debuglog('requesting new image for ' + teamId)
      let imageURL = 'https://www.mlbstatic.com/team-logos/' + teamId + '.svg'
      if ( teamId == 'MLB' ) {
        imageURL = 'https://www.mlbstatic.com/team-logos/league-on-dark/1.svg'
      }
      let reqObj = {
        url: imageURL,
        headers: {
          'User-agent': USER_AGENT,
          'origin': 'https://www.mlb.com'
        }
      }
      var response = await this.httpGet(reqObj, false)
      if ( response ) {
        this.debuglog('getImage response : ' + response)
        fs.writeFileSync(imagePath, response)
      } else {
        this.debuglog('failed to get image for ' + teamId)
      }
    }
  }

  // Get airings data for a game
  async getAiringsData(contentId, gamePk = false) {
    try {
      this.debuglog('getAiringsData')

      let cache_data
      let cache_name = contentId
      let data_url = 'https://search-api-mlbtv.mlb.com/svc/search/v2/graphql/persisted/query/core/Airings'
      let qs = { variables: '%7B%22contentId%22%3A%22' + contentId + '%22%7D' }
      if ( gamePk ) {
        this.debuglog('getAiringsData for game ' + gamePk)
        cache_name = 'a' + gamePk
        data_url = 'https://search-api-mlbtv.mlb.com/svc/search/v2/graphql/persisted/query/core/Airings?variables={%22partnerProgramIds%22%3A[%22' + gamePk + '%22]}'
        qs = {}
      } else {
        this.debuglog('getAiringsData for content ' + contentId)
      }
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.airings || !this.cache.airings[cache_name] || !this.cache.airings[cache_name].airingsCacheExpiry || (currentDate > new Date(this.cache.airings[cache_name].airingsCacheExpiry)) ) {
        let reqObj = {
          url: data_url,
          qs: qs,
          headers: {
            'Accept': 'application/json',
            'X-BAMSDK-Version': BAM_SDK_VERSION,
            'X-BAMSDK-Platform': PLATFORM,
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 hour from now
          let oneHourFromNow = new Date()
          oneHourFromNow.setHours(oneHourFromNow.getHours()+1)
          let cacheExpiry = oneHourFromNow

          let today = this.liveDate()
          let game_date = new Date(cache_data.data.Airings[0].startDate)
          let compare_date = game_date.getFullYear() + '-' + (game_date.getMonth()+1).toString().padStart(2, '0') + '-' + game_date.getDate().toString().padStart(2, '0')

          if ( compare_date == today ) {
            if ( (cache_data.data.Airings[0].mediaConfig.productType == 'LIVE') || ((typeof cache_data.data.Airings[0].milestones !== 'undefined') && (typeof cache_data.data.Airings[0].milestones[0] !== 'undefined') && (typeof cache_data.data.Airings[0].milestones[0].milestoneTime !== 'undefined') && (typeof cache_data.data.Airings[0].milestones[0].milestoneTime[0].start !== 'undefined') && ((cache_data.data.Airings[0].milestones[0].milestoneTime[0].start > 20*60) || (cache_data.data.Airings[0].milestones[0].milestoneTime[1].start > 20*60))) ) {
              this.debuglog('setting cache expiry to 5 minutes for live or untrimmed games today')
              currentDate.setMinutes(currentDate.getMinutes()+5)
              cacheExpiry = currentDate
            }
          } else if ( compare_date < today ) {
            this.debuglog('setting cache expiry to forever for past games')
            cacheExpiry = new Date(8640000000000000)
          }

          // finally save the setting
          this.setAiringsCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached airings data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getAiringsData error : ' + e.message)
    }
  }

  // Get gameday data for a game (play and pitch data)
  async getGamedayData(contentId) {
    try {
      this.debuglog('getGamedayData')

      let gamePk = await this.getGamePkFromContentId(contentId)

      let cache_data
      let cache_name = 'g' + gamePk
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name+'.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.gameday || !this.cache.gameday[cache_name] || !this.cache.gameday[cache_name].gamedayCacheExpiry || (currentDate > new Date(this.cache.gameday[cache_name].gamedayCacheExpiry)) ) {
        let reqObj = {
          url: 'http://statsapi.mlb.com/api/v1.1/game/' + gamePk + '/feed/live',
          headers: {
            'User-agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/json'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 1 hour from now
          let oneHourFromNow = new Date()
          oneHourFromNow.setHours(oneHourFromNow.getHours()+1)
          let cacheExpiry = oneHourFromNow

          if ( (cache_data.gameData.status.abstractGameState == 'Live') && (cache_data.gameData.status.detailedState.indexOf('Suspended') != 0) ) {
            this.debuglog('setting cache expiry to 5 minutes for live game')
            currentDate.setMinutes(currentDate.getMinutes()+5)
            cacheExpiry = currentDate
          } else {
            let today = this.liveDate()

            if ( cache_data.gameData.datetime.officialDate < today ) {
              this.debuglog('setting cache expiry to forever for past games')
              cacheExpiry = new Date(8640000000000000)
            }
          }

          // finally save the setting
          this.setGamedayCacheExpiry(cache_name, cacheExpiry)
        } else {
          this.log('error : invalid response from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached gameday data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getGamedayData error : ' + e.message)
    }
  }

  // Get broadcast start timestamp
  async getBroadcastStart(contentId) {
    try {
      this.debuglog('getBroadcastStart')

      if ( !this.temp_cache[contentId] ) {
        this.temp_cache[contentId] = {}
      }

      let cache_data = await this.getAiringsData(contentId)

      let broadcast_start_offset
      let broadcast_start_timestamp

      if ( cache_data.data.Airings[0].milestones ) {
        for (var j = 0; j < cache_data.data.Airings[0].milestones.length; j++) {
          if ( cache_data.data.Airings[0].milestones[j].milestoneType == 'BROADCAST_START' ) {
            let offset_index = 1
            let offset
            if ( cache_data.data.Airings[0].milestones[j].milestoneTime[0].type == 'offset' ) {
              offset_index = 0
            }
            broadcast_start_offset = cache_data.data.Airings[0].milestones[j].milestoneTime[offset_index].start

            // Broadcast start
            broadcast_start_timestamp = new Date(cache_data.data.Airings[0].milestones[j].milestoneTime[(offset_index == 0 ? 1 : 0)].startDatetime)
            this.debuglog('broadcast start time detected as ' + broadcast_start_timestamp)
            this.debuglog('offset detected as ' + broadcast_start_offset)
            broadcast_start_timestamp.setSeconds(broadcast_start_timestamp.getSeconds()-broadcast_start_offset)
            this.debuglog('new start time is ' + broadcast_start_timestamp)
            break
          }
        }
      }

      if ( broadcast_start_offset && broadcast_start_timestamp ) {
        return { broadcast_start_offset, broadcast_start_timestamp }
      }
    } catch(e) {
      this.log('getBroadcastStart error : ' + e.message)
    }
  }

  // Get skip markers into temporary cache
  async getSkipMarkers(contentId, skip_type, start_inning, start_inning_half) {
    try {
      this.debuglog('getSkipMarkers')

      let skip_markers = []

      // assume the game starts in a break
      let break_start = 0

      // Get the broadcast start time first -- event times will be relative to this
      let broadcast_start = await this.getBroadcastStart(contentId)
      let broadcast_start_offset = broadcast_start.broadcast_start_offset
      let broadcast_start_timestamp = broadcast_start.broadcast_start_timestamp
      this.debuglog('getSkipMarkers broadcast start detected as ' + broadcast_start_timestamp + ', offset ' + broadcast_start_offset)

      // start inning 0 is simply the broadcast start offset
      if ((skip_type == 0) && (start_inning == 0)) {
        let break_end = broadcast_start_offset
        skip_markers.push({'break_start': break_start, 'break_end': break_end})
      } else {
        if (start_inning == '') {
          start_inning = 0
        }
        if (start_inning_half == '') {
          start_inning_half = 'top'
        }

        let cache_data = await this.getGamedayData(contentId)

        // make sure we have play data
        if (cache_data && cache_data.liveData && cache_data.liveData.plays && cache_data.liveData.plays.allPlays) {

          // keep track of inning, if skipping inning breaks only
          let previous_inning = 0
          let previous_inning_half = ''

          // calculate total skip time (for fun)
          let total_skip_time = 0

          // Loop through all plays
          for (var i=0; i < cache_data.liveData.plays.allPlays.length; i++) {

            // make sure start inning is valid
            if (start_inning > 0) {
              let last_play_index = cache_data.liveData.plays.allPlays.length - 1
              let final_inning = cache_data.liveData.plays.allPlays[last_play_index].about.inning
              if (start_inning >= final_inning) {
                if (start_inning > final_inning) {
                  start_inning = final_inning
                  let final_inning_half = json_source['liveData']['plays']['allPlays'][last_play_index]['about']['halfInning']
                  if ((start_inning_half == 'bottom') && (final_inning_half == 'top')) {
                    start_inning_half = final_inning_half
                  }
                }
              }
            }

            // exit loop after found inning, if not skipping any breaks
            if ((skip_type == 0) && (skip_markers.length == 1)) {
              break
            }

            let current_inning = cache_data.liveData.plays.allPlays[i].about.inning
            let current_inning_half = cache_data.liveData.plays.allPlays[i].about.halfInning
            // make sure we're past our start inning
            if ((current_inning > start_inning) || ((current_inning == start_inning) && ((current_inning_half == start_inning_half) || (current_inning_half == 'bottom')))) {
              // loop through events within each play
              for (var j=0; j < cache_data.liveData.plays.allPlays[i].playEvents.length; j++) {
                let event_end_padding = ACTION_END_PADDING
                // always exclude break types
                if (cache_data.liveData.plays.allPlays[i].playEvents[j].details && cache_data.liveData.plays.allPlays[i].playEvents[j].details.event && BREAK_TYPES.includes(cache_data.liveData.plays.allPlays[i].playEvents[j].details.event)) {
                  // if we're in the process of skipping inning breaks, treat the first break type we find as another inning break
                  if ((skip_type == 1) && (previous_inning > 0)) {
                    break_start = ((new Date(cache_data.liveData.plays.allPlays[i].playEvents[j].startTime) - broadcast_start_timestamp) / 1000) + event_end_padding
                    previous_inning = 0
                  }
                  continue
                } else {
                  if ( (j < (cache_data.liveData.plays.allPlays[i].playEvents.length - 1)) && (!cache_data.liveData.plays.allPlays[i].playEvents[j].details || !cache_data.liveData.plays.allPlays[i].playEvents[j].details.event || !ACTION_TYPES.some(v => cache_data.liveData.plays.allPlays[i].playEvents[j].details.event.includes(v))) ) {
                    event_end_padding = PITCH_END_PADDING
                  }
                  let action_index
                  // skip type 1 (breaks) && 2 (idle time) will look at all plays with an endTime
                  if ((skip_type <= 2) && cache_data.liveData.plays.allPlays[i].playEvents[j].endTime) {
                    action_index = j
                  } else if (skip_type == 3) {
                    // skip type 3 excludes non-action pitches (events that aren't last in the at-bat and don't fall under action types)
                    if ( event_end_padding == PITCH_END_PADDING ) {
                      continue
                    } else {
                      // if the action is associated with another play or the event doesn't have an end time, use the previous event instead
                      if (cache_data.liveData.plays.allPlays[i].playEvents[j].actionPlayId || ((cache_data.liveData.plays.allPlays[i].playEvents[j].endTime === 'undefined') && (j > 0))) {
                        action_index = j - 1
                      } else {
                        action_index = j
                      }
                    }
                  }
                  if (typeof action_index === 'undefined') {
                    continue
                  } else {
                    let break_end = ((new Date(cache_data.liveData.plays.allPlays[i].playEvents[action_index].startTime) - broadcast_start_timestamp) / 1000) + EVENT_START_PADDING

                    // attempt to fix erroneous timestamps, like NYY-SEA 2022-08-09, bottom 11
                    if ( break_end < break_start ) {
                      this.debuglog('getSkipMarkers adjusting break start')
                      break_start = break_end - 10

                      let prev_break = skip_markers.length-1
                      if ( (prev_break > 0) && (break_start < skip_markers[prev_break].break_end) && (skip_markers[prev_break].break_start < (skip_markers[prev_break].break_end - 40)) ) {
                        this.debuglog('getSkipMarkers adjusting previous break end')
                        skip_markers[prev_break].break_end = skip_markers[prev_break].break_start + 30
                      }
                    }

                    // if the break duration should be greater than than our specified minimum
                    // and if skip type is not 1 (inning breaks) or the inning has changed
                    // then we'll add the skip marker
                    // otherwise we'll ignore it and move on to the next one
                    if ( ((break_end - break_start) >= MINIMUM_BREAK_DURATION) && ((skip_type != 1) || (current_inning != previous_inning) || (current_inning_half != previous_inning_half)) ) {
                      skip_markers.push({'break_start': break_start, 'break_end': break_end})
                      total_skip_time += break_end - break_start
                      previous_inning = current_inning
                      previous_inning_half = current_inning_half
                      // exit loop after found inning, if not skipping breaks
                      if (skip_type == 0) {
                        break
                      }
                    }
                    break_start = ((new Date(cache_data.liveData.plays.allPlays[i].playEvents[action_index].endTime) - broadcast_start_timestamp) / 1000) + event_end_padding
                    // add extra padding for overturned review plays
                    if ( cache_data.liveData.plays.allPlays[i].reviewDetails ) {
                      let isOverturned = cache_data.liveData.plays.allPlays[i].reviewDetails.isOverturned
                      if ( (isOverturned == false) && cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews && (cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews.length > 0) ) {
                        for (var k=0; k < cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews.length; k++) {
                          isOverturned = cache_data.liveData.plays.allPlays[i].reviewDetails.additionalReviews[k].isOverturned
                          if ( isOverturned == true ) {
                            break
                          }
                        }
                      }
                      if (isOverturned) {
                        break_start += 40
                      }
                    }
                  }
                }
              }
            }
          }

          this.debuglog('getSkipMarkers found ' + new Date(total_skip_time * 1000).toISOString().substr(11, 8) + ' total skip time')
        }
      }

      this.debuglog('getSkipMarkers skip markers: ' + JSON.stringify(skip_markers))
      this.temp_cache[contentId].skip_markers = skip_markers

      return true
    } catch(e) {
      this.log('getSkipMarkers error : ' + e.message)
    }
  }

  // Get Big Inning schedule, if available
  async getBigInningSchedule(dateString = false) {
    try {
      this.debuglog('getBigInningSchedule')

      let currentDate = new Date()
      if ( !this.cache || !this.cache.bigInningScheduleCacheExpiry || (currentDate > new Date(this.cache.bigInningScheduleCacheExpiry)) ) {
        if ( !this.cache.bigInningSchedule ) this.cache.bigInningSchedule = {}
        let reqObj = {
          url: 'https://www.mlb.com/live-stream-games/big-inning',
          headers: {
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response ) {
          // disabled because it's very big!
          //this.debuglog(response)
          // break HTML into array based on table rows
          var rows = response.split('<tr>')
          // start iterating at 2 (after header row)
          for (var i=2; i<rows.length; i++) {
            // split HTML row into array with columns
            let cols = rows[i].split('<td>')

            // define some variables that persist for each row
            let parts
            let year
            let month
            let day
            let this_datestring
            let add_date = 0
            let d

            for (var j=1; j<cols.length; j++) {
              // split on closing bracket to get column text at resulting array index 0
              let col = cols[j].split('<')
              switch(j){
                // first column is date
                case 1:
                  // split date into array
                  parts = col[0].split(' ')
                  year = parts[2]
                  // get month index, zero-based
                  month = new Date(Date.parse(parts[0] +" 1, 2021")).getMonth()
                  day = parts[1].substring(0,parts[1].length-3)
                  this_datestring = new Date(year, month, day).toISOString().substring(0,10)
                  this.cache.bigInningSchedule[this_datestring] = {}
                  // increment month index (not zero-based)
                  month += 1
                  break
                // remaining columns are times
                default:
                  let hour
                  let minute = '00'
                  let ampm
                  // if time has colon, split into array on that to get hour and minute parts
                  if ( col[0].indexOf(':') > 0 ) {
                    parts = col[0].split(':')
                    hour = parseInt(parts[0])
                    minute = parts[1].substring(0,2)
                  } else {
                    hour = parseInt(col[0].substring(0,col[0].length-2))
                  }
                  ampm = col[0].substring(col[0].length-2,col[0].length)
                  // convert hour to 24-hour format
                  if ( (ampm == 'PM') || ((hour == 12) && (ampm == 'AM')) ) {
                    hour += 12
                  }
                  // these times are EDT so add 4 for UTC
                  hour += 4
                  // if hour is beyond 23, note we will have to add 1 day
                  if ( hour > 23 ) {
                    add_date = 1
                    hour -= 24
                  }

                  d = new Date(this_datestring + 'T' + hour.toString().padStart(2, '0') + ':' + minute.toString().padStart(2, '0') + ':00.000+00:00')
                  d.setDate(d.getDate()+add_date)
                  switch(j){
                    // 2nd column is start time
                    case 2:
                      this.cache.bigInningSchedule[this_datestring].start = d
                      break
                    // 3rd column is end time
                    case 3:
                      this.cache.bigInningSchedule[this_datestring].end = d
                      break
                  }
                  break
              }
            }
          }
          this.debuglog(JSON.stringify(this.cache.bigInningSchedule))

          // Default cache period is 1 day from now
          let oneDayFromNow = new Date()
          oneDayFromNow.setDate(oneDayFromNow.getDate()+1)
          let cacheExpiry = oneDayFromNow
          this.cache.bigInningScheduleCacheExpiry = cacheExpiry

          this.save_cache_data()
        } else {
          this.log('error : invalid response from url ' + reqObj.url)
        }
      } else {
        this.debuglog('using cached big inning schedule')
      }
      // If we requested the schedule for a specific date, and it exists, return it
      if ( dateString ) {
        if ( this.cache.bigInningSchedule && this.cache.bigInningSchedule[dateString] ) {
          return this.cache.bigInningSchedule[dateString]
        }
      }
    } catch(e) {
      this.log('getBigInningSchedule error : ' + e.message)
    }
  }

  // Get event data
  async getEventData() {
    try {
      this.debuglog('getEventData')

      let cache_data
      let cache_name = 'events'
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !fs.existsSync(cache_file) || !this.cache || !this.cache.eventURLCacheExpiry || (currentDate > new Date(this.cache.eventURLCacheExpiry)) ) {
        let reqObj = {
          //url: 'https://dapi.cms.mlbinfra.com/v2/content/en-us/sel-mlbtv-featured-svod-video-list',
          url: 'https://dapi.mlbinfra.com/v2/content/en-us/vsmcontents/mlb-tv-welcome-center-big-inning-show',
          headers: {
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com',
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(response)
          cache_data = JSON.parse(response)
          this.save_json_cache_file(cache_name, cache_data)

          // Default cache period is 5 minutes from now
          let fiveMinutesFromNow = new Date()
          fiveMinutesFromNow.setMinutes(fiveMinutesFromNow.getMinutes()+5)
          let cacheExpiry = fiveMinutesFromNow

          // finally save the setting
          this.cache.eventURLCacheExpiry = cacheExpiry
          this.save_cache_data()
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
          return
        }
      } else {
        this.debuglog('using cached event data')
        cache_data = this.readFileToJson(cache_file)
      }
      if (cache_data) {
        return cache_data
      }
    } catch(e) {
      this.log('getEventData error : ' + e.message)
    }
  }

  // Get event URL, used to determine the stream URL if available
  async getEventURL(eventName) {
    try {
      this.debuglog('getEventURL')

      let cache_data = await this.getEventData()

      let eventList
      if ( cache_data && cache_data.items ) {
        eventList = cache_data.items
      } else if ( cache_data && cache_data.references && cache_data.references.video ) {
        eventList = cache_data.references.video
      }

      if ( eventList ) {
        for (var i=0; i<eventList.length; i++) {
          if ( eventList[i].fields && eventList[i].fields.blurb && eventList[i].fields.url ) {
            if ( !eventList[i].fields.blurb.startsWith('LIVE') ) {
              break
            } else {
              if ( eventList[i].title ) {
                if ( (eventName == 'BIGINNING') && eventList[i].title.startsWith('LIVE') && eventList[i].title.includes('Big Inning') ) {
                  this.debuglog('active big inning url')
                  return eventList[i].fields.url
                } else if ( eventList[i].title.toUpperCase().endsWith(' VS. ' + eventName) ) {
                  this.debuglog('active ' + eventName + ' url')
                  return eventList[i].fields.url
                }
              }
            }
          }
        }
      }
    } catch(e) {
      this.log('getEventURL error : ' + e.message)
    }
  }

  // Get event stream URL
  async getEventStreamURL(eventName) {
    this.debuglog('getEventStreamURL for ' + eventName)
    if ( this.cache.media && this.cache.media[eventName] && this.cache.media[eventName].streamURL && this.cache.media[eventName].streamURLExpiry && (Date.parse(this.cache.media[eventName].streamURLExpiry) > new Date()) ) {
      this.log('using cached eventStreamURL')
      return this.cache.media[eventName].streamURL
    } else {
      var playbackURL = await this.getEventURL(eventName)
      if ( !playbackURL ) {
        this.debuglog('no active event url')
      } else {
        this.debuglog('getEventStreamURL from ' + playbackURL)
        let reqObj = {
          url: playbackURL,
          simple: false,
          headers: {
            'Authorization': 'Bearer ' + await this.getOktaAccessToken() || this.halt('missing OktaAccessToken'),
            'User-agent': USER_AGENT,
            'Accept': '*/*',
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com/',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj)
        if ( response && this.isValidJson(response) ) {
          this.debuglog('getEventStreamURL response : ' + response)
          let obj = JSON.parse(response)
          if ( obj.success && (obj.success == true) ) {
            this.debuglog('found eventStreamURL : ' + obj.data[0].value)
            this.cacheStreamURL(eventName, obj.data[0].value)
            return obj.data[0].value
          } else {
            this.log('getEventStreamURL error')
            this.log(obj.errorCode)
            this.log(obj.message)
            return
          }
        } else if ( response.startsWith('#EXTM3U') ) {
          this.debuglog('getEventStreamURL is eventURL : ' + playbackURL)
          this.cacheStreamURL(eventName, playbackURL)
          return playbackURL
        }
      }
    }
  }

  // Update blackout teams
  async updateBlackoutTeams() {
    let blackout_teams = []

    try {
      if ( /(^\d{5}$)/.test(this.credentials.zip_code) ) {
        this.log('getBlackoutTeams for zip code ' + this.credentials.zip_code)
        let reqObj = {
          url: 'https://content.mlb.com/data/blackouts/' + this.credentials.zip_code + '.json',
          headers: {
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com/'
          }
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog('getBlackoutTeams response : ' + response)
          let obj = JSON.parse(response)
          if ( obj.teams ) {
            blackout_teams = obj.teams
          }
        } else {
          this.log('error : invalid json from url ' + reqObj.url)
        }
      }
    } catch(e) {
      this.log('getBlackoutTeams error : ' + e.message)
    }

    this.log('setting blackout teams to ' + JSON.stringify(blackout_teams))
    this.credentials.blackout_teams = blackout_teams
    this.save_credentials()
  }

  // Check if Fox regional games exist for a date
  async check_regional_fox_games(games) {
    this.debuglog('check_regional_fox_games')
    let fox_start_time
    let regional_fox_games_exist = 'false'
    for (var j = 0; j < games.length; j++) {
      if ( games[j].content && games[j].content.media && games[j].content.media.epg ) {
        for (var k = 0; k < games[j].content.media.epg.length; k++) {
          if ( games[j].content.media.epg[k].title == 'MLBTV' ) {
            for (var x = 0; x < games[j].content.media.epg[k].items.length; x++) {
              if ( games[j].content.media.epg[k].items[x].callLetters == 'FOX' ) {
                if ( fox_start_time && (games[j].gameDate == fox_start_time) ) {
                  this.debuglog('check_regional_fox_games found')
                  regional_fox_games_exist = 'true'
                  break
                } else {
                  fox_start_time = games[j].gameDate
                }
              }
            }
            break
          }
        }
      }
    }
    return regional_fox_games_exist
  }

  // get all blackout games for a date
  async get_blackout_games(games, calculate_expiries=false) {
    let blackouts = {}

    let national_blackout = /(^\d{5}$)/.test(this.credentials.zip_code)

    let regional_fox_games_exist
    for (var j = 0; j < games.length; j++) {
      let game_pk = games[j].gamePk.toString()
      if ( games[j].content && games[j].content.media && games[j].content.media.epg ) {
        for (var k = 0; k < games[j].content.media.epg.length; k++) {
          if ( games[j].content.media.epg[k].title == 'MLBTV' ) {
            for (var x = 0; x < games[j].content.media.epg[k].items.length; x++) {
              if (games[j].content.media.epg[k].items[x].mediaFeedType == 'NATIONAL') {
                if ( national_blackout && (games[j].content.media.epg[k].items[x].callLetters == 'FOX') && (games[j].seriesDescription == 'Regular Season') ) {
                  if ( !regional_fox_games_exist ) {
                    regional_fox_games_exist = await this.check_regional_fox_games(games)
                  }
                  if ( regional_fox_games_exist == 'false' ) {
                    blackouts[game_pk] = { blackout_type:'National' }
                    break
                  }
                } else {
                  if ( (games[j].seriesDescription != 'Spring Training') && (games[j].seriesDescription != 'Regular Season') ) {
                    blackouts[game_pk] = { blackout_type:'International' }
                  } else if ( national_blackout ) {
                    blackouts[game_pk] = { blackout_type:'National' }
                  }
                  break
                }
              }

              let awayteam = games[j].teams['away'].team.abbreviation
              let hometeam = games[j].teams['home'].team.abbreviation
              if ( (games[j].seriesDescription != 'Spring Training') && (this.credentials.blackout_teams.includes(hometeam) || this.credentials.blackout_teams.includes(awayteam)) ) {
                blackouts[game_pk] = { blackout_type:'Local' }
                break
              }
            }
            break
          }
        }

        // add blackout expiry, if requested
        if ( blackouts[game_pk] && calculate_expiries && await this.check_game_time(games[j]) ) {
          let blackoutExpiry = await this.get_blackout_expiry(games[j])
          blackouts[game_pk].blackoutExpiry = blackoutExpiry
        }
      }
    }

    return blackouts
  }

  async resetGameChanger(id, includeTeams, excludeTeams) {
    let today = this.liveDate()
    if ( !this.temp_cache.gamechanger || !this.temp_cache.gamechanger.date || (this.temp_cache.gamechanger.date != today) ) {
      this.log('updating gamechanger for ' + today)
      let cache_data = await this.getDayData(today)
      let blackouts = {}
      let start
      let end
      if ( cache_data.dates && cache_data.dates[0] && cache_data.dates[0].games && (cache_data.dates[0].games.length > 0) ) {
        blackouts = await this.get_blackout_games(cache_data.dates[0].games)
        this.debuglog('Game changer blackouts ' + JSON.stringify(blackouts))

        let gameIndexes = await this.get_first_and_last_games(cache_data.dates[0].games, blackouts)
        if ( (typeof gameIndexes.firstGameIndex !== 'undefined') && (typeof gameIndexes.lastGameIndex !== 'undefined') ) {
          start = new Date(cache_data.dates[0].games[gameIndexes.firstGameIndex].gameDate)
          end = new Date(cache_data.dates[0].games[gameIndexes.lastGameIndex].gameDate)
          end.setHours(end.getHours()+4)
        }
      }
      this.temp_cache.gamechanger = {
        date: today,
        start: start,
        end: end,
        dateString: today.substring(0,4) + '/month_' + today.substring(5,7) + '/day_' + today.substring(8,10),
        blackouts: blackouts,
        gamechangerCacheExpiry: null,
        cache_data: null
      }
    }

    this.temp_cache.gamechanger[id] = {
      lastAccess: null,
      segments: [],
      sequence: 0,
      discontinuitySequence: 0,
      playlist: {},
      includeTeams: includeTeams,
      excludeTeams: excludeTeams,
      streamURL: null,
      games: [],
      players: [],
      inning_states: [],
      break_expiries: {},
      gamePk: null
    }
  }

  // get best active live game by leverage
  async getBestGame(id) {
    var game_changer_title = 'Game changer ' + id + ' '

    try {
      let cache_data
      let cache_name = 'gamechanger'
      let cache_file = path.join(this.CACHE_DIRECTORY, cache_name + '.json')
      let currentDate = new Date()
      if ( !this.temp_cache.gamechanger.cache_data || !this.temp_cache.gamechangerCacheExpiry || (currentDate > new Date(this.temp_cache.gamechangerCacheExpiry)) ) {
        this.debuglog(game_changer_title + 'fetching new gamechanger data')
        let cacheExpiry = new Date()
        cacheExpiry.setSeconds(cacheExpiry.getSeconds()+9)
        this.temp_cache.gamechangerCacheExpiry = cacheExpiry
        let reqObj = {
          url: 'http://gd2.mlb.com/components/game/mlb/year_' + this.temp_cache.gamechanger.dateString + '/master_scoreboard.json',
          headers: {
            'User-Agent': USER_AGENT,
            'Origin': 'https://www.mlb.com',
            'Referer': 'https://www.mlb.com',
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip, deflate, br'
          },
          gzip: true
        }
        var response = await this.httpGet(reqObj, false)
        if ( response && this.isValidJson(response) ) {
          this.debuglog(game_changer_title + 'valid json response')
          this.debuglog(response)
          this.temp_cache.gamechanger.cache_data = JSON.parse(response)
        } else {
          this.log(game_changer_title + 'error : invalid json from url ' + reqObj.url)
          return
        }
      } else {
        this.debuglog(game_changer_title + 'using cached gamechanger data')
      }
      cache_data = this.temp_cache.gamechanger.cache_data

      if ( cache_data ) {
        if ( cache_data.data && cache_data.data.games && cache_data.data.games.game && (cache_data.data.games.game.length > 0) ) {
          var games = []
          var best_games = []
          var players = {}
          var inning_states
          var omitted_games
          // if we don't have a current game, and nothing is found on loop #1, expand the criteria to include:
          // 2. challenge/replay review games
          // 3. games in break
          // 4. warmup
          for (var x=1; x<5; x++) {
            inning_states = {}
            omitted_games = {'excluded': [], 'blackout': [], 'warmup': [], 'inactive': [], 'break': [], 'pitching_change': [], 'review': []}

            // reset all break expiries if we're on our third loop and including games in break
            if ( x == 3 ) {
              this.temp_cache.gamechanger[id].break_expiries = {}
            }

            for (var i=0; i<cache_data.data.games.game.length; i++) {
              let teams = cache_data.data.games.game[i].away_name_abbrev + '@' + cache_data.data.games.game[i].home_name_abbrev
              let game_pk = cache_data.data.games.game[i].game_pk.toString()

              // Check break expiry, if available
              if ( this.temp_cache.gamechanger[id].break_expiries[game_pk] && (this.temp_cache.gamechanger[id].break_expiries[game_pk] > currentDate) ) {
                this.debuglog(game_changer_title + teams + ' still in break')
                omitted_games.break.push(teams)
                continue
              }

              // Game is not included
              if ( (this.temp_cache.gamechanger[id].includeTeams.length > 0) && !this.temp_cache.gamechanger[id].includeTeams.includes(cache_data.data.games.game[i].away_name_abbrev) && !this.temp_cache.gamechanger[id].includeTeams.includes(cache_data.data.games.game[i].home_name_abbrev) ) {
                omitted_games.excluded.push(teams)
                continue
              }

              // Game is excluded
              if ( (this.temp_cache.gamechanger[id].excludeTeams.length > 0) && (this.temp_cache.gamechanger[id].excludeTeams.includes(cache_data.data.games.game[i].away_name_abbrev) || this.temp_cache.gamechanger[id].excludeTeams.includes(cache_data.data.games.game[i].home_name_abbrev)) ) {
                omitted_games.excluded.push(teams)
                continue
              }

              // Game is blacked out
              if ( this.temp_cache.gamechanger.blackouts[game_pk] ) {
                omitted_games.blackout.push(teams)
                continue
              }

              if ( cache_data.data.games.game[i].status.status.toLowerCase().includes('challenge') || cache_data.data.games.game[i].status.status.toLowerCase().includes('review') ) {
                // Game is in replay review
                if ( x < 2 ) {
                  omitted_games.review.push(teams)
                  continue
                }
              } else if ( cache_data.data.games.game[i].status.status == 'Warmup' ) {
                // Game is in warmup
                if ( x < 4 ) {
                  omitted_games.warmup.push(teams)
                  continue
                }
              } else if ( cache_data.data.games.game[i].status.status != 'In Progress' ) {
                // Game is otherwise not active (not started or game over)
                omitted_games.inactive.push(teams)
                continue
              }

              let inning_half = cache_data.data.games.game[i].status.inning_state
              if (inning_half == 'Bottom') {
                inning_half = 'bot'
              } else if (inning_half == 'Top') {
                inning_half = 'top'
              }

              let inning_num = parseInt(cache_data.data.games.game[i].status.inning)
              if ( Number.isNaN(inning_num) ) {
                omitted_games.inactive.push(teams)
                continue
              }
              let outs = parseInt(cache_data.data.games.game[i].status.o)
              if ( Number.isNaN(outs) ) {
                omitted_games.inactive.push(teams)
                continue
              }
              let runners_on_base = '_ _ _'
              if ( cache_data.data.games.game[i].runners_on_base ) {
                if ( cache_data.data.games.game[i].runners_on_base.runner_on_1b ) {
                  runners_on_base = '1 '
                } else {
                  runners_on_base = '_ '
                }
                if ( cache_data.data.games.game[i].runners_on_base.runner_on_2b ) {
                  runners_on_base += '2 '
                } else {
                  runners_on_base += '_ '
                }
                if ( cache_data.data.games.game[i].runners_on_base.runner_on_3b ) {
                  runners_on_base += '3'
                } else {
                  runners_on_base += '_'
                }
              }
              let balls = parseInt(cache_data.data.games.game[i].status.b)
              let strikes = parseInt(cache_data.data.games.game[i].status.s)
              let away_score = parseInt(cache_data.data.games.game[i].linescore.r.away)
              let home_score = parseInt(cache_data.data.games.game[i].linescore.r.home)

              // Game hasn't started yet
              if ( (x < 4) && (inning_num == 1) && (inning_half == 'top') && (outs == 0) && (balls == 0) && (strikes == 0) && (away_score == 0) && (runners_on_base == '_ _ _') ) {
                omitted_games.inactive.push(teams)
                continue
              }

              // Game is between innings
              if ( (inning_half == 'Middle') || (inning_half == 'End') || (outs == 3) ) {
                if ( outs == 3 ) {
                  if ( inning_half == 'top' ) {
                    inning_half = 'Middle'
                  } else if ( inning_half == 'bot' ) {
                    inning_half = 'End'
                  }
                }

                if ( (inning_half == 'Middle') || (inning_half == 'End') ) {
                  if (inning_half == 'Middle') {
                    // check for finished games
                    if ( (inning_num == 9) && (away_score < home_score) ) {
                      omitted_games.inactive.push(teams)
                      continue
                    }
                    inning_half = 'bot'
                  } else if (inning_half == 'End') {
                    // check for finished games
                    if ( (inning_num >= 9) && (away_score != home_score) ) {
                      omitted_games.inactive.push(teams)
                      continue
                    }
                    inning_half = 'top'
                    inning_num += 1
                  }

                  outs = 0
                  runners_on_base = '_ _ _'
                  balls = 0
                  strikes = 0
                }

                if ( x < 3 ) {
                  this.debuglog(game_changer_title + teams + ' inning break started or in progress')
                  omitted_games.break.push(teams)

                  // only set break expiry for active games (that already have a stored inning state)
                  if ( this.temp_cache.gamechanger[id].inning_states && (this.temp_cache.gamechanger[id].inning_states.length > 0) && this.temp_cache.gamechanger[id].inning_states[0][game_pk] ) {
                    this.setBreakExpiry(id, game_pk)
                  }

                  continue
                }
              }

              let inning_state = inning_half + ',' + inning_num
              inning_states[game_pk] = inning_state

              // if the inning state has changed, assume a break
              if ( (x < 3) && this.temp_cache.gamechanger[id].inning_states && (this.temp_cache.gamechanger[id].inning_states.length > 0) && this.temp_cache.gamechanger[id].inning_states[0][game_pk] && (inning_state != this.temp_cache.gamechanger[id].inning_states[0][game_pk]) ) {
                this.debuglog(game_changer_title + teams + ' inning break detected')
                omitted_games.break.push(teams)
                this.setBreakExpiry(id, game_pk)
                continue
              }

              // if the pitcher has changed, assume a break
              let pitcher = null
              if ( cache_data.data.games.game[i].pitcher && cache_data.data.games.game[i].pitcher.id ) {
                pitcher = cache_data.data.games.game[i].pitcher.id
                if ( (x < 3) && this.temp_cache.gamechanger[id].players && (this.temp_cache.gamechanger[id].players.length > 0) && this.temp_cache.gamechanger[id].players[0][game_pk] && (this.temp_cache.gamechanger[id].players[0][game_pk].pitcher != pitcher) ) {
                  this.debuglog(game_changer_title + teams + ' pitching change break detected')
                  omitted_games.pitching_change.push(teams)
                  this.setBreakExpiry(id, game_pk)
                  continue
                }
              }

              let batter = null
              if ( cache_data.data.games.game[i].batter && cache_data.data.games.game[i].batter.id ) {
                batter = cache_data.data.games.game[i].batter.id
              }
              let new_batter = false
              if ( ((balls == 0) && (strikes == 0)) || (balls == 4) || (strikes == 3) || (this.temp_cache.gamechanger[id].players && (this.temp_cache.gamechanger[id].players.length > 0) && this.temp_cache.gamechanger[id].players[0][game_pk] && (this.temp_cache.gamechanger[id].players[0][game_pk].batter != batter)) ) {
                new_batter = true
              }

              // bump perfect games or no hitters in the 9th inning to the top of the leverage list
              let leverage_adjust = 0
              if ( (inning_num == 9) && ((cache_data.data.games.game[i].status.is_perfect_game == 'Y') || (cache_data.data.games.game[i].status.is_no_hitter == 'Y')) ) {
                let away_hits = parseInt(cache_data.data.games.game[i].linescore.h.away)
                if ( ((away_hits == 0) && (inning_half == 'top')) || (inning_half == 'bot') ) {
                  if ( cache_data.data.games.game[i].status.is_perfect_game == 'Y' ) {
                    this.debuglog(game_changer_title + 'adjusting ' + teams + ' for perfect game')
                    leverage_adjust = MAX_LEVERAGE * 2
                  } else{
                    this.debuglog(game_changer_title + 'adjusting ' + teams + ' for no hitter')
                    leverage_adjust = MAX_LEVERAGE
                  }
                }
              }

              let run_differential_index = Math.max(-4, Math.min((home_score - away_score), 4)) + 4
              let inning_num_index = Math.min(inning_num, 9)

              let leverage_index = LI_TABLE[inning_num_index][inning_half][runners_on_base][outs][run_differential_index] + leverage_adjust

              games.push({
                'leverage_index': leverage_index,
                'teams': teams,
                'away_score': away_score,
                'home_score': home_score,
                'inning_half': inning_half,
                'inning_num': inning_num,
                'outs': outs,
                'runners_on_base': runners_on_base,
                'balls': balls,
                'strikes': strikes,
                'new_batter': new_batter,
                'game_pk': game_pk
              })

              players[game_pk] = {'pitcher': pitcher, 'batter': batter}
            }

            if ( this.temp_cache.gamechanger[id].gamePk || (games.length > 0) ) {
              break
            }
          }
          this.debuglog(game_changer_title + 'omitted games ' + JSON.stringify(omitted_games))

          if ( games.length > 0 ) {
            //best_games = games.sort(this.GetSortOrderReverse('leverage_index'))
            // sort games by leverage index (desc), then inning number (desc), then inning half (bottom then top), then finally outs (desc)
            best_games = games.sort(function (a, b) {
              return b.leverage_index - a.leverage_index || b.inning_num - a.inning_num || a.inning_half.localeCompare(b.inning_half) || b.outs - a.outs;
            })
          }
          this.debuglog(game_changer_title + 'live sorted games ' + JSON.stringify(best_games))
          this.debuglog(game_changer_title + 'players ' + JSON.stringify(players))
          this.debuglog(game_changer_title + 'inning states ' + JSON.stringify(inning_states))
          this.debuglog(game_changer_title + 'break expiries ' + JSON.stringify(this.temp_cache.gamechanger[id].break_expiries))

          if ( !this.temp_cache.gamechanger[id].games ) this.temp_cache.gamechanger[id].games = []
          this.temp_cache.gamechanger[id].games.push(best_games)
          let maxlength = (this.gamechanger_delay + 10) / 10
          while ( this.temp_cache.gamechanger[id].games.length > maxlength ) {
            this.temp_cache.gamechanger[id].games.shift()
          }
          if ( !this.temp_cache.gamechanger[id].players ) this.temp_cache.gamechanger[id].players = []
          this.temp_cache.gamechanger[id].players.push(players)
          while ( this.temp_cache.gamechanger[id].players.length > maxlength ) {
            this.temp_cache.gamechanger[id].players.shift()
          }
          if ( !this.temp_cache.gamechanger[id].inning_states ) this.temp_cache.gamechanger[id].inning_states = []
          this.temp_cache.gamechanger[id].inning_states.push(inning_states)
          while ( this.temp_cache.gamechanger[id].inning_states.length > maxlength ) {
            this.temp_cache.gamechanger[id].inning_states.shift()
          }

          best_games = this.temp_cache.gamechanger[id].games[0]
          if ( maxlength > 1 ) {
            this.debuglog(game_changer_title + 'delayed sorted games ' + JSON.stringify(best_games))
          }
          if ( (best_games.length == 0) || (this.temp_cache.gamechanger[id].gamePk && (best_games[0].game_pk == this.temp_cache.gamechanger[id].gamePk)) ) {
            this.debuglog(game_changer_title + 'best game has not changed')
            return
          } else {
            // Update state of curr_game
            let curr_game
            let curr_game_below_avg = false
            if ( this.temp_cache.gamechanger[id].gamePk ) {
              for (var i=0; i<best_games.length; i++) {
                if ( this.temp_cache.gamechanger[id].gamePk == best_games[i].game_pk ) {
                  curr_game = best_games[i]
                  if ( curr_game.leverage_index < 1.0 ) {
                    curr_game_below_avg = true
                  }
                  break
                }
              }
            }
            if ( curr_game && (best_games.length > 0) && (curr_game.leverage_index == best_games[0].game_pk) ) {
              this.debuglog(game_changer_title + 'current game still best or tied for best')
              return
            }
            // Only switch games if:
            //  curr_game is None (either no curr_game or it's in commercial break)
            //  The change in leverage is > 1.5 and there's a new batter in curr_game
            //  game has a better leverage than curr_game and curr_game is below average leverage (1.0) and there's a new batter in curr_game
            for (var i=0; i<best_games.length; i++) {
              let large_leverage_diff = false
              if ( curr_game && ((best_games[i].leverage_index - curr_game.leverage_index) > 1.5) ) {
                large_leverage_diff = true
              }
              let game_better = false
              if ( curr_game && (best_games[i].leverage_index > curr_game.leverage_index) ) {
                game_better = true
              }
              if ( !curr_game || (curr_game.new_batter && (large_leverage_diff || (curr_game_below_avg && game_better))) ) {
                curr_game = best_games[i]
                this.log(game_changer_title + 'loading game ' + curr_game.teams)
                this.temp_cache.gamechanger[id].gamePk = curr_game.game_pk
                // get stream URL
                let favTeamBroadcast
                let mediaId
                let streamURL
                let airings_data = await this.getAiringsData('', curr_game.game_pk)
                if ( airings_data.data && airings_data.data.Airings && (airings_data.data.Airings.length > 0) ) {
                  for (var y = 0; y < airings_data.data.Airings.length; y++) {
                    if ( (airings_data.data.Airings[y].mediaConfig.type == 'VIDEO') && (airings_data.data.Airings[y].mediaConfig.productType == 'LIVE') && (airings_data.data.Airings[y].mediaConfig.state == 'ON') ) {
                      // prefer fav team broadcasts
                      if ( this.credentials.fav_teams.length > 0 ) {
                        for (var z = 0; z < this.credentials.fav_teams.length; z++) {
                          if ( airings_data.data.Airings[y].feedSubType == TEAM_IDS[this.credentials.fav_teams[z]] ) {
                            this.debuglog(game_changer_title + 'found fav team broadcast')
                            favTeamBroadcast = true
                            mediaId = airings_data.data.Airings[y].mediaId
                            break
                          }
                        }
                        if ( favTeamBroadcast ) {
                          break
                        }
                      }

                      // fall back to home or national broadcast
                      if ( !mediaId || (airings_data.data.Airings[y].feedType == 'Home') || (airings_data.data.Airings[y].feedType == 'National') ) {
                        this.debuglog(game_changer_title + 'found ' + airings_data.data.Airings[y].feedType + ' broadcast')
                        mediaId = airings_data.data.Airings[y].mediaId
                      }
                    }
                  }
                  if ( mediaId ) {
                    streamURL = await this.getStreamURL(mediaId)
                  } else {
                    this.log(game_changer_title + 'failed to find mediaId for ' + curr_game.game_pk)
                  }
                  if ( streamURL ) {
                    // always convert the stream URL to variant form
                    streamURL = streamURL.slice(0, streamURL.lastIndexOf('/'))
                    return streamURL
                  } else {
                    this.log(game_changer_title + 'failed to find streamURL for ' + mediaId)
                  }
                } else {
                  this.log(game_changer_title + 'failed to find airings for ' + curr_game.game_pk)
                }
              } else if ( large_leverage_diff ) {
                this.debuglog(game_changer_title + best_games[i].teams + ' is a better game, but ' + curr_game.teams + ' still has a batter at the plate')
              } else if ( game_better ) {
                this.debuglog(game_changer_title + best_games[i].teams + ' is a better game, but not enough better to switch from ' + curr_game.teams)
              }
            }
          }
        } else {
          this.log(game_changer_title + 'error : no games in date from url ' + reqObj.url)
        }
      } else {
        this.log(game_changer_title + 'error : no data found or cached')
      }
    } catch(e) {
      this.log(game_changer_title + 'getBestGame error : ' + e.message)
    }

    return
  }

  async get_first_and_last_games(games, blackouts) {
    let firstGameIndex
    for (var j = 0; j < games.length; j++) {
      let gamePk = games[j].gamePk.toString()
      if ( games[j].gameDate && !blackouts[gamePk] && !games[j].rescheduleDate && !games[j].status.startTimeTBD ) {
        firstGameIndex = j
        break
      }
    }
    let lastGameIndex
    for (var j = (games.length-1); j >= 0; j--) {
      let gamePk = games[j].gamePk.toString()
      if ( games[j].gameDate && !blackouts[gamePk] && !games[j].rescheduleDate ) {
        lastGameIndex = j
        break
      }
    }
    return { firstGameIndex, lastGameIndex }
  }

  async count_broadcasts(items, mediaType, mediaTitle, language) {
    let broadcast_count = 0
    for (var x = 0; x < items.length; x++) {
      // for video, check that it's not in-market
      if ( (mediaType == 'MLBTV') && await this.check_in_market(items[x]) ) {
        continue
      } else if ( mediaType == mediaTitle ) {
        if ( ((typeof items[x].language) == 'undefined') || ((mediaType == 'Audio') && (items[x].language == language)) ) {
          broadcast_count++
        }
      }
    }
    return broadcast_count
  }

  async check_in_market(item) {
    try {
      if ( item.mediaFeedType.startsWith('IN_MARKET_') ) {
        return true
      }
    } catch (e) {
      return false
    }
    return false
  }

  async check_pay_tv(item) {
    try {
      if ( item.foxAuthRequired || item.tbsAuthRequired || item.espnAuthRequired || item.fs1AuthRequired || item.mlbnAuthRequired ) {
        return true
      }
    } catch (e) {
      return false
    }
    return false
  }

  async get_scheduled_innings(game) {
    var scheduledInnings = '9'
    if ( game.linescore && game.linescore.scheduledInnings ) {
      scheduledInnings = game.linescore.scheduledInnings
      if ( (game.status.abstractGameState == 'Final') && game.linescore.currentInning && (game.linescore.currentInning < 9) ) {
        scheduledInnings = game.linescore.currentInning
      }
    }
    return scheduledInnings
  }

  async check_game_time(game) {
    if ( !game.resumeGameDate && !game.resumedFromDate && (game.status.startTimeTBD == false) ) {
      return true
    } else {
      return false
    }
  }

  async get_blackout_expiry(game) {
    let scheduledInnings = await this.get_scheduled_innings(game)
    // avg 9 inning game was 3:11 in 2021, or 21.22 minutes per inning
    let gameDurationMinutes = 21.22 * scheduledInnings
    // default to assuming the scheduled game time is the first pitch time
    let firstPitch = new Date(game.gameDate)
    if ( game.gameInfo ) {
      // check if firstPitch has been updated with a valid time (later than the scheduled game time)
      if ( game.gameInfo.firstPitch && (game.gameInfo.firstPitch >= game.gameDate) ) {
        firstPitch = new Date(game.gameInfo.firstPitch)
        // for completed games, get the duration too
        if ( game.gameInfo.gameDurationMinutes ) {
          gameDurationMinutes = game.gameInfo.gameDurationMinutes
          // add any delays
          if ( game.gameInfo.delayDurationMinutes ) {
            gameDurationMinutes += game.gameInfo.delayDurationMinutes
          }
        }
      }
    }
    // blackout is officially 90 minutes after game ends, but in practice, we add an extra hour
    gameDurationMinutes += 150
    let blackoutExpiry = firstPitch
    blackoutExpiry.setMinutes(blackoutExpiry.getMinutes()+gameDurationMinutes)
    return blackoutExpiry
  }

  async check_media_state(item, abstractGameState, mediaDate) {
    let mediaInfo = {}
    if ( (item.mediaState == 'MEDIA_ON') || ((mediaDate) && ((item.mediaState == 'MEDIA_ARCHIVE') || (abstractGameState == 'Final'))) ) {
      mediaInfo.mediaId = item.mediaId
      mediaInfo.contentId = item.contentId
    } else {
      this.log('event video not available')
    }
    return mediaInfo
  }

  async generate_xml_program(channelid, start, stop, title, description, icon) {
    return "\n" + '    <programme channel="' + channelid + '" start="' + start + '" stop="' + stop + '">' + "\n" +
    '      <title lang="en">' + title + '</title>' + "\n" +
    '      <desc lang="en">' + description.trim() + '</desc>' + "\n" +
    '      <category lang="en">Sports</category>' + "\n" +
    '      <icon src="' + icon + '"></icon>' + "\n" +
    '    </programme>'
  }

  async convert_stream_to_pipe(stream, channelid) {
    return 'pipe://ffmpeg -hide_banner -loglevel fatal -i "' + stream + '" -map 0:v -map 0:a -c copy -metadata service_provider="MLBTV" -metadata service_name="' + channelid + '" -f mpegts pipe:1'
  }

  async create_channel_object(channelid, logo, stream, channelMediaType) {
    let channel_object = {}
    channel_object.name = channelid
    channel_object.logo = logo
    channel_object.stream = stream
    channel_object.mediatype = channelMediaType
    return channel_object
  }

  async getAlternateAudioTracks(epg, teamType) {
    this.debuglog('alternateAudioTracks')
    let alternateAudioTracks = {}
    if ( teamType == 'NATIONAL' ) {
      teamType = 'HOME'
    }
    for (var k = 0; k < epg.length; k++) {
      let mediaTitle = epg[k].title
      if ( mediaTitle == 'Audio' ) {
        for (var x = 0; x < epg[k].items.length; x++) {
          let audioTeamType = epg[k].items[x].type
          if ( audioTeamType != teamType ) {
            if ( epg[k].items[x].language == 'en' ) {
              alternateAudioTracks['Alternate English'] = epg[k].items[x].mediaId
            } else if ( epg[k].items[x].language == 'es' ) {
              alternateAudioTracks['Alternate Spanish'] = epg[k].items[x].mediaId
            }
          }
        }
      }
    }
    return alternateAudioTracks
  }

}

module.exports = sessionClass